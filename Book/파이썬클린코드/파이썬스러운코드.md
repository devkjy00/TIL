# pythonic
프로그래밍의 관용구(idiom)는 코드를 작성하는 특별한 방법이다, 
모든 언어는 고유한 관용구를 가지고 있다
- 관용구는 더나은 성능, 실수를 줄이도록 도와준다


### 인덱스와 슬라이싱
- 파이썬은 음수 인덱스로 접근이 가능하다

- slice는 내장 객체로 직접 빌드할 수 있다
    - slice(1, 7, 2) -> [1:7:2], slice(None, 3) -> [:3]

- ***자체 시퀀스 생성***
    - 시퀀스는 ```__getitem__```과 ```__len__```을 구현하는 객체이기때문에 반복이 가능하다
    - ```__getitem__```
        - 인덱싱을 작동하도록 하는 매직 메소드이다
        - A[x]와 같은 형태를 사용하면 호출되는 메서드로 [x]를 인자값으로 받는다

    - 사용자 클래스 정의에서 ```__getitem__```구현
        - 객체를 감싸는 래퍼, 캡슐화 (포함)
            - 클래스의 속성값 list형을 대입 하고 ```__getitem__```과 ```__len__```를 구현하면 기존의 리스트의 메서드와 호환성을 유지할 수 있다
        
        - 상속을 받는 경우
            - collections.UserList 를 부모 클래스로 상속 받아서 호환성을 유지 할 수 있다
        
        - 사용자 시퀀스 구현
            - 범위로 인덱싱 할때 해당 클래스와 같은 타입의 인스턴스 여야 한다, 인덱싱후 타입이 바뀌면 안된다
            - slice에서 마지막 요소는 제외하는 관습을 지켜야 한다


### 컨텍스트 관리자(context manager)
- ```__enter__```과 ```__exit__``` 두개의 매직 메서드로 구성된다

- with문
    - 컨택스트 관리자 객체의```__enter__```를 호출하고 무엇을 반환하든 as 뒤 변수에 할당한다
    - 후에 코드가 실행될 새로운 컨텍스트로 진입한다
    - 문장이 끝나면(들여쓰기) 컨텍스트가 종료된다
    - 컨택스트 관리자 객체의 ```__exit__```을 호출한다
    - 예외, 오류가 있는 경우에도 ```__exit__```를 호출하기 때문에 안전하다
        - 예외를 ```__exit__```메소드의 인자값으로 받는다

- 컨텍스트 관리자를 디자인 할때 ```__enter__```의 반환값이 필요한지 고려해야 한다
- ```__exit__```가 예외값을 받지 않으면 None값을 가진다
    - *오류를 무시하면 안된다*

- 구현
    - 클래스 내에 ```__enter__```과 ```__exit__```를 구현
        - with문으로 호출 한다
    - ***contextlib 모듈을 사용해 쉽게 구현***
        - contextlib.contextmanager
            - 데코레이터로 함수를 컨텍스트 관리자로 변환 with문으로 호출한다
            - 함수는 제너레이터 형태여야 한다
                - yield문 이전의 코드는 ```__enter__```기능, 이후는 ```__exit__```의 기능을 한다
                - yield문으로 블록안에서 사용할 값을 반환할 수도 있다
            
            - 장점
                - 리팩토링이 쉬워진다
                - 특정 객체에 속하지 않는 컨텍스트 관리자가 필요한 경우 좋은 방법이다
                - 다른 클래스와 독립된 컨텍스트 관리자 함수를 만들때 사용하는게 좋다
        
        - contextlib.ContextDecorator
            - 컨텍스트 관리자 안에서 실행될 함수에 데코레이터를 적용하게 해주는 ***믹스인 클래스***
                - 매직메서드로 구현된 컨텍스트관리자 객체에만 사용 가능하다

            - 매직메서드가 구현된 컨텍스트 관리자 클래스에 contextlib.ContextDecorator클래스를 상속한다
            - @사용자클래스() 로 함수에 데코레이터를 랩핑한다
            - with문 없이 컨텍스트 관리자안에서 함수가 실행된다

            - 특징 
                - 완전히 독립적이다
                - with문의 as 처럼 내부에서 사용하고자 하는 값을 얻을 수 없다


            > 믹스인 클래스
            - 다른 클래스에서 필요한 기능만 섞어서 사용 할 수 있도록 메서드만 제공하는 유틸리티 형태의 클래스

        - contextlib.suppress
            - 명시된 예외가 발생하면 실패하지 않도록 한다
            - 로직에서 자체적으로 처리하고 있는 예외임을 명시(관리되고 있는 예외)
            - with contextlib.suppress(예외명): 
                - 코드 블록 내에서 명시된 예외가 발생해도 안전하다는 것을 뜻한다

### 프로퍼티, 속성과 객체 메서드의 다른 타입들
- public, private, protected 프로퍼티를 갖는 다른 언어와 달리 파이썬의 모든 객체, 함수의 프로퍼티는 public이다
    - 호출하지 못하도록 할 방법이 없다
    - 밑 줄을 사용해서 private영역의 속성임을 명시할 수는 있다

- 밑줄
    - private영역임을 명시하고 메서드에도 적용된다
    - ***객체는 외부 호출 객체와 관련된 속성과 메서드만을 노출해야한다***

- 이름 맹글링(name mangling)
    - 밑줄 두개를 사용해서 다른 이름을 만든다
        - 맹글링된 속성을 그냥 호출 하면 AttributeError이 뜬다
        - ```self.__a```는 ```self._클래스명__a```로 다른이름으로 호출 할 수 있다
        - 확장된 클래스의 메서드를 이름 충돌없이 오버라이드 하기 위해 만들어진 기능

- 프로퍼티
    - @property -> 응답하기위한 쿼리의 역할
    - @속성명.setter -> 값을 수정하는 역할
    - 속성에 대한 접근을 제어한다, 다른 언어의 접근 메서드 getter, setter와 같은 기능을 한다
        - class.attr = x 가 실행되면 호출되고 x를 인자값으로 받는다
        - get_, set_ 과 같은 메서드를 사용하는 것 보다 훨씬 간단하고 직관적인 방법이다
        - 속성값을 가져오거나 수정할 때 연산이 필요한 경우만 프로퍼티를 사용한다
    
    - 명령-조회(쿼리) 분리 원칙
        - 프로퍼티는 상태를 변경하거나 값을 반환하는 기능을 분리해서 실행할 수 있게 해준다
        - 메서드는 한가지만 해야한다

    - 다른 속성의 값을 기반으로 연산을 할때 사용하기 좋은 방법이다

### 이터러블 객체
- 이터러블 -> ```__iter__```를 구현한 객체
- 이터레이터 -> ```__next__```를 구현한 객체

- 반복 가능한 객체인지 검사하는 과정
    - 객체에 ```__iter__```, ```__next__```가 구현되었는지 확인
    - 객체가 시퀀스이고 ```__len__```, ```__getitem__```가 구현됬는지 확인


- 반복 가능한 객체 생성
    - 이터러블 객체
        - 반복명령은 iter()함수를 호출하고 ```__iter__```를 실행한다
        - ```__iter__```메서드는 자신을 반환, 이터러블 객체임을 명시한다
        - 각 루프마다 next()함수가 호출되고 ```__next__```가 실행된다
        - ```__next__```에서 StopIteration, 값을 반환, 증가하도록 정의한다
            - 한번 StopIteration이 발생하면 두번째 루프는 작동하지 않는다
        
        - 컨테이너 이터러블(container iterable)
            - ```__iter__```가 매번 새로운 제너레이터를 반환하게 해서 반복 할 수 있다
            - ```__iter__```메서드에서 반복문 실행 yield문으로 값을 반환한다
            - 매번 제너레이터를 생성해서 일반적으로 제너레이터를 사용하기 좋다
    
    - 시퀀스
        - iter()함수는 ```__iter__```가 없으면 ```__getitem__```을 실행한다
        - 이터러블 보다 많은 메모리를 사용하지만 O(1)시간복잡도로 값을 찾을 수 있다

        - ```__getitem__```
            - 시퀀스[인자값]을 반환한다
        - ```__len__```
            - len(시퀀스)를 반환 한다

        - 포함(래핑)된 객체의 메서드들과 호환성을 유지하는 좋은 방법이다
        
### 컨테이너 객체
- in 키워드로 호출한다(container.```__contains__```(element)와 같다)
- 컨테이너는 ```__contains__```를 구현한 객체로 일반적으로 Boolean 값을 반환한다
- 클래스내에 ```__contains__```매직 메소드를 위임해서 응집력을 높일 수 있다
    - 객체의 메소드 내부에 사용자 논리비교식을 정의 해서 Boolean 값을 반환 시킬수 있다
    - 외부에서 사용할 때도 직관적으로 만들 수 있다

### 객체의 동적인 속성
- ```__getattribute__```
    - 객체.속성 을 호출하면 실행된다
    - 속성 값에 접근할 수 있게 해준다
- ```__getattr__```
    - 찾는 속성이 없을 경우 호출 된다
    - 반환 값을 제어거나 새로운 속성을 만들 수도 있다
    - 값이 없으면 AttributeError를 발생시켜야 한다




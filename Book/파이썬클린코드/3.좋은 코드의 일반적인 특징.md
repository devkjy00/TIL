좋은 소프트웨어는 좋은 디자인으로부터 나온다
코드가 디자인이고, 디자인이 곧 고드이다

### 계약에 의한 디자인(Design by Contract - DbC)
컴포넌트는 기능을 숨겨서 캡슐화하고 고객에게 애플리케이션 프로그래밍 인터페이스(API)를 노출해야 한다

- 계약
    - API를 디자인 할 때 예상되는 입력,출력 및 부작용을 문서화 해야한다, 계약의 개념
    - 사전조건과 사후조건을 명시하고 불변식과 부작용을 기술한다
    - 계약을 어겼을 경우 명시적으로 예외를 발생시켜야 한다
        - 문제를 정확하게 특정하기 위해서 사용자 예외를 만드는 것이 가장 좋다

    - 오류를 쉽게 찾을 수 있고 책임의 한계를 명확히할 수 있다
        - 격리된 상태로 유지해서 사전조건,사후조건에 대한 검사 그리고 핵심 기능 구현을 구분하는 것이 좋다 

    - 사전조건 : 제공된 데이터의 유효성을 검사, 데이터베이스, 파일, 이전의 메서드 검사등
        - mypy 같은 정적 분석 도구도 효과적이지만 충분하지 않다
        - 유효성 검사를 어디서 할지를 정해야한다
            - 함수를 호출하지 전(관용적 접근법): 어떤 값이라도 수용한다
            - 함수가 자체적으로(까다로운 접근법): 안전하고 견고한 방법
            - 중복을 피해서 작성해야 한다

    - 사후조건 : 함수 반환 값의 유효성 검사
        - 특정 속성이 보존되도록 보장해야한다

    - 불변식 : docstring에 함수의 연산을 문서화
    - 부작용 : docstring에 코드의 부작용을 언급하기도 한다

    - 올바른 데이터 타입만 검사하기 보다는 특정 예외처리를 하는 것이 바람직하다

### 방어적(defensive) 프로그래밍
코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호 할 수 있게 하는 것으로 여러측면을 고려한 기술

- 에러 핸들링
    - 데이터 입력 확인 시 자주 사용하고 에러에 대해서 실행할지 중단할지를 결정하는 것이 목적
    - 에러 처리 방법
        - 값 대체
            - 결과 값을 안전한 다른 값으로 대체, 신중하게 선택해야 한다
            - 견고성과 정확성간의 트레이드 오프이다
            - 기본 값으로 대체하는 것이 안전하지만 실패하는 것이 옳을 때 도 있다
                - 오류가 있는 데이터를 유사한 값으로 대체하는 것은 위험, 오류를 숨길 수 있다
        
        - 에러 로깅

        - 예외 처리
            - 호출자에게 실패했음을 알리는 것
            - 예외 처리로 로직처리나 흐름제어를 하면 복잡해진다, 실질적 문제에만 사용
            - 캡슐화를 약화 시키기 때문에 주의, 너무 많은 예외는 여러개의 작은 것으로 나누는 것이 좋을 수 있다
            - ***올바른 수준의 추상화 단계에서 예외 처리***
                - 예외는 한가지 일을 하는 함수의 한 부분이어야 한다
                - 예외가 속한 상황의 바로 뒤에 처리해야한다
            - ***Traceback 노출 금지***
                - 특정 예외에는 trace정보, 메시지 및 수집 가능한 정보를 로그로 남기는 것이 중요하다
                - 보안을 위한 고려사항으로 사용자에게 보여서는 안된다, 중요 정보나 지적 재산의 유출이 발생할 위험
                - 예외가 발생했을때 일반적인 메시지를 사용해야 한다, "인터넷 연결 오류"
            - ***비어있는 except블록 지양***
                - 에러는 무조건 명시적으로 전달해야 한다
            - ***원본 예외 포함***
                - 오류 처리 과정에서 다른 오류를 발생시킬때 원래 예외를 포함하는 것이 좋다
                - raise e from 원래 예외
                    - 예외의 타입을 변경한다
                    - 원본 예외는 ```__cause__```속성으로 설정된다

            - ***assert 사용***
                - 불가능한 조건을 의미하는 것으로 잘못된 시나리오에 도달할 경우 프로그램을 중단 시키는 것
                - 흐름 제어에 사용하면 안된다
                - AssertionError를 처리하면 안되고(프로그램 중단이 목적) 함수로 값을 반환하는 것은 좋지 않다
    

### 관심사의 분리
책임이 다르면 컴포넌트, 계층 또는 모듈로 분리해야 파급효과를 최소화하고 유지보수성을 향상 시킬수 있다

- 응집력과 결합력
    - 응집력 : 잘 정의된 목적, 한가지 일만 잘 수행하는 철학
    - 결합력 : 객체가 서로 어떻게 의존하는지
        - 낮은 재사용성 : 지나치게 의존적이거나, 많은 인자를 가진경우 결합이 강해지고 사용이 제한적이여 진다
        - 파급(ripple)효과 : 너무 가깝게 붙어 있게 되면 예상치 못한 영향을 미친다
        - 낮은 수준의 추상화 : 결합된 객체가 서로 다른 추상화 레벨에서 문제를 해결하기 어렵다
    
    - 높은 응집력, 낮은 결합력이 바람직


### 개발 지침 약어
- DRY(Do not Repeat Yourself), OAOO(Once And Only Once)
    - 단 한번 단 한곳에 정의 되어야한다
    - 이유
        - 반복되어있는 코드를 수정하면 오류가 발생하기 쉽다
        - 수정하기 위한 비용이 비까다
        - 모든 코드의 위치를 기억해야 해서 신뢰성이 떨어지고 완결성이 떨어진다
    - 중복은 기존코드를 무시함으로써 발생한다, 중복을 피하기 위해 함수,컨텍스트 관리자, 이터레이터, 제너레이터, 데코레이터들이 도움이 된다

- YAGNI(You Ain't Gonna Need it)
    - 필요 없는 추가 개발을 하지말라

- KIS(Keep It Simple)
    - 설계할 때 과잉 엔지니어링을 피해야 한다
    - 최소한의 기능을 구현
    - 코드 측면에서 문제에 맞는 가장 작은 데이터 구조를 사용

- EAFP(Easier to Ask Forgiveness then Permission), LBYL(Look Before You Leap)
    - EAFP : 동작하지 않을 경우에 대응하는 것
    - LBYL : 먼저 무엇을 사용하려고 하는지 확인
    - 파이썬은 EAFP방식이 좋다(명시적으로 예외를 정의하는 것)

### 컴포지션과 상속
객체 지향 구조를 디자인 할때 다형성, 상속, 캡슐화 같은 개념 이용한다, 
보통은 클래스의 메서드를 결정하는 것부터 개발을 시작한다

- 상속의 좋은 예
    - public 메서드, 속성 인터페이스를 정의한 클래스를 상속 받아서 추가기능을 더하는 경우
    - 인터페이스 방식을 강제하고자 할 때 구현을 하지 않은 기본 추상클래스를 상속해서 하위 클래스에서 적절한 구현을 하도록 하는 경우
    - Exception을 상속받은 사용자 예외 클래스
    
    - 상속을 제대로 사용하면 객체를 전문화 하고 세부적인 추상화를 할 수 있다
    - 클래스의 public메서드는 부모 클래스가 정의하는 것과 일치해야한다

- 상속 안티패턴
    - 데이터 구조를 사용하는 객체를 만들지 않고 데이터 구조 자체를 객체로 만드는 건 좋지 않다
    - 일부 메서드가 필요해서 상속을 받는 것은 계층구조가 잘못된설계된것이다, 상속은 개념적 확장이 되어야 한다(이름으로 상속을 예상가능해야함)

- 컴포지션
    - 확장할 클래스를 private속성에 저장하고 필요한 메서드를 정의하고 나머지 public 메서드를 추가적으로 구현하는 것
    - 데이터 구조를 변경하려고 해도 인터페이스만 유지하면 영향을 받지 않는다
    - 결합을 줄이고 파급효과를 최소화 한다

- 파이썬의 다중상속
    - 올바르게 구현하지 않으면 문제가 커진다
    - ***메서드 결정 순서(MRO)***
        - 2개의 부모 클래스가 같은 메서드를 상속할때 먼저 상속받은 순서대로 메서드를 호출한다
        - [cls.```__name__``` for cls in 자녀클래스.mro()]
            - 결정 순서를 반환하는 명령어이다

    - ***믹스인(mixin)***
        - 코드를 재사용하기 위해 일반적인 행동을 캡슐화 해놓은 기본 클래스
        - class c (a,b): pass
            - 믹스인은 새로운 코드가 필요 없고 일종의 데코레이터 역할을한다

### 함수와 메서드의 인자
- 파이썬의 함수 인자 동작방식
    - 인자의 복사방식 : 파이썬에서 모든 인자는 값에 의해 전달된다(call by value)
        - mutable객체를 전달하고 값을 변경하면 실제 값이 변경되는 부작용 발생
        - immutable 타입을 인자로 사용하는 것이 바람직

    - 가변인자
        - 언패킹은 가독성을 높인다
    
    - 함수 인자의 개수
        - 함수 많은 인수를 받는 것은 설계문제
                    - 추상화 부족이라고 생각할 수 있다
                    - 새로운 상위레벨의 추상화 객체가 필요하거나 누락된 객체가 있음을 의미

        - 인자가 너무 많을 때 대안
            - 구체화(reification) : 전달하는 모든 인자를 포함하는 새로운 객체를 만드는것
                - 누락된 추상화를 구현하는 것
            - 가변인자,키워드 인자를 사용 하는 것(동적인 방법으로 유지보수 어려움)
                - 인터페이스에 대한 문서화 필수

### 소프트웨어 디자인 우수 사례 결론
- 소프트웨어 독립성
    - 두 요소가 독립적이라는 것, 좋은 디자인은 가능한 한 영향을 최소화 한다
    - 독립된 요소는 단위 테스트도 독립적이다

- 코드 구조
    - 큰 파일을 만드는 것보다 하나의 파일에 유사한 컴포넌트만 정리해서 구조화해야 한다
    - init파일을 가진 디렉토리 만들기
        - 다른 파일의 정의를 가져와서 호환성을 보장할 수 있다
        - 모듈에 all변수에 익스포트가 가능하도록 표시 가능

    - 장점
        - 모듈을 임포트 할 때 구몬을 분석하고 메모리에 로드할 객체가 줄어든다
        - 의존성이 줄었기 때문에 더 적은 모듈만 가져오면 된다


        

        



파이썬은 생성패턴 같은 일부의 디자인 패턴을 내부적으로 이미 구현하고 있다
객체에 어떤 종류의 커스터 마이징을 해도 특별한 팩토리 클래스가 필요없다

### 디자인 패턴
- 패턴은 생성(creational), 구조(structural), 행동(behavioral)패턴 중의 하나로 분류
- 디자인 패턴을 강제로 적용해서는 안되고 패턴이 출현할 때 까지 코드를 진화 시키고 리팩토링 하면서 개선하면서 디자인패턴을 발견하는 것이다
- 파이썬의 특수성을 감안한 디자인 패턴을 살펴보자

- 생성 패턴
    - 객체를 인스턴스화 할 때의 복잡성을 최대한 추상화하기 위 한것
    - 팩토리
        - 파이썬의 핵심기능, 모든 것이 객체라는 것
        - 클래스, 함수, 사용자 정의 객체 각각의 역할이 특별히 구분되지 않는다
        - 파이썬에서는 별로 필요하지 않다
    
    - 싱글턴과 공유상태(monostate)
        - 객체지향 소프트웨어를 위한 전역변수의 한 형태(나쁜선택일 수 있다)
            - 단위테스트가 어렵다
        - 파이썬의 모듈은 이미 싱글턴이라는 것을 의미한다
            - 여러번 임포트해도 sys.modules에 로딩되는 것은 항상 한개다

        - 공유상태
            - 싱글턴을 사용하는 것보다는 여러 인스턴스에서 사용할 수 있도록 복제하는 것이 좋다
            - 모노 스테이트 패턴의 주요개념 
                - 일반 객체처럼 많은 인스턴스를 만들 수 있어야한다
                - 내부 동작을 신경쓰지 않아도 된다
                - 클래스 속성을 사용하는 것처럼 단순하지만 속성값을 사용할 올바른 인터페이스를 제공해야한다

                ```py
                class monostate():
                    _value = None # 모든 인스턴스가 이값을 공유

                    def __init__(self, value):
                        self.value = value

                    @property
                    def value(self):
                        return self._value
                    
                    @value.setter
                    def value(self, new_value):
                        self.__class__._value = new_value
                        # type(self).value 도 작동
                ```
                - 디스크립터를 사용해서 만들 수 도 있다
                    - 클래스속성인 디스크립터객체에 값을 저장하고 인스턴스가 공유
                    - 3회 반복의 법칙 참고

    - borg 패턴
        - 실제로는 모노스테이트 패턴을 파이썬에서는 borg패턴이라고 한다
        - 같은 클래스의 모든 인스턴스가 모든 속성을 복제하는 객체를 만드는 것
        ```py
        class A:
            def __init__(self, num):
                self.num = num

        class a1(A):
            _attr = {}
            def __init__(self, num):
                self.__dict__ = self.__class__._attr
                # 인스턴스 사전경로가 클래스속성의 경로를 가리키게한다
                super().__init__(num) 
                # 인스턴스에 값을 사전에 저장하지만 저장된 경로는 클래스속성
        ```
        - 사전은 뮤터블 객체이기 때문에 같은 주소에서 값을 수정한다
            - 모든 인스턴스가 같은 값을 계속 참조할 수 있다

        - 빌더
            - 객체의 복잡한 초기화를 추상화하는 패턴
            - 필요로하는 모든 객체를 직접 생성해주는 하나의 복잡한 객체를 만든다
                - 빌더 객체는 필요한 모든 것들을 어떻게 생성하는지 연결하는지 알고있다
                - API같은 것을 노출하는 경우에만 구현한다
                    - 사용자는 최종ㄷ객체에 대한 모든 정보를 해당 인터페이스에 피라미터로 전달한다

- 구조 패턴
    - 구조 패턴은 인터페이스를 복잡하게 하지 않으면서도 기능을 확장하여 더 강력한 인터페이스 또는 객체를 만들어야 하는 상황에 유용하다
    - 어댑터 패턴
        - 호환되지 않는 두개 이상의 객체에 대한 인터페이스를 동시에 사용할 수 있게 해준다, 래퍼(wrapper)라고도 한다
        - 새로운 데이터 소스를 추가해야할 때 인터페이스 호환도 안되고 수정도 못할때
            - 수용할 수 있는 새로운 인터페이스를 개발할 수 있다
                - 사용중인 인터페이스 클래스를 상속 받는 클래스를 만들고 새로운 데이터와 호환되는 메서드를 원래 인터페이스에 있는 메서드에 포함해서 오버라이딩한다
                - 더 좋은 방법은 컴포지션을 사용하는 것이다

    - 컴포지트 패턴
        - 객체는 내부적으로 다른 여러 객체를 사용한다
        - 객체는 구조화된 트리 형태로 불 수 있다 사용자는 이중 아무거나 호출하여 원하는 결과를 얻고자 한다
        - 컴포지트 객체도 클라이언트처럼 동작한다, 요청을 관련 노드가 처리할 수 있을 때까지 계속 전달한다
    
    - 데코레이터
        - 상속을 하지 않고도 객체의 기능을 동적으로 확장할 수 있다
        - 같은 클래스를 상속받은 하위 클래스들을 중첩해서 객체를 생성하고 다형성을 이용해서 메서드를 호출한다

    - 파사드
        - 객체 간 상호 작용을 단순화 하려는 많은 상황에서 유용하다
        - 패턴은 여러 객체가 다대다 관계를 이루며 상호작용하는 경우에 사용
        - 파사드는 객채에 대한 모든 연결을 만드는 대신 파사드역할을 하는 중간 객체를 만드는 것
            - 파사드는 허브 또는 단일 참조점 역할을 한다
            - 외부 오브젝트의 입장에서는 파사드 내부의 모든 내용이 완전히 불투명해야 한다
        
        - 객체의 결합력을 낮춰주고 인터페이스개수를 줄이고 더 나은 캡슐화를 지원할 수 있다
        - 이 패턴으로 단일 인터페이스를 제공하면 단일 진리점, 코드의 진입점 역할을 해서 사용자가 노출된 기능을 쉽게 사용할수 있다(requests객체처럼)
        - 객체 뿐 아니라 패키지의 레이아웃를 결정하는데 적용된다
            - 임포트 가능한 외부용 레이아웃, 내부용 레이아웃을 구분
            - ```__init__.py```파일이 모듈의 루트로서 파사드와 같은 역할을 한다
            - init파일의 API가 유지되는 한 클라이언트에 영향을 주지 않게 된다
                - os모듈의 예로 윈도우,맥 별로 다른 posix모듈을 호출해서 적절한 기능을 제공한다

- 행동 패턴
    - 객체가 어떻게 협력, 통신하는지, 런타임중 인터페이스는 어떤 형태여야하는지에 대한 문제를 해결하는 것이 목표
    - 책임 연쇄 패턴
        - 이벤트를 연결하고 처리하려고 시도하고 처리가 불가능하면 후계자(successor)에게 전달한다
            - 객체마다 같은 메소드를 가지고 객체를 중첩해서 인스턴스 생성
            - 처리할 수 있다면 처리하고 불가능하면 중첩된 객체에게 전달한다
            ```py
            a1 = A(B())
            a1.method()
            ```
    
    - 템플릿 메서드 패턴
        - 코드의 재사용성을 높여주고 객체를 보다 유연하게 하여 다형성을 유지하면서 쉽게 수정할 수 있다
        - 행위를 정의 할 때 특정한 형태의 클래스 계층구조를 만드는 것
            - 계층구조를 이루는 모든 클래스들은 공통된 템플릿을 공유, 특정요소만 변경가능
            - 공통적인 로직을 부모 클래스의 public메서드로 구현, 내부에는 private 메서들을 호출

        - 다형성을 쉽게 보존할 수 있고 하위 클래스의 private메서드를 오버라이드하기만 하면된다
            - 반환 값의 타입이 동일하다면 하위 호환성도 유지 될 것

    - 커맨드
        - 수행해야 할 작업을 요청한 순간부터 실제 실행 시까지 분리하는 것
            - ```__call__```메서드로 호출가능한 객체를 생성하고 나중에 호출할 수 있다
            - DB와 연결하여 커서를 얻고 커서를 통해서 SQL문을 실행할 수 있다
        
        - 실행될 명령의 피라미터들을 저장하는 객체(command)를 만든다
        - 피라미터를 수정,상호작용할 수 있는 객체(invoker)를 만든다
        - 실제로 작업을 수행할 객체(receiver)를 만든다

    - 상태 패턴
        - 구체화(reification)를 도와주는 대표적 소프트웨어 디자인 패턴
        - 행동, 상태를 추가하는 일은 객체가 할 일이다, 구체화가 필요하다
            - 행동, 상태를 한 객체에 정의하면 너무 많은 책임을 갖게 된다
            - 표현하고자 하는 각 종류의 상태를 객체로 만들고 메서드를 규칙에 따라 정의
            - 더블 디스패치 메커니즘
                - 디스패치는 메서드 호출을 의미한다, 더블 디스패치의 예로 컴포지션된 객체의 메서드를 오버라이딩해서 호출하는 것

            - 추상 기본 클래스를 만들고 상속함으로써 상태 객체의 종류를 명확히하고 인터페이스의 메서드 구현을 강제할 수 있다
            - 상태를 참조하는 객체가 참조하는 상태가 바뀌면 이전의 객체는 더이상 참조하지 않고 GC로 처리되야 한다

    - Null 객체 패턴
        - 함수나 메서드는 일관된 타입을 반환해야 한다
        - 디자인 패턴의 주요 목표는 메서드나 함수가 작동하는데 필요한 구체적인 클래스를 명시하지 않는 것이다
            - 그래서 인터페이스를 새로 만들고 객체를 재배치해서 인터페이스에 적합하게 만드는 것
            - 파이썬에서는 이러한 작업 없이도 다른객체에 전달해서 사용할 수 있다
                - 그래서 메서드의 반환 값에 더 주의를 해야 한다
        
        - 일관성이 있는 타입의 객체를 반환하라
            - 예로 사용자 ID로 검색하는 명령에서 검색된 사용자가 없을 때
                - 예외 처리, UserUnknown타입(Null객체)을 반환
                - 어떠한 경우에도 None을 반환하면 안된다

        - Null객체는 아무일도 수행하지 않아야 한다
        - 테스트가 쉬워지고 로그를 추가하거나 사용된 피라미터값을 확인할수 있다


### 디자인 패턴에 대한 최종 정리
- 디자인에 대한 패턴의 영향
    - 실제로 디자인 패턴이 필요하지 않고 간단한 솔루션이 있을 수 있다 
    - 3외 반복의 법칙을 기억, 문제를 정확히 식별하고 패턴을 인지하여 추상화를 할때가 디자인패턴의 적용 고려시점
    - 패턴은 일반적으로 객체와 객체 사이의 상호작용을 의미한다
    - 파이썬에서는 이터레이터 패턴이 이미 구현되어있고 전략 패턴같은 경우 파이썬은 함수가 객체이므로 의미가 없다

- 모델의 이름
    - 디자인 패턴의 이름을 코드작성에 사용하는 것은 권장되지 않는다
        - 알 필요 없다
        - 명확한 의도를 드러내지 못한다



    


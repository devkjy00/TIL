### 파이썬의 데코레이터
함수와 메서드의 기능을 쉽게 수정하기 위한 수단
```py
def func():
    ~~~
func = modifier(func)
# 데코레이터의 원래 구현형태이다

@modifier
def func():
# 데코레이터 이후의 나온것을 첫 인수값으로 받는다
# 사실상 문법적 설탕일 뿐이다
# func는 데코레이팅된 함수, 래핑된 객체이다
```
'데코레이터 디자인 패턴'과는 다른 의미

- 함수 데코레이터
    - 인자값의 유효성 검사, 기능을 새롭게 정의, 결과를 캐쉬 하는 등의 작업
    ```py
    # 특정 예외에 대해 3번 재시도하는 데코레이터
    def retry(operation):
        @wraps(operation)
        def wrapped(*args, **kwargs):
            for _ in range(3): # 3번 시도
                try:
                    return operation(*args, **kwargs)
                except:
                    # 예외처리
            raise fail
        return wrapped
    
    @retry
    def run_operation(x):
        ~~
    ``` 

- 클래스 데코레이터
    - 인자값을 함수가 아닌 클래스로 받는다
    - 남용할 경우 가독성을 떨어뜨리기 쉽다
    - 장점
        - 코드재사용의 이점
        - 여러 클래스가 특정 인터페이스를 따르도록 강제할 수 있다
        - 여러 클래스에 검사를 데코레이터하나로 할 수 있다
        - 클래스 기능을 보강할 수 있다
        - 유지 보수시에 데코레이터를 활용하면 기존 로직을 훨씬 쉽게 변경가능
    - 다른 유형의 데코레이터
            - 제너레이터, 코루틴, 데코레이터 중첩도 가능하다


    - 인자 전달
        - 중첩된 클로저 함수보다 클래스데코레이터가 가독성이 더 좋다
        - 중첩함수의 데코레이터
            ```py
            def with_retry(x,y):
                # 데코레이터의 괄호의 인수값을 받는다 
                def retry(operation):
                    # 함수를 인자로 받는다 
                    @wraps(operation)
                    def wrapped(~~):
                        ~~
                    
                    return wrapped
                return retry
            ```      
        - 데코레이터 객체
            ```py
            class deco:
                def __init__(self, x):
                    # 데코레이터의 괄호의 인수값을 받는다
                def __call__(self, func):
                    # 함수를 인자로 받는다
            @deco()
            def func():
            ```
            - @ 연산전 피라미터를 사용해 데코레이터 객체를 생성,```__init__()```를 호출한다
            - 그 다음 @ 연산이 호출되서 함수를 래핑하고 ```__call__()```를 호출한다
    
    - 데코레이터 활용
        - 피라미터 변환: 더 직관적 API를 노출하기위해 인수값이 어떤게 처리되는지 캡슐화하여 숨길수 있다
            - 사전조건,사후조건을 강제할 수도 있다
        - 코드 추적 : 함수의 실행을 로깅
            - 실제 함수의 실행 경로 추적
            - 메모리 사용량, CPU사용률등을 모니터링
            - 실행 시간 측정
            - 언제 실행되고 전달된 피라미터는 뭔지 로깅
        - 피라미터 유효성 검사
        - 재시도 로직 구현
        - 반복 작업을 데코레이터로 구현해서 클래스 단순화

    - 데코레이터 실수 피하기
        - 래핑된 원본 객체의 데이터 보존 -> functools.wraps()
            - 래핑하면 원본 객체의 데이터에 접근 할 수 없게 된다
            - @wraps()데코레이터를 사용해서 원본객체의 데이터가 래핑된것을 알려줘야한다
        
        - 데코레이터 부작용 처리
            - 래핑된 함수 바깥에 추가 로직을 구현한 경우
                - 래핑 함수 밖의 코드는 임포트할 때 실행된다
                - 함수 밖의 로직을 구현한 경우 임포트전에 적절한 설정을 완료해야한다
                - 데코레이터 설정을 사용자 측에서 하는 것은 좋은 습관이 아니다

            
            - 임포트에서 실행되는 부작용을 활용
                - 모듈의 공용 레지스트리에 객체를 등록하거나 래핑한 클래스들을 실행하는등
                ```py
                def deco(func):
                    # 로직 정의
                    return func
                    # 래핑한 함수 반환

                @deco
                class a():
                    pass
                
                # 데코레이터를 임포트 하면 로직이 실행되고 래핑된 클래스,함수들을 실행시킬수 있다 
                ```
                - 웹 프레임워크, 라이브러리들은 이 기능을 활용한다
                - 코드만 봐서는 어떤 결과가 나올지 예측하기 어렵다
                - 결과를 외부에 노출하는 코드가 있어야 한다

    - 어느 곳에 재사용가능한 데코레이터 만들기
        - *args, **kwargs 를 사용하면 모든 경우 사용가능
        - 원래 함수와 비슷하게 인자를 정의 하는경우 -> 가독성이 높아진다
            - 함수,메서드 모두 사용하기위해 메서드의 self추가 변수를 처리해야한다
                - 디스크립터 프로토콜을 구현한 데코레이터 객체를 만들기
                    1. 클래스 데코레이터에 ```__get__```메서드를 추가
                    2. 함수를 객체에 바인딩하고 데코레이터를 새로운 호출가능객체로 생성

### 데코레이터와 DRY 원칙
- 신중하게 설계하지 않은 데코레이터는 코드의 복잡성을 증가시킨다
- 데코레이터는 리팩토링 단계에서 최소환으로 구현
- 적어도 3회 이상 필요한 경우 구현

### 데코레이터와 관심사의 분리
- 하나이상의 작업을 수행하지 않도록 설계
- 데코레이터도 작게 만들어야 한다
- 작은 데코레이터들을 적용하는 순서도 중요하다


### 좋은 데코레이터 분석
- 캡슐화, 관심사의 분리 : 데코레이터가 하는 일과 래핑된 함수가하는 일의 책임을 명확히 구분해야 한다, 데코레이터사용자는 세부 구현사항을 전혀 몰라야 한다
- 독립성 : 데코레이팅 되는 객체와 최대한 분리
- 재사용성 : 범용적 이어야 한다, 범용적이지 않다면 함수로 만드는게 낫다







                



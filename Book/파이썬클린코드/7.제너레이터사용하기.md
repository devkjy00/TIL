제너레이터는 전통적 언어에는 없는 파이썬의 특징적 기능이다


### 제너레이터 만들기
- 제너레이터는 메모리를 적게 사용하는 반복을 위한 방법이다
- 한번에 하나의 리터럴 값을 반환해주는 이터러블 생성 객체이다
    - 게으른 연산(lazy computation)

- 제너레이터 표현식
    - sum(),max()같은 이터러블 연산이 가능한 함수에 직접 전달할 수도 있다
    - 파이썬스러운 방식.

### 이상적인 반복
- 관용적인 반복 코드
    - ```__next__```를 구현한 객체(이터레이터)의 next함수를 호출 할 때마다 다음 시퀀스 값을 무제한 출력한다
    - ```__iter__```매직 메서드를 구현한 객체(이터러블)만 반복이 가능하다
    
    - next()함수
        - 이터러블을 다음 요소로 이동시키고 기존의 값을 반환한다
        - 더 이상 값이 없으면 StopIteration 예외가 발생한다
    
    - 제너레이터 사용
        - 제너레이터가 호출되면 yield문장을 만나기 전까지 실행, 값을 생성하고 멈춘다

    - itertools
        - 이터레이터, 제너레이터, itertools들을 서로 연결하여 더 효율적인 객체를 만들수 있다
        - itertools.tee(시퀀스, 복사개수)
            - 제너레이터의 값들을 하나씩 복사 개수만큼 복사해서 언패킹, 할당한다
            - 반복을 여러번 해야 되는 경우 사용
        - itertools 공부 필요

    - 이터레이터를 사용한 코드 간소화
        - 2중 중첩 루프 해결
            - 2중 중첩 루프를 제너레이터 함수로 정의하면 플래그나 예외를 사용한 것보다 간단하게 나타 낼수 있다
            - 최대한 중첩루프를 제거하고 추상화하여 반복을 단순화 하라

- 파이썬의 이터레이터 패턴
    - 이터레이션 인터페이스
        - 이터러블과 이터레이터는 다르다
        - 반복을 하기위해서는 ```__iter__```가 구현되있어야하고 실제 반복할 때 값을 가져오는 로직은 ```__next__```에 구현한다
        - next()함수는 한번에 하나씩만 생성하는데 이런의미에서 제너레이터는 이터레이터 이다
    
    - 이터러블이 가능한 시퀀스 객체
        - ```__iter__```가 없을 경우 객체가 시퀀스인지 확인한다
        - ```__getitem__```,```__len__```을 구현한 객체는 반복이 가능하다


### 코루틴(coroutine)
cooperative routine의 약자로 함수나 메서드같은 서브루틴(함수,메서드)이 메인루틴과 종속관계를 가진 것과 다르게 메인루틴과 대등한 관계로 협력하는 모습에서 코루틴이라 불리게 됬다

- 제너레이터 인터페이스의 메서드
    - close()
        - 제너레이터에서 GeneratorExit 예외를 일으킨다, 반복이 중지된다
        - 코루틴이 일종의 자원관리를 하는 경우 이 함수가 모든 자원을 해제한다
        - 제너레이터에서 작업을 종료할 때는 이 메서드를 사용한다

    - throw(ex_tyep[,ex_value[,ex_traceback]])        
        - 제너레이터가 중단된 위치에서 예외를 던진다
            - 제너레이터객체.throw(예외명)
        - 이는 보통 처리가능한 예외를 뜻하고 제너레이터에서 예외처리를 한다
        - 예외를 처리하고 다시 값을 반환한다

    - send(value)
        - a = yield b
        - 이 경우 yield문은 두가지 일을 한다
            - b 값을 보내고
            - send()로 전달된 values을 a에 할당

        - 코루틴에 값을 전송하는 것은 yield 구문이 멈춘 상태만 가능
        - 코루틴이 send()로 값을 보내기 위해서는 최소한번의 next()를 실행해서 yield문에 멈춰야 한다
            - 그렇지 않으면 TypeError 발생
            - 데코레이터를 사용해서 next()를 먼저 구현하면 편리 할 것


- 코루틴 고급 주제
    - 코루틴은 나중에 코드가 실행 될 때까지 코드의 실행을 멈추는 것을 목표로한다
    - 기술적으로는 제너레이터이지만 다른 의미를 가지고 있다
    - 값 반환
        - 제너레이터에서 값을 반환(return)하면 반복이 즉시 중단된다
        - StopIteration 예외가 발생해도 예외 객체 내(객체.value)에 반환 값이 저장된다

- 코루틴 위임하기 - yield from
    - yield from구문은 서브제너레이터에서 직접 값을 생산할 수 있도록 해서 중첩 루프를 피할 수 있다
    - 어떤 이터러블에 대해서도 동작하고 제너레이터 표현식과 마찬가지이다
    - 이미 정의된 제너레이터를 다른 함수에서 똑같이 하나씩 값을 보내게 해준다, 일종의 제너레이터 중첩문

    - 서브제너레이터 반환 값
        - 서브제너레이터 함수에서 반환(return)된 값은 할당자로 값에 예외에 포함되서 할당된다
            - num = yield from 이터러블
            - 서브제너레이터 함수에 return이 없으면 None이 반환됨
        
    - 서브 제너레이터와 데이터 송수신
        - 제너레이터는 코루틴 처럼 동작, 값을 전송하고 예외를 던지면 코루틴 역할을 하는 해당 제터레이터는 값을 받아서 처리해야한다
        - 외부에서 값을 전달해도 실제 전달 받는 것은 yield from의 서브제너레이터안에 yield이다

### 비동기 프로그래밍
- 비동기 프로그래밍은 논 블로킹(non-blocking)방식의 병렬I/O작업을 할 수 있다
    - 코루틴이 정지된 동안 다른 작업을 할 수 있어 효율적이다
        - 여기서 병렬이라는 것은 DB, 네트워크, 디스크요청 같은 Non-CPU중심의 작업에서 대기시간이 생기면 제어권을 스케줄러에 넘겨줘서 다른 작업을 하게 해준다는 뜻이다
        - 단일 스레드에서 마치 여러개를 동시게 실행한 것과 비슷한 효과를 낼 수 있다
    - 프로그램은 yield from문장에 의해 제어권을 주고 받는다

- 파이썬3.5이전에는 코루틴이 @coroutine데코레이터가 적용된 제너레이터였다
- 지금은 코루틴이 새로운 타입으로 추가됬다
    - await, async def 구문이 추가됬다
        - await는 yield from을 대신하고 awaitable 객체에서만 동작한다
        - async def sms @coroutine 데코레이터를 대신해서 코루틴을 정의하는 방법이다
            - 코루틴 인스턴스를 반환하는 객체를 만든다

    - 제어권을 반납할때 await 코루틴객체 호출하면 된다, yield처럼 호출자에게 제어권을 넘겨줘서 비동기적으로 관리한다




        
디스크립터는 다른언어에서는 생소한 개념이다

### 디스크립터 개요
- 디스크립터 매커니즘
    - 클라이언트 클래스와 디스크립터 클래스를 구현해야한다
    - get, set, delete, set_name 메서드를 구현할 수 있다
    - 디스크립터 객체가 클라이언트클래스의 클래스속성으로 정의 되어야 한다
        - 클래스 속성을 호출하면 디스크립터의 get메서드가 호출된다
    - 제어흐름을 변경할 수 있고 논리를 추상화할수 있다

- 디스크립터 프로토콜의 메서드 탐색
    - ```__get__```(self, instance, owner)
        - 객체(instance).속성(self)로 호출한다
        - instance : 디스크립터를 호출한 객체
        - owner : 클라이언트 클래스
        - self : 디스크립터 객체
        ```py
        def __get__(self, instance, owner):
            if instance is None:    # 클라이언트클래스가 호출한경우(객체가 없음)
                return ~~
            return ~~               # 객체가 호출한 경우
        ```

    - ```__set__```(self, instance, value)
        - 인스턴스.속성 = 값(value)로 호출한다
        - 입력된 값을 연산 후 self가 아닌 instance 속성에 저장해야한다
        - 일반적으로 유효성 검사 객체를 생성할 때 활용
        - set메서드가 구현되지 않은 디스크립터객체는 값을 할당하면 객체자체를 덮어쓴다

    - ```__delete__```(self, instance)
        - del 인스턴스.속성 으로 호출한다
        - 권한이 없는 객체는 속성을 제거하지 못하도록 할 수 있다

    - ```__set_name__```(self, owner, name(디스크립터객체의 이름))
        - 처음에 자동으로 실행된다, 디스크립터 객체의 이름을 가져오기위한 편의 기능
        - 이 이름은 인스턴스.```__dict__```[name]으로 인스턴스에 값을 사용할 때 사용된다
        - 확장성을 위해```__init__```에 이름을 정의하고```__set_name__```으로 수정하는게 좋다

### 디스크립터의 유형
- 비 데이터 디스크립터
    - ```__get__```메서드만을 구현한 디스크립터
    - .descriptor 속성을 조회 하면 객체.dict 에서 키를 찾지 못하면 그 다음으로 클래스에서 디스크립터를 찾게 된다 (인스턴스.속성 검색 -> 클래스.속성 검색)
    - 만약 디스크립터 속성에 값을 할당하면 인스턴스.속성 사전에 값이 생겨서 디스크립터에 접근할 수 없다
    
- 데이터 디스크립터
    - ```__set__```메서드를 구현한 디스크립터
    - set메서드의 블록에서 instance.```__dict__```[name] = value 로 인스턴스.속성의 값을 오버라이딩한다
    - 데이터 디스크립터는 인스턴스사전보다 높은 우선순위를 갖는다, 그래서 속성에 접근하면 바로 get,set,delete메서드가 실행된다

- 주의할 점
    - 디스크립터 메서드안에서 setattr()이나 할당 표현식을 직접사용하면 무한루프가 발생한다
    - 그래서 ```__dict__```를 사용하는 것이 일반적이다

### 디스크립터 실전
- 디스크립터가 다른 유형의 클래스,프로젝트에서도 동일한 결과를 내도록 설계해야 한다
- 입력된 값을 본인이 아닌 호출한 객체에 저장해야 한다
- 비즈니스 로직구현보다는 내부 API를 정의 하는데 적합하다

- 다른 형태의 디스크립터
    - 전역 상태 공유 이슈
        - 클래스 속성의 문제점은 모든 인스턴스에서 공유된다는 것이다
        - 디스크립터객체에 데이터를 보관하면 모든 객체가 동일한 값에 접근하게 된다
    - 약한 참조 사용
        - ```__dict__```를 사용하지 않는 대안은 객체가 직접 내부 매핑을 통해 각 인스턴스의 값을 보관하고 반환하는 것이다
        - 내부 매핑에서 사전을 사용하면 순환 종속성이 생겨 사용하면 안된다
        - 사전을 사용하는것이 일반적인 방법이다

- 디스크립터에 대한 추가 고려사항
    - 코드 재사용
        - 프로퍼티가 필요한 구조가 반복되는 경우 디스크립터를 사용할 수 있다
        - 디스크립터는 데코레이터가 클래스 메서드에서도 동작하도록 돕는다(self변수처리)
            - 데코레이터는 항상 get메서드를 구현하는 것이 안전하다

        - 3의 규칙, 3번 이상 쓰이는지 확인하라
        - 사용자가 접근하는 내부 API에 대해서는 디스크립터를 사용하는 것이 좋다
        - 디스크립터는 비즈니스 로직에서 사용할 새로운 객체나 데이터구조를 정의하는 것과 비슷하다
    
    - 클래스 데코레이터 피하기
        - 데코레이터를 디스크립터로 깔끔하게 만들 수 있다
        - 예제 p.195


### 디스크립터 분석
좋은 디스크립터의 기준?
- 파이썬 내부에서의 디스크립터 활용
    - 함수와 메서드
        - 함수는 ```__get__```메서드가 구현되어있어서 클래스 안에서 메서드 처럼 동작한다
        - 메서드는 추가인자인 self를 가진 함수이다, 인스턴스를 인자로 받아서 수정하는 함수와 동일
        - 메서드는 또 다른 함수 이며 객체에 바인딩 되어있다
        ```py
        # 메서드
        instance = class()
        instance.method(..)

        # 파이썬의 실제 처리
        instance = class()
        class.method(instance,..)
        ```
        - 디스크립터의 기능을 활용한 구문 변환
            1. instance.method()구문에서는 괄호보다 그 앞 부분이 먼저 평가된다
            2. method는 클래스의 속성으로 정의된 객체(함수),정의된 get 메서드가 호출되어서 함수를 메서드로 변환한다, 객체의 인스턴스에 바인딩 하는 것
            - 사용자 정의 호출가능한 객체를 정의 할 때는 디스크립터로 만들어서 클래스 속성으로도 사용할 수 있도록 하는 것이 좋다(call을 정의하면 get,set도 정의하는게 좋다)

    - 메서드를 위한 빌트인 데코레이터
        - 데코레이터는 디스크립터이다
        - 메서드를 클래스가 호출하면 디스크립터 자체를 반환한다, 프로퍼티객체도 스스로를 반환한다
        - @classmethod는 내부에 정의된```__get__```함수에서 인스턴스,클래스 상관없이 래핑한 메서드의 self에 클래스를 넘겨준다
        - @staticmethod는 정의된 인자 외에 다른 인수를 넘기지 않도록 해서 self를 바인딩하는 작업을 취소한다
    
    - 슬롯(slot)
        - 특정 속성만 정의하고 다른것은 제한, 메모리를 적게 사용한다
        - 클래스의 ```__dict__```속성을 없에서 정적으로 만들어서 동적으로 속성을 추가할 수 없다
            - 정적인 객체에만 사용해야 한다
        - 슬롯에 정의된 이름마다 디스크립터를 만들어서 값을 저장하고 사용한다

- 데코레이터를 디스크립터로 구현
    - 데코레이터에 ```__get__```메서드를 구현, types, MethodType을 사용해서 데코레이터 자체를 객체에 바인딩된 메서드로 만들면 된다

### 요약
- 디스크립터는 메타프로그래밍에 가까운 고급기능이다
- 디스크립터는 내부 API개발이나 라이브러리, 프레임워크 디자인같은 일반적 경우에 대해 사용해야한다
- 비즈니스 로직을 포함하면 안된다
> 메타 프로그래밍
- 프로그램을 데이터 처럼 다룰 수 있게 하는 프로그래밍 기법
- 다른 프로그램을 읽고, 생성하고, 분석하고, 변형시키고, 런타임중에 수정할 수도 있게한다





    








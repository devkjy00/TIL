## 1.클래스의 토대: 추상 데이터형(Abstract Data Type)
- *추상 데이터형 : 데이터와 데이터를 처리하는 연산의 집합*
    - 처음에 구현하기 쉽고 나중에 변경하기 쉬운 클래스를 만들 수 있다
    - 구현 세부 사항을 감출 수 있다
    - 변경이 전체에 영향을 미치지 않는다 -> 변경이 쉽다
    - 인터페이스가 더 많은 정보를 제공하도록 만들 수 있다
    - 프로그램이 명백하고 정확해진다
    - 프로그램의 가독성이 높아진다
    - 전체 프로그램에 데이터를 넘길 필요가 없다
    - 저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다
        ```
        예>
        선박 제어
            - 속력을 조절한다
            - 현재 설정을 얻는다
            - 이전 속력으로 달린다
            - 사용을 중지한다
        ```

> 간단한 객체도 ADT로 취급하라

## 2.좋은 클래스 인터페이스
- 좋은 추상화 : 복잡한 연산을 단순한 형태로 보여주는 것
    - 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다, 응집력/일관성이 떨어지면 분리하자
    - 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다
    - 관련 없는 정보를 다른 클래스로 옮겨라
    - 인터페이스는 프로그래밍적으로 강제할 수 있게 만들어라
        - 메소드 순서에 의존하거나 특정 객체에 의존한다면 Assert나 다른 기법을 사용해서 강제화 하는 방법을 모색해야 한다

    - 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다
    - 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라
    - 추상화와 응집도를 함께 고려하라


- 좋은 캡슐화
    - 클래스와 멤버의 접근성을 최소화하라
    - 멤버 데이터는 getter, setter를 사용해라
    - 내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 말라(변수명이나 함수명, 타입 등)
    - 클래스 사용자를 가정하지 말라 
    - 프렌드 클래스를 피하라
    - 어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 말라
    - 코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라
    - *캡슐화의 의미론적인 위반을 각별히 주의하라*
        - 클래스 A가 a() 내부에서 init()을 호출하기 때문에 init()를 호출하지 않는다 등의 상황
        > 철저히 모르는 상태를 유지하도록 해야 하고 온전히 인터페이스만 보고 이해가 되야한다
        
    - 지나치게 밀접한 결합을 주의하라
        - 클래스가 완전하지 않으면 다른 루틴이 내부 데이터를 직접 읽거나 써야 한다

## 3.설계와 구현 문제
- 포함(has a)
    - 컴포지션을 통해서 "has a"를 구현하라
    - 최후의 수단으로 비공개 상속(private 멤버)을 통해서 "has a"를 구현하라
    - 약 7개 이상의 데이터 멤버를 포함하는 클래스를 주의하라
        - 7이라는 수는 개인이 다른 작업을 수행할 때 기억할 수 있는 개별 항목의수다


- 상속(is a)
    - 공개 상속(protected, public 멤버)을 통해서 "is a"를 구현하라
    - 상속을 고려해서 설계하고 문서화하라, 그게 아니면 상속을 금지하라
        - 상속은 복잡도를 높인다, 상속이 고려되지 않으면 final로 오버라이드를 막을 수 있다

    - *리스코프 치환 원칙(LSP: 서브클래스는 기본클래스를 대체할 수 있어야한다)을 따르라*
        - 파생된 클래스를 다 알아야한다면 복잡도는 걷잡을 수 없다, 일반적인 개념으로 다 다룰 수 있어야한다

    - 상속받고 싶을 때만 상속받게 하라
        - 인터페이스는 필요없고 구현 사용이 목적이면 포함을 사용하라

    - 오버라이드가 불가능한 멤버 함수와 같은 이름의 함수를 만들지 말라
    - 공통으로 사용되는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 가장 높은 곳으로 옮겨라
    - 인스턴스가 하나뿐인 클래스를 의심하라
        - 별개의 클래스가 아닌 데이터로 표현할 수 있는지 확인하자

    - 파생 클래스가 하나뿐인 기본 클래스를 의심하라
        - 현재의 작업을 분명하고 단순하게 만드는 것이 중요, 필요이상의 상속구조를 만들지 말자

    - 루틴을 오버라이드 했는데 파생된 루틴 내부에서는 아무것도 하지 않는 클래스들을 의심하라
        - 이는 추상화를 파괴한다, 일반적인 객체의 모습을 지키지 못한다면 다른 방식으로 구현하자

    - 깊은 상속 구조를 피하라
        - 서브 클래스의 총 갯수가 7개를 넘지 않도록 하자
        - 중복 코드제거와 복잡성 최소화를 목적으로 상속을 사용하라

    - 광범위한 타입 검사보다 다형성을 택하라
        - 타입별로 writeA(), writeB() 보다는 write()와 같이 단일 루틴을 사용하자

    - 모든 데이터를 보호가 아닌 비공개로 만들어라

    - 다중 상속 : 다중 상속은 믹스인 클래스를 만들기에 유용하지만 복잡성을 고려한 후 사용해야 한다 

- 멤버 함수와 데이터
    - 클래스에 가능한 적은 수의 루틴을 유지하라
        - 클래스 당 루팅의 수가 늘어나는 것은 오류율 상승과 연관이 있다

    - 원하지 않는 멤버 함수와 연산자가 암묵적으로 생성되지 않도록 하라
        - 싱글턴을 사용하는 방법이 있다

    - 클래스에서 호출되는 루틴의 수를 최소화하라
        - 팬 아웃 : 클래스가 사용한 클래스가 많을수록 오류도 증가하는 경향이 있다
    - 다른 클래스에 대한 간접적인 루틴 호출을 최소화하라
        - 데미테르의 법칙 : A객체가 생성한 B객체를 사용할 때 B객체가 제공하는 객체를 사용해서는 안된다

    - 일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라

- 생성자
    - 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라
    - 다른 사실이 증명될 때까지 얕은 복사보다 깊은 복사를 택하라

## 4.클래스를 작성하는 이유
- 현실 세계의 객체를 모델링
- 추상 객체를 모델링 : 적절한 추상화 객체를 생각해내는 것은 어려운 문제중 하나이다
- 복잡성을 줄이고 고립시킨다
- 구현 세부 사항을 숨긴다
- 변경의 효과를 제한한다
- 전역 데이터를 숨긴다
- 매개변수 전달을 간소화한다
- 중앙 집중 관리한다
- 코드 재사용을 돕는다
- 프로그램 전체를 고려한다
- 연관된 기능을 패키지로 구성한다
- 특정한 리팩터링을 수행한다

- 주의할 점
    - 신(god) 클래스를 생성하지 말라
    - 관련이 없는 클래스를 제거하라
    - 동사를 뒤에 붙이는 클래스를 피하라







# 5. 구현 설계
훌룡한 클래스와 루틴 설계의 상당 부분이 시스템 아키텍처로 결정되기 된다

### 설계
- 설계는 요구사항을 코드 작성과 디버깅에 연결하는 작업이다
- 설계의 어려움
    
    - 설계는 불명확한 문제 :  솔루션을 만들기 위해 또 다시 문제를 해결해야한다
    - 불완전한 프로세스 
    - 절충과 우선순위의 문제 : 목적(성능, 개발시간)에 맞게 다른 설계
    - 제약이 따른다 : 자원의 제약으로 간결안 해결방안 필요
    - 비결정적 : 설계하는 방법은 수십가지
    - 발견적 학습 : "경험법칙", 작동하는지 시도해봐야됨

- 핵심 설계 개념
    
    - 복잡성 관리
        - 현실은 가변적, 비본질적이고 현실의 문제를 반영한 프로그램도 복잡해진다
        - 복잡성 관리 부족은 프로젝트 실패로 이어진다
    
    - 복잡성 해결법
        - 서브시스템, 하나만 하는 객체, 추상성을 최대화
        - 인간의 뇌가 한번에 처리하는 본질적 복잡성의 양을 최소하 한다
        - 비본질적 복잡성이 불필요하게 증가하지 않도록 한다
    
    - 바람직한 설계
        - 복잡성 최소화 : 간단하고 이해하기 쉽게
        - 유지보수의 편리함
        - 느슨한 결합 : 클래스 연결 최소화(추상화, 캡슐와, 정보 은닉)        
        - 확장성 : 내부구조를 유지하면서 시스템 개선가능
        - 재사용성
        - 높은 팬인(fan-in) : 특정 클래스를 사용하는 클래스의 수가 많다는 것
        - 낮은 팬아웃(fan-out) : 특정 클래스를 적게 사용하는 것
        - 이식성 : 다른 환경으로 쉽게 이동
        - 간결성 : 더 이상 뺄 내용이 없는 것
        - 계층화 : 일관된 추상화로 쉽게 이해

- 설계 단계
    
    - 소프트웨어 시스템
        - 시스템 수준은 서브시스템, 패키지 들을 조합하는 데 도움을 준다
    
    - 서브시스템, 패키지로 분할
        - 커뮤니케이션 규칙을 정하고 제한하여 각 서브시스템이 독립된 의미를 갖도록 만들어야 한다
        - 과도한 커뮤니케이션으로 인한 순환관계를 조심
        - 공통적 서브 시스템

            - 비즈니스 규칙 : 규칙, 정책, 절차
            - 사용자 인터페이스 : 사용자 인터페이스 컴포넌트를 독립시킨 서브시스템
            - 데이터 베이스 접근 : 접근에 대한 세부사항을 감추고 추상화 해서 복잡성을 줄일 수 있다
            - 시스템 의존성 : 각 운영체제에 대한 의존성을 서브시스템으로 패키지화

    - 클래스로 분할
        - 개별적 클래스로 구현할 만큼 자세하게 서브시스템을 분해해야 한다
        - 클래스와 객체
    
    - 루틴으로 분할
        - 클래스를 루틴으로 나눈다
    
    - 내부 루틴 설계
        - 각 루틴의 상세한 기능을 구현한다
        
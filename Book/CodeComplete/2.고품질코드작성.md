# 5. 구현 설계
훌룡한 클래스와 루틴 설계의 상당 부분이 시스템 아키텍처로 결정되기 된다

## 설계
- 설계는 요구사항을 코드 작성과 디버깅에 연결하는 작업이다
- 설계의 어려움
    
    - 설계는 불명확한 문제 :  솔루션을 만들기 위해 또 다시 문제를 해결해야한다
    - 불완전한 프로세스 
    - 절충과 우선순위의 문제 : 목적(성능, 개발시간)에 맞게 다른 설계
    - 제약이 따른다 : 자원의 제약으로 간결안 해결방안 필요
    - 비결정적 : 설계하는 방법은 수십가지
    - 발견적 학습 : "경험법칙", 작동하는지 시도해봐야됨

- ## 핵심 설계 개념 ₩
    
    - 복잡성 관리
        - 현실은 가변적, 비본질적이고 현실의 문제를 반영한 프로그램도 복잡해진다
        - 복잡성 관리 부족은 프로젝트 실패로 이어진다
    
    - 복잡성 해결법
        - 서브시스템, 하나만 하는 객체, 추상성을 최대화
        - 인간의 뇌가 한번에 처리하는 본질적 복잡성의 양을 최소하 한다
        - 비본질적 복잡성이 불필요하게 증가하지 않도록 한다
    
    - 바람직한 설계
        - 복잡성 최소화 : 간단하고 이해하기 쉽게
        - 유지보수의 편리함
        - 느슨한 결합 : 클래스 연결 최소화(추상화, 캡슐와, 정보 은닉)        
        - 확장성 : 내부구조를 유지하면서 시스템 개선가능
        - 재사용성
        - 높은 팬인(fan-in) : 특정 클래스를 사용하는 클래스의 수가 많다는 것
        - 낮은 팬아웃(fan-out) : 특정 클래스를 적게 사용하는 것
        - 이식성 : 다른 환경으로 쉽게 이동
        - 간결성 : 더 이상 뺄 내용이 없는 것
        - 계층화 : 일관된 추상화로 쉽게 이해

- ## 설계 단계
    
    - 소프트웨어 시스템
        - 시스템 수준은 서브시스템, 패키지 들을 조합하는 데 도움을 준다
    
    - 서브시스템, 패키지로 분할
        - 커뮤니케이션 규칙을 정하고 제한하여 각 서브시스템이 독립된 의미를 갖도록 만들어야 한다
        - 과도한 커뮤니케이션으로 인한 순환관계를 조심
        - 공통적 서브 시스템

            - 비즈니스 규칙 : 규칙, 정책, 절차
            - 사용자 인터페이스 : 사용자 인터페이스 컴포넌트를 독립시킨 서브시스템
            - 데이터 베이스 접근 : 접근에 대한 세부사항을 감추고 추상화 해서 복잡성을 줄일 수 있다
            - 시스템 의존성 : 각 운영체제에 대한 의존성을 서브시스템으로 패키지화

    - 클래스로 분할
        - 개별적 클래스로 구현할 만큼 자세하게 서브시스템을 분해해야 한다
        - 클래스와 객체
    
    - 루틴으로 분할
        - 클래스를 루틴으로 나눈다
    
    - 내부 루틴 설계
        - 각 루틴의 상세한 기능을 구현한다
        
- ## 설계 빌딩 : ***발견적 학습***
설계에는 정답이 없으므로 좋은 소프트웨어 설계를 위해서 발견적 학습을 효과적으로 적용해야 한다. 

- 객체 모델링: 현실과 가상의 객체를 찾는 것
    1. 객체와 객체의 속성을 식별
        - 모듈, 클래스 별로 책임을 나누는 것
    
    2. 객체가 무엇을 할 수 있는지 결정
        - 루틴을 결정하는 것
    
    3. 다른 객체에 무엇을 할지 결정
        - 보통 포함(참조), 상속 하는 것
    
    4. 다른 객체에 공개할 부분을 결정
        - 정보를 은닉하는 것
    
    5. 객체의 인터페이스를 정의
        - 다른 객체에 노출하는 속성 "공개(public) 인터페이스"
        - 상속된 서브클래스에게만 노출하는 "보호(protected) 인터페이스"

- 일관성 있는 추상화
    - 내부 작업에 신경쓰지 않고 추상화 하여 공개된 인터페이스에만 집중할 수 있게 해야 한다
    - 빠르고 안전하게 프로그래밍 할 수 있게 해준다

- 구현 세부 사항을 캡슐화 하라
    - 추상화, 계층이 다른 수준에서 데이터에 접근하지 못하도록 정보를 은닉하는 것
    - 복잡성을 관리할 수 있게 도와준다

- 상속이 설계를 단순화 할 수있을 때 상속하라
    - 속성에 유사성이 있는 객체는 같은 클래스를 상속 받도록 만들어라
    - 상속을 통해 부모 클래스로 부터 같은 연산, 메서드 쓸 수 있는 '다형성'이 지원된다

- ***정보 은닉***
    - 구조적 설계의 '블랙박스', 객체지향 설계의 '캡슐화', '모듈', '추상화'
    - 설계나 구현에서 다른 프로그램으로 한 부분을 숨기기로 결정한는 것
    - 복잡성을 감추는 데 중점, 강력한 발견적 기법이다

    - 비밀, 프라이버시
        - 클래스 내에서 변경된 사항이 클래스 인터페이스를 벗어나는 범위까지 영향을 미쳐서는 안된다
        - "가시성", 어떤 기능을 클래스에 비밀로 남기고 어던 기능을 외부로 알릴지 결정해야 한다
            - 예 ) id 를 생성하는 함수 "id = NewId()" 처럼 세부사항은 숨기고 인터페이스를 공개
                - 연산과정과 타입을 숨겨야 한다 

    - 정보 은닉의 장애물
        - 정보의 지나친 배분
            - 시스템 정보를 지나치게 배분하는 것, 전역변수를 난무
            - 시스템 전체에 사용자와 상호작용을 넣는 것, 서브 클래스로 생성해야 한다

        - 순환 의존성   
            - 클래스A의 루틴이 클래스B를 호출하고 클래스B의 루틴이 또 A를 호출할 때 발생
        
        - 전역 데이터로 오해받는 클래스 데이터
            - 클래스 데이터는 단일 클래스안의 루틴만 접근 하기 때문에 전역 데이터에 비해 위험 요소가 훨씬 적다
            - 큰 클래스의 경우 전역 데이터 비슷한 문제를 유발 할 수 있다

        - 성능 손해
            - 아키텍처 수준과 코드 작성 수준에서 성능 손해를 피하려는 시도가 정보 은닉에 방해 된다
            - 성능 개선을 미리 준비하는 가장 좋은 방법은 코드를 모듈화 하는 것

    - 정보 은닉의 가치
        - 객체 지향적 사고에서 하기 힘든 설계를 정보 은닉에 대한 발견적 사고가 돕는다
        - 클래스에서 무엇을 숨겨야 하는가를 고민하라, 데이터를 공개하지 않도록 인터페이스를 설계하라

- ***변경 될 것 같은 영역을 찾아라***
    - 변경 가능성이 있는 루틴이나 클래스등은 결합을 낮추고 고립시켜야 한다
    - 변화가 클래스 내부에 제한 되어 외부는 영향을 받지 않도록 인터페이스를 설계

    - 변경될 가능서잉 큰 영역
        - 비즈니스 규칙 
            - 조세 구조, 보험 요율표 변경 등
        
        - 하드웨어 의존성
            - 다양한 디지털 컴포넌트와의 상호작용은 서브 시스템이나 클래스로 고립시킨다
        
        - 입력과 출력
            - 자신만의 자료구조, 데이터 파일을 생성하는 경우 시간이 지나면 자료 구조, 파일 포맷도 변할 것이다

        - 표준을 따르지 않는 언어 기능
            - 라이브러리나 언어의 확장 기능이 표준을 따르지 않으면 다른 환경에서 작동 되지 않을 수 있기 때문에 대체 가능한 기능을 별도로 클래스내에 숨겨라

        - 어려운 설계 및 구현 부분
            - 기능을 분류하여 나쁜 설계나 구현이 나머지 시스템에 미치는 영향을 최소화 하라
        
        - 상태 변수
            - 프로그램의 상태를 나타내는 변수는 자주 변경되는 경향이 있다 
            - bool변수는 상태변수로 쓰지말고 시퀀스데이터를 사용하면 추가,제거가 간편하다
            - 변수에 직접 접근하지 말고 루틴을 사용하라
                - 검사코드가 루틴에 있다면 훨씬 쉬워 진다

        - 변경의 정도 예측하기
            - 절대로 변경되지 않은 부분만 다른 객체에 영향을 미치도록 허용하라
            - 프로그램의 사용자가 만족하는 부분은 변경될 가능서이 작다
            - 개선 가능성이 있으면 잠재적인 변경으로 이어지기때문에 정보 은닉 원칙을 사용해 설계하라
        
- ***결합을 느슨하게 유지하라***
    - 결합은 다른 클래스나 루틴이 얼마나 밀접하게 연관되어 있는지를 기술
    - 작고 단순,직접적이며 눈에 띄는 유연한 결합을 갖도록 해라
    - 두 클래스가 동일한 전역 데이터를 사용하면 훨씬 더 긴밀하게 결합된다

    - 결합의 기준
        - 크기 
            - 모듈 사이의 연결 횟수를 의미
            - 더 적은 공개 메서드, 더 적은 매개변수를 받는 루틴이 느슨한 결합이다

        - 가시성
            - 연결이 얼마나 명시적인지를 의미
            - 데이터의 이동, 연결 부분을 눈의 띄게 만들어야 한다, 전역 x
        
        - 유연성
            - 얼마나 쉽게 모듈사이의 연결을 변경할 수 있는지를 의미
            - 가장 처음 개발한 모듈은 유연성이 떨어지게 된다
            - 다른 모듈을 호출하는게 쉬울수록 결합은 느슨해지고, 유연성은 커지고 유지보수 하기도 쉽다(표준에 맞는 완성된 데이터가 호출하기 쉽다)
            - 시스템 구조를 만들 때 상호 연결을 최소화 하도록 프로그램을 나눠라
    
    - 결합의 종류

        - 간단한 데이터 매개변수 결합 : 모든 데이터를 매개변수로 전달, 느슨한 결합
        - 간단한 객체 결합 : 모듈이 객체를 인스턴스화(구별된 클래스?), 느슨한 결합
        
        - 의미론적인 결합 : 내부 작동에 대한 논리적 지식을 사용할 때 발견하기 어렵다
            - 제어플래그(bool) 전달은 데이터로 무엇을 할지 정보가 없다, 따라서 주의가 필요
            - 전역 데이터 수정 : 같은 전역 데이터를 참조하는 다른 객체에 영향을 미친다
            - 모듈의 코드 변경 : 임포트한 모듈이 변경되면 알아 챌수 없기 때문에 위험하다, 그래서 버젼이 중요
                - 모듈에서 추가적인 추상화를 제공하는 것이 느슨한 결합의 핵심

- 디자인 패턴을 활용하라
    - 패턴은 완전히 직접 작성한 설계로는 얻을 수 없는 여러가지 이점을 제공한다
        - 이미 만들어진 추상화를 제공함으로써 복잡성을 줄인다
        - 코드를 직접 작성하는 대신 라이브러리 코드를 사용하는 것과 개념적으로 유사
        - 과거의 수많은 설계 문제를 해결하는 디자인 패턴이 새로 만드는 것보다 낫다
    
    - 발견적 학습의 가치를 제공
        - 디자인 패턴을 대안으로 살펴보는 것만으로 직저 디자인하는 것과 비교 할 수 없이 쉽게 할 수 있다

    - 복잡한 논의를 할 수있도록 의사소통을 원활하게 한다
        - 종류 : 추상팩토리, 어댑터, 브리지, 컴포지트, 데코레이터, 파사드, 팩토리 메서드, 이터레이터, 옵저버, 싱글턴, 스트래티지, 템플릿 메서드

    - 패턴을 억지로 코드에 끼워 맞추면 안된다, 패턴의 기능에 집착하면 안된다

- 다른 발견적 학습
    - 응집력을 강하게 하라
        - 클래스내의 속성,루틴들의 연관성이 높은 기능을 포함하는 클래스를 응집력이 강하다고 한다
    
    - 계층을 만들어라
        - 단계식 정보구조를 만드는 것 정보의 복잡성을 다루는 중요한 도구이다
         
    - 클래스 계약을 형식화 하라
        - 테스트 케이스를 작성하는 것과 유사, "선행조건", "후행조건"을 정의
    
    - 책임을 할당하라
        - 객체가 무엇을 책임져야 하는지 묻는 것, 
    
    - 테스트가 가능하도록 설계
        - 독립적으로 테스트 할 수 있도록 구별, 의존성을 최소화

    - 실패를 피하라
        - 실패의 경우를 적절하게 고려하라, 예외, 오류

    - 결합 시점을 의식적으로 선택하라
        - 특정 값을 변수에 할당하는 시점, 초기에 결합하면 간단하지만 유연성이 떨어지기 쉽다
        - 다른 객체들을 만든후에 결합하는 것도 고려하자

    - 제어 지점을 정하라
        - 중요한 코드를 찾기 위한 정확한 장소를 정해서 코드를 작성하라

    - 주먹 구구식 기법의 사용을 고려
        - 단순 무식하더라도 효과없는 코드보다는 낫다

    - 다이어그램 그리기
        - 천마디 말보다 그림 한장이 낫다

    - 모듈화를 유지하라
        - 모듈화의 목표는 루틴, 클래스를 "블랙박스"처럼 만드는 것
        - 그 과정이 은닉과 캡슐화는 주지않는 시야를 열어준다


- ## 설계 실천법
    - 반복 
        - 설계는 반복적인 프로세스다
        - 되풀이 하다 보면 매번 설계를 향상 시킬수 있다는 것을 배운다

    - 분할과 정복
        - 각 부분을 개별적으로 처리하라
        - 점증적인 개선은 복잡성을 다루는 강력한 도구이다

- 하향식, 상향식 설계 접근 방법
    - 하향식 
        - 높은 추상화 수준에서 시작에서 상세화 수준을 점점 높이는 방법
        - 분해보다 코드 작성이 더 쉬울 때 까지 계속 분해
        - 두뇌가 한번에 너무 많은 세부 사할을 처리하지 않아도 된다
    - 상향식
        - 구체적인 것부터 시작해서 구체적 객체를 규명하고 객체와 기본 클래스 집합을 일반화 하는방법
        - 주로 설계 문제가 하위 수준에서 발견 되기도 한다
        - 상향식 구성의 절차 
            - 시스템의 역할을 정의
            - 구체적인 객체와 책임을 파악
            - 서브시스템, 패키지, 합성, 상속등으로 객체들 그룹짓기
            - 반복
    
    - 상향식, 하향식 접근은 서로 상호보완적이다

- 실험적인 프로토타이핑
    - 구현 세부사항을 제대로 이해하기 전에는 문제를 완전하게 정의 할 수 없다
    - 프로토 타이핑을 쓰고 버리는 코드를 의미, 최소한의 코드를 작성해야 한다
    - 설계 질문이 구체적이지 않으면 효과가 없다

- 협력적인 설계
    - 두명이 한명 보다 낫다

- 설계 작업 기록하기
    - 설계 문서를 코드 자체에 넣어라, 독스트링과 같은 기능

- 설계의 논의와 결정을 요약, 공유하기, 또는 사진으로 기록 남기기

- 설계 플립 차트를 보관 하라, 또는 도형으로 그리기
- 복잡성은 죽음이다
- 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지해야 한다

### 시스템 제작과 시스템 사용을 분리하라
- 소프트 웨어 시스템은 객체를 제작, 의존성을 서로 연결하는 준비과정과 이후의 런타임 로직 구현을 분리해야 한다
- *관심사 분리*는 가장 중요한 설계 기법중 하나이다
- 대다수 어플리케이션은 시작 단계라는 관심사를 분리하지 않는다
    - 준비 과정 코드와 런타임 로직이 마구 뒤섞이게 된다
    - 초기화 지연, 계산 지연 기법이다
        - 장점
            - 실제로 필요할 때까지 객체를 생성하지 않아서 부하가 걸리지 않는다
            - null포인터를 반환하는 경우가 발생하지 않는다
        - 단점
            - 의존성을 해결하지 않으면 컴파일이 안된다
            - 일반 런타임 로직과 객체 생성 로직이 섞여서 단일 책임 원칙이 깨진다
        - 수시로 사용하게 되면 전반적인 설정 방식이 곳곳에 흩어져서 모듈성이 저조하고 중복이 심해진다
    - 설정 논리(객체생성같은)는 일반 실행 논리와 분리해야 모듈성이 높아진다

- ### Main 분리
    - 시스템 생성과 시스템 사용을 분리하는 방법
        - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮긴다
        - 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결 되었다고 가정한다
        - 객체를 생성하는 책임을 맡은 오브젝트가 main의 요청으로 특정 상황에 필요한 객체를 생성해서 넘겨준다

    - 나머지 시스템은 객체가 생성되는 과정을 전혀 모른다

- ### 팩토리
    - 시스템 생성과 사용을 분리해야 하지만 객체 생성 시점을 어플리케이션에서 결정할 필요도 생긴다
    - ***Abstract Factory 패턴***
        - 객체를 생성하는 책임을 맡은 오브젝트가 인터페이스를 구현하도록 한다
        - 어플리케이션은 인터페이스와 결합해서 객체생성이 필요한 시점에 인터페이스에 정의된 객체생성 메서드를 이용해 생성을 요청한다

- ### 의존성 주입
    - 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입(Dependency Injection, DI) 이다
        - 제어 역전(Inversion of Control, IoC)기법을 의존성 관리에 적용한 메커니즘이다
        - 제어 역전은 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠 넘긴다
            - 단일 책임 원칙을 지키게 된다
    
    - 초기설정을 책임질 메커니즘으로 main루틴이나 특수 컨테이너를 사용한다
    - 예로 JNDI 검색에서 객체는 서버에 이름을 제공하고 그이름에 일치하는 서비스를 요청한다
        - 요청하는 객체는 인터페이스를 통해서 의존성을 능동적으로 해결 한다

### 확장
- 처음부터 올바르게 시스템을 만들 수는 없다, 변화 하는 요구사항에 맞춰서 시스템도 변화 한다
    - 반복적, 점진적인 개발이 애자일 방식의 핵심이다

- 관심사를 적절히 분리해 관리 한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다

- ### 횡단(cross-cutting) 관심사
    - 영속성과 같은 관심사는 자연스럽게 객체의 경계를 넘나드는 관심사
    - 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다(같은이름의 메서드)
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)
        - 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다
        - 독립적으로 분리하기 어려운 부가기능을 모듈화 한다
    

### 자바 프록시
- 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예이다
    - Method 타입의 메서드를 인수로 넘겨서 해당 객체가 처리하도록 한다

- 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다
- 실행 지점을 명시하는 메커니즘도 제공하지 않는다

### 순수 자바 AOP프레임워크
- 스프링 AOP, JBoss AOP 등은 내부적으로 프록시를 사용한다
- 스프링은 비즈니스 논리를 POJO로 구현한다
    > POJO(Plain Old Java Object)
    - 프레임 워크의 사용으로 무거워진 객체에 반발하여서 생긴 개념
    - 간단한 객체(필요한 기능만 있는)를 지향하는 것으로 미리 정의된 인터페이스, 클래스, 어노테이션을 상속, 구현, 포함 하지 않는다

- POJO는 순수하게 도메인에 초점을 맞춘다
    - 그래서 테스트가 개념적으로 더 쉽고 간단하다
    - 단순하기 때문에 코드를 보수하고 개선하기 편하다

### AspectJ 관점
- 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ로 자바 언어의 확장이다
    - AspectJ'애너테이션 폼'은 에너테이션을 사용해 관점을 정의한다
        - 새로운 도구/언어 라는 부담을 완화한다

### 테스트 주도 시스템 아키텍쳐 구축
- 도메인 논리를 POJO로 작성할 수 있다면, 즉 코드수준에서 아키텍처 관심사를 분리할 수 있다면(도메인 기능을 프레임워크없이 직접짜는것?) 진정한 테스트 주도 아키텍처 구축이 가능해진다
    - 설계가 최대한 분리되어서 각 추상화 수준과 범위에서 코드가 적당히 단순해 지기 때문

- 최선의 시스템 구조는 각기 POJO객체로 구현된 모듈화된 관심사영역(관심사)으로 구성된다

### 의사 결정을 최적화하라
- 관심사를 분리하면 세분화된 관리와 결정이 가능해진다
    - 관심사를 모듈로 분리한 POJO시스템은 기민함을 제공한다, 그래서 최신정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다

- 단지 표준이라는 이유만으로 프레임 워크를 사용하는 것은 좋지 않다

### 시스템은 도메인 특화 언어가 필요하다
- DSL(Domain-Specific Language)은 간단한 스크립트 언어나 표준언어로 구현한 API를 가리킨다
- 좋은 DSL은 의사소통의 간극을 줄여준다
    - 도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면 도메인을 잘못 구현할 가능성이 줄어든다
    - 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어 올릴 수 있다

> 결론
- 모든 추상화 단계에서 의도는 명확히 표현하기 위해 POJO를 작성하고 각 구현 관심사를 분리해야 한다
- *시스템이든 개별 모듈이든 실제로 돌아가는 가장 단순한 수단을 사용해야 한다*



    






    
    

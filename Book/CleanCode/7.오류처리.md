깨끗한 코드와 오류처리는 확실한 연관성이 있다, 여기저기 흩어진 오류 처리코드는 실제 코드가 하는 일을 파악하기 어렵게 만든다

- ### 오류 코드보다 예외를 사용하라
    - 오류를 처리하는 조건문이 아닌 예외처리를 하면 논리가 오류처리코드와 뒤썪이지 않아서 코드가 깔끔해진다

- ### Try-Catch-Finally 문 부터 작성하라
    - try블록은 에서 무슨 일이 생기든지 catch블록은 프로그램 상태를 일관성 있게 유지해야한다
    - try-catch-finally문으로 시작하면 try블록에서 무슨일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다
        - 예외가 발생할 부분과 그 다음 명령을 분리 할 수 있다
    
    - 테스트 케이스를 작성할 때는 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후에 테스트를 통과하는 코드를 작성하는 방법을 권한다
        - 자연스럽게 try 블록의 트랜잭션 범위 부터 구현하게 되서 본질을 유지하기 쉬워진다
    
- ### 미확인(unchecked) 예외를 사용하라 
    - 확인된 예외는 OCP를 위반한다
        - 메서드에서 던진 예외의 catch블록이 몇 단계 위에 있다면 상위 단계 메서드 선언부를 전부 고쳐야 한다
        - 이는 캡슐화를 깨버리게 된다
    
    - 아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 하지만 일반적으로 의존성이라는 비용이 이익보다 크다

- ### 예외에 의미를 제공하라
    - 예외를 던질때 오류 메시지에 정보를 담고, 실패한 연산 이름과 유형을 언급해서 충분한 정보를 넘기면 오류의 원인과 위치를 찾기 쉬워진다

- ### 호출자를 고려해서 예외 클래스를 정의하라
    - 오류는 발생한 위치, 컴포넌트, 유형등 으로 분류가 가능하다
    - 오류를 정의할 때 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다
    - 오류를 처리하는 방식이 중복되는 catch문 같은 경우 오류를 던지는 객체를 감싸는 래퍼클래스를 정의해서 하나의 예외 유형을 던지도록 만들 수 있다
        - 외부 API를 사용할 때 가장 좋은 방법이다
        - 테스트 하기도 쉬워진다
    
- ### 정상 흐름을 정의하라
    - *특수사례패턴*
        - 예외에서 처리하는 특수 상황을 값을 관리하는 객체내에서 처리하도록 하는 방법이다
            - try-catch가 아니라 객체 내에서 if문으로 처리하는 방식
            - 클라이언트가 예외적인 상황을 처리할 필요가 없어지고 더 간결해지게 된다
        
- ### null을 반환하지 마라
    - null을 반환하는 코드는 나쁜 코드이다, 일거리를 늘리고 호출자에게 문제를 떠넘기는 코드이다
        - 매번 객체를 사용할 때 null체크를 해야되도록 만든다

    - 메서드에서 null을 반환할 상황이 오면 예외를 던지거나 특수 사례 객체를 반환해야 한다
        - 외부 API가 null을 반환한다면 감싸기 메서드를 구현해서 예외를 던지거나 특수 사례 객체를 반환할 수 있다
        - 많은 경우 특수 사례 객체가 손쉬운 해결책이다
    
    - null 대신 빈리스트를 반환할 수 있다
        - ```return Collections.emptyList();``` 로 읽기 전용 리스트를 반환 할 수 있다
    
- ### null을 전달하지 마라
    - null이 기대되는 값이 아니라면 최대한 피해야 한다
    - 객체타입 인수로 null을 전달하면 NullPointerException이 발생한다
        - assert문을 사용하는 방법이 있다
    
    - 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다
        - 애초에 null을 넘기지 못하도록 금지하는 것이 합리적이다
    
> 결론
- 오류처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다
    

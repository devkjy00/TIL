### 01. 가독성과 유연성을 개선하는 리팩터링
- 코드 가독성 개선
	- 익명 클래스를 람다로, 람다를 메서드 참조로, 명령형 데이터 처리를 스트림으로

- 익명 클래스를 람다 표현식으로 리팩터링하기
	- 익명 클래스의 this == 람다를 감싸는 클래스
	- 익명 클래스는 변수(shadow variable)를 가릴 수 있지만 람다는 가릴 수 없다
		```java
		Runable r1 = () -> { 
			int a = 2;		// 컴파일 에러
			System.out.println(this); };

		Runable r2 = new Runable() {
			public void run() {
				int a = 2;		// ok
				System.out.println(this);
			}
		};
		```
	- 익명 클래스는 명시적으로 형식이 정해지는 반면 람다의 형식은 컨텍스트에 따라 달라져서 모호해지게 된다
		-  `doSomething((Type)() -> {})` vs `doSomething(() -> {})`
		- 이 코드 처럼 명시적 형변환을 사용해서 모호함을 제거할 수 있다


- 람다 표현식을 메서드 참조로 리팩터링하기
	- 가독성이 떨어지는 람다 표현식은 해당 클래스에 메서드로 정의해서 메서드 참조로 깔끔하게 사용하자

- 코드 유연성 개선
	- 조건부 연기 실행
		- 상태를 표현하는 enum이나 predicate등을 매개변수로 받아서 조건부로 메서드가 실행되도록 할 수 있다
	
	- 실행 어라운드
		- 중복되는 코드를 미리 작성하고 변경가능한 로직의 코드를 람다로 받아서 실행할 수 있다

### 02. 람다로 객체지향 디자인 패턴 리팩터링하기
- 전략 패턴 
	- 특정한 작업을 수행하는 데 있어서 알고리즘, 즉 "전략"을 선택할 수 있게 하는 패턴, 유연성을 제공한다
	- 구성
		- 인터페이스
		- 다양한 방식의 구현 클래스
	
	- *람다로 리펙터링*
		- 함수형 인터페이스
		- 람다 표현식

- 템플릿 메서드 패턴
	- 기존 알고리즘을 조금 고쳐야 하는 상황에 사용 -> 메서드에 초점

	- 구성
		- 추상 클래스에서 동작을 정의
		- 구현 클래스에서 추상 클래스를 확장
		```java
		abstract class OnlineBanking {
			public void processCustomer(int id) {
				Customer c = Database.getCustomerWithId(id);
				makeCustomerHappy(c);
			}

			abstract void makeCustomerHappy(Customer c);
		}
		```


	
	- *람다로 리펙터링*
		- 동작 파라미터화를 통해 추상 메서드를 제거
		```java
		public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) {
			Customer c = Database.getCustomerWithId(id);
			makeCustomerHappy.accept(c);
		}
		```

- 옵저버 패턴
	- 객체 간의 일대다(one-to-many) 의존 관계를 관리, 상태 변경시 의존 객체에게 알림을 보내는 패턴
		- GUI 컴포넌트 등에서 자주 사용된다(event listener..)
		- 그래프 탐색처럼 주체는 내부적으로 옵저버 인터페이스를 구현한 객체 목록을 유지하고 자신의 상태가 변경되면 옵저버에게 알림(.notify)을 보낸다
	- 구성
		- 주체(subject) : 상태를 가지고 있는 객체
		- 옵저버(observer) : 주체에 의존하는 객체
	

	- *람다로 리팩토링*
		- 주체 : 상태를 가지는 객체, 매개변수로 람다 받기
		- 람다표현식 : 각 옵저버의 notify를 구현
		> 옵저버가 상태를 가지고 메서드가 복잡하다면 기존의 클래스 구현방식이 유리하다

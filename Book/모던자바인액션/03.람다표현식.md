# 어디에, 어떻게 람다를 사용하나
- 함수형 인터페이스 : 하나의 추상 메서드만 가진 인터페이스
    - 디폴트 메서드는 가질 수 있다
    - @FunctionalInterface : 실제로 함수형인터페이스가 아니면 컴파일러가 에러를 발생시킨다

- 함수 디스크립터 : 람다 표현식의 시그니처를 서술하는 메서드

# 람다 활용 : 실행 어라운드 패턴(execute around  pattern)
- 실행 어라운드 패턴 : 중복되는 준비/정리 코드가 작업을 감싸고 있는 형식의 코드
    - (초기화/준비 코드) -> (작업) -> (정리/마무리 코드)
    - 작업 코드를 람다로 전달받아서 동작파라미터화할 수 있다

```java
// 예시
public String processFile(BufferedReaderProcessorInterface p) throws IOException {
    try (BufferedReader br = (new FileReader("data.txt"))) {
        return p.process(br);
        }
    }
```

# 함수형 인터페이스 사용
- `Predicate<T>, Consumer<T>, Function<T, R> `...

- 함수형 인터페이스는 *확인된 예외*를 던지는 동작을 허용하지 않는다
    - 시그니처에 직접 정의하거나 try-catch로 람다를 감싸야 사용가능

# 형식 검사, 형식 추론, 제약
- 형식 검사 : 람다가 할당될 변수, 람다의 파라미터등을 통해서 대상 형식(target type)을 지정한다


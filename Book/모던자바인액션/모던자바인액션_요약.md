### 01. 자바 8, 9, 10, 11
- Java 8
	- Steam API
		- 병렬 처리가 공짜
	- 람다와 메서드 참조
	- 인터페이스의 디폴트 메서드

### 02. 동작 파라미터화
```java
public static <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> result = new ArrayList<>();
	for(T e: list) {
			if(p.do(e)){
					result.add(e);
			}
	}
	return result;
}

List<Apple> redApples = filter(apples, (Apple apple) -> RED.equals(apple.getColor()));
```

### 03. 람다 표현식
- 실행 어라운드 패턴 : 중복되는 준비/정리 코드가 작업을 감싸고 있는 형식의 코드(동작 파라미터화)
- Lambda
	- 형식 추론
	- 람다 캡쳐링 : 외부 변수 활용

```java
void sort(Comparator<? super E> c)

items.sort(Comparator.comparing(item::getWeight));
```

### 04. 스트림 소개
- 파이프라이닝(pipelining) : 스트림은 자신을 반환해서 연결한다
    - laziness, short-circuiting 같은 최적화가 가능해진다
		- allMatch, anyMatch, noneMatch, findFirst, findAny

- 스트림은 요청할 때만 요소를 계산하는(메모리사용) 고정된 자료구조

### 06. 스트림 데이터 수집
- Collectors
    - .counting()
    - .maxBy(obj::getValue)
    - .minBy(obj::getValue)
    - .summing{Int,Long,Double}(obj::getValue)
    - .averaging{Int,Long,Double}(obj::getValue)
    - .summerizing{Int,Long,Double}(obj::getValue)
        - IntSummaryStatistics,... 클래스로 모든 정보가 수집된다

    - .joining("구분자")
    - .reducing(초기값, obj::getValue, 연산 함수)
        - (연산함수) -> Optional 반환

    - .groupingBy(맵의 키)
        - (맵의 키, filtering(predicate), toList()) : 값이 없는 키의 맵도 생성된다
            - toSet(), toCollection(HashSet::new) 와 같은 방법도 가능
        - (맵의 키, 컬렉터) : 원하는 형태로 값을 수집한다

    - collectingAndThen(컬렉터, 변환 함수)
        - 컬렉터의 반환 값이 Optional일 경우 변환 함수로 Optional::get을 사용해서 간단하게 값을 수집할 수 있다
        - groupingBy와 같은 최종 연산에서 유용하게 사용할 수 있다

    - partitioningBy(predicate)

- Collector 인터페이스를 직접 구현해서 효율적인 컬렉터를 만들 수 있다
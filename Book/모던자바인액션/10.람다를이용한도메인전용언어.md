- "프로그램은 사람들이 이해할 수 있도록 작성되어야 하는 것이 중요하며 실행하는 부분은 부차적일 뿐" - 하롤드 아벨슨

- 도메인 전용 언어(DSL)은 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어이다
	- HTML, SQL ...
	- 특정 도메인을 위한 메서드명 관습을 만드는 것도 DSL이라고 할 수 있다(예: JUnit, JPA)

## 01.도메인 전용 언어
- DSL의 장점
	- 간결함, 가독성, 유지보수, 특정 목적에 집중, 관심사 분리

- DSL의 단점
	- DSL 설계가 어려움 : 간결하고 제한적인 언어에 도메인 지식을 담는 것은 쉬운 일이 아니다
	- 개발 비용 : DSL을 추가하거나 유지보수/변경 하는 일은 많은 비용과 시간이 소모된다
	- 추가 우회계층 : DSL은 추가적인 계층으로 도메인 모델을 감싸고 계층을 작게 만들어 성능 문제를 회피해야 한다
	- 새로 배워야 하는 언어 : 여러 비즈니스 도메인을 다루는 개별 DSL을 사용한다면 이들이 유기적으로 동작하도록 합치는 것은 쉬운 일이 아니다, 개별 DSL이 독립적으로 진화 할 수 있기 때문
	- 호스팅 언어 한계 : 자바 처럼 장황하고 엄격한 문법으로 사용자 친화적 DSL을 만들기는 어렵다, 람다가 해결책이 될 수 있다
	> 자바가 아닌 다른 언어로 DSL을 구현하는 방법도 있다


- JVM에서 이용할 수 있는 다른 DSL 해결책
	- 내부(embed) DSL : 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현
		- 람다를 활용하면 간결하게 구현 가능
		- 기존의 코드와 함께 DSL을 컴파일 할 수 있어서 다른 컴파일러나 외부 도구를 사용할 필요가 없다
		- 팀이 새로 배워야 할 것이 줄어든다
		- IDE의 기능을 그대로 사용가능 하다

	- 다중 DSL : 여러 도메인 별로 각 DSL이 필요한 상황에 자바를 이용해서 쉽게 합칠 수 있다
		- JVM은 100개 이상의 언어를 실행할 수 있다
		- 두 개이상의 언어가 혼재한 경우 여러 컴파일러를 사용해야 한다

	- 외부(standalone) DSL : 호스팅 언어와는 독립적으로 자체의 문법으로 구현
		- 새 언어를 설계해서 DSL을 실행할 코드를 만들어야 한다
			- 무한한 유연성을 가지지만 개발 비용이 많이 든다
		
		- DSL로 구현한 비즈니스 코드를 명확하게 분리할 수 있지만 이로 인해 호스트 언어 사이에 인공 계층이 생긴다

## 02. 최신 자바 API의 작은 DSL
- 스트림 API는 컬렉션을 조작하는 DSL
	- 스트림 API의 플루언트 형식은 잘 설계된 DSL의 특징을 가지고 있다

- 데이터를 수집하는 DSL인 Collectors
	- Collectors를 중첩하면 다중 수준의 Collector를 만들 수 있다


## 03. 자바로 DSL을 만드는 패턴과 기법
- DSL은 도메인 모델에 친화적이고 가독성이 높은 API를 제공한다
- DSL 예제
	- 주식 거래 주문을 처리하는 도메인 모델
		```java
		// 시장의 주식 가격을 모델링한 순수 자바 빈즈
		@Getter
		@Setter
		private class Stock {
			private String symbol;
			private String market;

			public void setSymbol(String symbol) {
				this.symbol = symbol;
			}
		}

		// 주식을 사고 파는 거래
		@Getter
		@Setter
		public class Trade {
			public enum Type {BUY, SELL}
			private Type type;

			private Stock stock;
			private int quantity;
			private double price;
		}

		// 한 개이상의 거래 주문
		@Getter
		@Setter
		public class Order {
			private String customer;
			private List<Trade> trades = new ArrayList<>();

			public void addTrade(Trade trade) {
				trades.add(trade);
			}
		}

		Order order = new Order();
		order.setCustomer("BigBank");

		Trade trade1 = new Trade();
		trade1.setType(Trade.Type.BUY);

		Stock stock1 = new Stock();
		sotck1.setSymbol("IBM");
		sotck1.setMarket("NYSE");

		trade1.setStock(stock1);
		trade1.setQuantity(80);
		trade1.setPrice(125.00);
		order.addTrade(trade1);	
		```
		- 도메인 모델은 직관적이지만 주문을 의미하는 객체를 만들기 위해 상당히 장황하게 작성해야 한다
	

	1. 메서드 체인 : DSL의 가장 흔한 방식 중 하나로 한 개의 메서드 호출 체인으로 거래 주문을 정의할 수 있다
		```java
		Order order = forCustomer("BigBank")
			.buy(80)
			.stock("IBM")
			.on("NYSE")
			.at(125.00)
			.sell(50)
			.stock("GOOGLE")
			.on("NASDAQ")
			.at(375.00)
			.end();
		```
		- 플루언트 API로 도메인 객체를 만드는 몇 개의 빌더를 구현해야 한다
			```java
			// Order builder
			public class MethodChainingOrderBuilder{
				public final Order order = new Order();

				private MethodChainingOrderBuilder(String customer) {
					order.setCustomer(customer);
				}

				public static Order forCustomer(String customer) {
					return new MethodChainingOrderBuilder(customer).order;
				}


				// 거래에 대한 정보는 해당 객체의 빌더를 사용하도록 한다
				public TradeBuilder buy(int quantity) {
					return new TradeBuilder(this, Trade.Type.BUY, quantity);
				}

				public TradeBuilder sell(int quantity) {
					return new TradeBuilder(this, Trade.Type.SELL, quantity);
				}

				public MethodChainingOrderBuilder addTrade(Trade trade) {
					order.addTrade(trade);
					return this;
				}
			}

			public class TradeBuilder {
				private final MethodChainingOrderBuilder builder; // 빌더를 저장해서 체이닝을 계속할 수 있도록 한다
				public final Trade trade = new Trade();

				private TradeBuilder(MethodChainingOrderBuilder builder, Trade.Type type, int quantity) {
					this.builder = builder;
					trade.setType(type);
					trade.setQuantity(quantity);
				}

				public StockBuilder stock(String symbol) {
					return new StockBuilder(builder, trade, symbol);
				}
			}

			public class StockBuilder {
				private final MethodChainingOrderBuilder builder;
				private final Trade trade;
				public final Stock stock = new Stock();

				private StockBuilder(MethodChainingOrderBuilder builder, Trade trade, String symbol) {
					this.builder = builder;
					this.trade = trade;
					stock.setSymbol(symbol);
				}

				public TradeBuilder on(String market) {
					stock.setMarket(market);
					trade.setStock(stock);
					return new TradeBuilder(builder, trade.getType(), trade.getQuantity());
				}
			}
			```
			- 두 거래 빌더를 따로 만듦으로써 절차에 따라 플루언트 API를 호출하도록 강제한다
			- 정적 메서드 사용을 최소화하고 메서드 이름이 인수 이름을 대신하도록 해서 가독성을 더한다

	
	



# 병렬 스트림
- Stream
    - .parallel() : 순차스트림을 병렬 스트림으로 변환
    - .sequential() : 병렬스트림을 순차스트림으로 변환
    - 전체중에 마지막에 호출된 메서드가 파이프라인을 실행할 전략을 결정한다

- 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다

## 스트림 성능 측정
- *성능을 최적화 할 때 는 첫째도 측정 둘때도 측정...*
- Java Microbenchmark Harness(JMH) : 어노테이션 기반으로 작은 벤치마크를 구현할 수 있다
    ```java
    @BenchmarkMode(Mode.AverageTime) // 대상 메서드 실행 평균 시간 측정
    @OutputTimeUnit(TimeUnit.MILLISECONDS) // 벤치마크 결과를 밀리초 단위로 출력
    @Fork(2, jvmArgs={"-Xms4G", "-Xmx4G"}) // 4Gb의 힙 공간을 제공한 환경에서 두번 벤치마크를 수행
    public class ParallelBench{
        @Benchmark
        public long test(){
            }

        @TearDown(Level.Invocation) // 매 번 벤치마크를 실행후 다음에는 GC 동작 시도
        public void tearDown(){
            System.gc();
            }
    }
    ```
    - `java -jar ./target/benchmarks.jar ParallelStreamBenchmark` 와같이 실행할 수 있다

- iterate 연산으로 반복덧셈을 병렬 처리시 순차 처리보다 느려진다
    - 반복 결과로 박싱된 객체가 만들어져서 더하려면 언박싱을 해야한다
    - 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다
        1. *리듀싱처럼 시작시점에 전체 리스트가 준비 되지 않아서 청크로 분할할 수 없다*
        2. 순차처리 방식처럼 처리되고 스레드를 할당하는 오버헤드만 증가




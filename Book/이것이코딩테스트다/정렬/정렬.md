# 정렬
- 기준에 따라서 순서대로 나열하는 것
- 문제에서 요구하는 조건에 따라서 적절한 정렬 알고리즘이 공식처럼 사용된다

- 선택 정렬
    - 가장 작은 데이터를 선택 맨 앞의 데이터와 바꾸는 방법
    - 정렬해야할 데이터를 가장앞으로 보내는 과정을 N-1번 반복하명 정렬이 완료된다
    - 시간 복잡도 : O(N2승)
    

- 삽입 정렬
    - 선택 정렬에 비해 실행 시간 측면에서 더 효율적
    - 데이터가 거의 정렬 되어있을 때 더 효율적이다
    - 과정
        - 첫번째 데이터를 기준으로 시작
        - 다음 값을 비교 해서 크면 두고 작으면 다시 왼쪽으로 이동
        - 첫자리이거나 더 작은수를 만나면 멈추고 그자리에 삽입한다
        - 다시 오른쪽으로 탐색 
        - 반복
    
    - 시간 복잡도 : O(N2승)
        - 최선의 경우 O(N)
- 퀵 정렬
    - 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 배열을 반으로 나누는 방식으로 동작
    - 호어분할 방식 : 배열의 첫 번째 데이터를 피벗으로 정한다
    - 과정
        - 피벗을 정한다
        - 정렬할 데이터의 왼쪽에서 피벗보다 작은값을 찾는다
        - 정렬할 데이터의 오른쪽에서 피벗보다 큰값을 찾는다
        - 두 데이터를 바꾼다
        - 반복해서 왼쪽과 오른쪽이 서로 지나치면 작은값과 피벗을 바꾼다
        - 피벗의 오른쪽과 왼쪽을 분할해서 다시 반복한다

    - 시간 복잡도 : O(NlogN)
        - 최악의 경우 O(N2승) :이미 데이터가 정렬되어 있는 경우, 피벗값이 가장 작거나 가장 큰값인 경우 

- 계수 정렬
    - 매우 빠른 알고리즘
    - 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적이다
    - 데이터에 따라서 심각한 비효율성을 초래할 수 있다
    - 과정
        - 데이터의 가장 작은값부터 가장 큰값까지 길이의 배열을 만든다
        - 각 데이터를 0으로 초기화 한다
        - 정렬할 데이터를 하나씩 확인해서 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다


    - 시간 복잡도 : O(N+K)


- sorted()
    - 항상 O(NlogN)을 보장한다
    - c언어로 최적화가 되어있어서 빠르다
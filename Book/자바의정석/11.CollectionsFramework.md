# 컬렉션 프레임워크
데이터 군을 저장하는 클래스들을 표준화한 설계

- 핵심 인터페이스
    - Collection
        - List 
            - 구현 클래스 : ArrayList, LinkedList, (Stack, Vector)

        - Set
            - 구현 클래스 : HashSet, TreeSet

    - Map
        - 구현 클래스 : HashMap, TreeMap, (Hashtable, Properties)

    - Vector, Stack, Hashtable, Properties 는 컬렉션 프레임워크 이전에 존재 하던것으로 남아있지만 새로 추가된 기능을 사용하는 것이 좋다

- Collection
    - 메서드
        - add{All}  : 객체(들) 추가
        - clear     : 모두 삭제
        - remove{All}   : 지정객체(들) 삭제
        - retainAll : 지정된 객체들만 남기고 삭제  
        - contain{All}  : 객체(들) 확인
        - toArray   : 객체(들)을 Object배열로 반환
        - hashCode  : 해쉬코드 반환
        - iterator  : iterator객체로 반환
        - isEmpty, equals, size 
    
    - Collection.List
        - 메서드
            - add{All}  : 인덱스 위치에 추가
            - set       : 인덱스 위치에 값 저장
            - remove    : 인덱스 위치의 값 삭제
            - get       : 인덱스 위치의 값 반환
            - {i, lastI}ndexOf  : 처음, 마지막 부터 인덱스위치 값반환
            - listIterator  : ListIterator 반환
            - subList   : 인덱스 범위의 값을 객체로 반환
            - sort      : 정렬
        
    - Collection.Set
        - HashSet, TreeSet
- Map
    - Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap 등의 구현클래스가 있다

    - 메서드
        - put{All}  : 키 위치에 값 추가, 모든 키,값 추가
        - clear, remove     : 모두 삭제, 키 위치 삭제
        - contains{Key, Value}  : 키, 값 이있는지 확인
        - values    : 모든 값을 Collection객체로 반환ㅓ
        - {key, entry}Set   : (키),(키, 값)을 Set으로 반환
        - size equals, haxhCode, isEmpty,  
        
    - Map.Entry
        - Map인터페이스의 내부 인터페이스로 Map인터페이스를 구현시에 같이 구현해야 한다

        - 메서드
            - equals, getKey, getValue, setValue, hashCode
                

- ArrayList
    - 가장 많이 사용되는 컬렉션 클래스, Object배열을 이용해서 데이터를 순차적으로 저장한다
        - 모든 종류의 객체를 담을 수 있다
    
    - 생성자 : 크기가 10인 ArrayList 생성
        - Collection 저장한 배열생성, int의 초기용량배열생성

    - 메서드
        - add{All}      : 마지막, 인덱스위치에 추가
        - ensureCapacity    : 용량이 int보다 크도록한다
        - trimToSize    : 용량을 크기에 맞게 줄인다(빈공간삭제)
        - clone
        - clear, remove{All}(위치or객체), retainAll, get, set, sort, contains, isEmpty, size, toArray, {i, lastI}ndexof, {i, listI}terator,  

    - 지정한 크기보다 더 많은 객체를 저장하면 자동으로 크기가 늘어나지만 처리시간이 많이 소요되기때문에 크기를 여유있게 잡아야한다
    - Capacity와 Size는 다른 개념이다 Size는 사용하고 있는 공간, Capacity는 총 사용할수 있는 공간

    - 삭제 연산
        - remove는 삭제할 객체의 바로 아래 객체가 삭제할 객체를 덮어쓰는 방식으로 처리한다
            - System.arraycopy(data, 3, data, 2, 2);
            - 마지막 인덱스에 저장된 것을 삭제하면 빠르지만 중간 인덱스에 객체를 삭제하려면 데이터가 많을수록 오래걸린다

        - 값을 삭제 할 때는 마지막 인덱스부터 하나씩 줄여가면서 비교 삭제해야 한다
            - 자리이동을 방해받지 않고 하기위해

    - 특징
        - 배열은 가장 기본적인 형태의 자료구조로 데이터가 메모리에서 연속적으로 존재
            - 데이터를 읽을 때 접근시간이 가장 빠르다
            - 크기를 변경할 수 없다, 새로운 배열을 생성해야한다
            - 비순차적인 데이터의 추가, 삭제는 시간이 많이걸린다
                - 순차적으로 추가하거나 마지막데이터를 삭제하는 경우 가장 빠르다

- LinkedList
    - 접근성을 높이기 위해 이중 연결리스트로 구현되었다

    - 이중 연결 리스트
        - 양 방향으로 연결된 리스트, 양 쪽방향의 주소값을 저장한다
        - 역 방향으로도 움직일수 있기 때문에 접근과 이동이 더 쉽다

        - 이중 원형 연결리스트
            - 시작과 끝을 양방향으로 연결한 연결 리스트

    - 생성자 : 주어진 컬렉션을 포함할 수 있다
    - 메서드
        - 상속받은 메서드를 거의 모두 사용가능하다
        - Queue 인터페이스 구현
            - element, peek : 첫번째 요소 반환
            - poll      : 첫번째 요소 반환, 삭제
            - offer     : 끝에 추가
            - remove    : 첫번째 요소 제거

        - Deque 인터페이스 구현
            - add{First, Last}  : 추가,(push)
            - offer{F, L}   : 추가, bool값반환
            - {get, peek}{F, L}     : 값 반환
            - remove{F, L}  : 삭제, (pop)
            - poll{F, L}    : 값 반환, 삭제
            - remove{F, L}Occurrence: 일치하는 객체제거
            - descendingIerator : 역순 이터레이터 반환

    - 특징
        - 데이터필드와 링크필드(주소값)으로 이루어진 하나의 노드들이 주소를 통해서 불연속적으로 존재 
           - 데이터를 읽어올 때 n번째 데이터까지 따라가야만 값을 얻을 수 있기때문에 접근 시간이 느리다
            - 비순차적으로  데이터를 추가, 삭제하는게 쉽다, 가장 빠르다(주소만 변경하면 된다)
                - 크기 변경이 쉽다

- Stack과 Queue
    - 스택은 ArrayList로 큐는 LinkedList로 구현하는 할 수 있다

    - Stack 클래스
        - push, pop-비었으면 예외, peek, empty, search
    
    - Queue 인터페이스
        - add, remove-비었으면 예외, element, offer, poll, peek
        - PriorityQueue 클래스
            - 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼낸다
            - 배열으로 구현되어있고 '힙'이라는 자료구조 형태이다
        
        - Deque 인터페이스
            - 양쪽 끝에서 추가/ 삭제, 스택과 큐를 합쳐놓은 형태이다
            - 구현 클래스 : ArrayDeque, LinkedList

    - 스택은 클래스로 구현되있지만 큐는 인터페이스이기 때문에 구현된 클래스를 골라 사용하면 된다

- Iterator, ListIteratro, (Enumeration)
    - 컬렉션에 저장된 요소에 접근하는데 사용되는 인터페이스로 읽어오는 방법을 표준화했다
        - Enumeratino은 Iterator의 구 버전이고 Iterator의 기능을 추가한것이 ListIterator이다

    - Collection를 구현한 클래스에 대해 iterator를 호출해서 얻은 객체로 요소들을 읽어올수 있다
        - Map 인터페이스는 값을 쌍으로 가지고 있기 때문에 키와 값을 따로 Set형태로 변환해서 iterator를 호출 해야 한다

    - 메서드    
        - hasNext   : 남은 요소가 있는지 확인
        - next      : 다음 요소를 읽어온다
        - remove    : 읽어 온 요소를 삭제
            - 읽어 온 값의 인덱스를 lastRet에 저장해서 삭제한다
            - 삭제후에 lastRet은 null값을 가진다

    - ListIterator
        - 양 방향으로 이동을 가능하게 한다
        - List인터페이스를 구현한 클래스만 사용 할 수 있다

        - 메서드
            - hasPrevious, previous 
            - {next, previous}Index : 다음, 이전 요소의 인덱스 반환
            - set   : 읽어온 객체를 변경한다

    - 인터페이스를 상속 받아서 구현할 경우 빈 블럭으로 두면 안된다
        - 메서드를 구현하지 않는 경우 UnsupportedOperationException을 발생시키도록 구현해야 한다
            - RuntimeException이기 때문에 선언부에 명시하지 않아도 된다
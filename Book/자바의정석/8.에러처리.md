# 예외처리(exception handling)
- 프로그램 오류
 	- 컴파일 에러 : 컴파일 시에 발생하는 에러
	- 런타임 에러 : 실행 시에 발생하는 에러
		- 에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
 		- 예외(exceprion) : 프로그램 코드에 의해서 수습될 수 있는 약한 오류
	- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것

- 예외 클래스의 계층구조
	- Object 	- Throwbble - Exception
 		     	- Error

	- Exception - IOExe..ClassNot....(CompileException)
	            - RuntimeException - ...


- 위와 같이 예외 클래스들은 두 그룹으로 나뉜다
	- Exception 클래스들 : 사용자의 실수같은 외적요인으로 발생
	 RuntimeException 클래스들 : 프로그래머의 실수로 발생

- 예외 처리하기(try-catch)
	- 예외에 대비한 코드를 작성하는 것으로 비정상종료를 막고 정상적인 실행상태를 유지하도록 한다
		- 에러와 예외는 모두 실행시 발생하는 오류이다
		- 처리되지 못한 예외는 JVM의 예외처리기가 받아서 원인을 출력한다
		- 예외문은 괄호를 생략할 수 없다

	- try-catch문이 중첩된 경우 같은 이름의 예외참조변수를 사용하면 안된다

- 예외의 발생, catch
	- 예외가 발생한 위치이후의 try블럭은 수행되지 않는다
	- 예외가 발생하면 해당예외클래스의 인스턴스가 생성된다
		- instanceof 연산자로 catch블럭의 괄호내의 선언된 참조변수와 검사한다
		- true인 catch블럭을 수행하고 예외문 종료
	
	- printStackTrace()
		- 예외 발생후 호출 스택에 있던 메서드의 정보와 예외메시지를 출력
		
	- getMessage()
		- 예외 클래스 인스턴스에 저장된 메시지를 얻는티

	- 멀티 catch 블럭
		- '|'기호를 이용해서 catch블럭을 합칠 수 있다
		- catch(ExceptionA | ExceptionB)
		- 합쳐진 예외 클래스가 상속 관계이면 컴파일 에러가 발생
			- 불필요한 코드를 제거해야 한다

		- 예외인스턴스의 참조변수는 합쳐진 예외클래스의 조상클래스타입으로 선언된다
			- 합쳐진 클래스의 동일한 조상의 멤버만 사용가능
			- 어떤 예외 클래스의 예외인지 알수 없다
		
		- catch블럭에 선언된 참조변수는 상수여서 변경할 수 없다

- 예외 발생시키기
	- throw
		- 예외 클래스의 인스턴스를 명시해서 예외를 던진다
		- throw new Exception("예외");
		- 예외클래스 생성자에 문자열을 주면 인스턴스에 메시지로 저장된다
	- checked예외, unchecked예외
		-  checked : 발생한 컴파일예외(Exception)를 처리하지 않으면 컴파일 에러가 발생 컴파일이 되지 않는다
		- unchecked : 발생한 런타임예외(RuntimeException)는 컴파일이 되지만 실행하면 예외가 발생한다

- 메서드에 예외 선언
	- throws
		- 메서드의 선언부에 throws 예외클래스를 선언
		- ','를 구분자로 여러개 선언할 수 있다
		- 오버라이딩 할때 상속관계를 고려해아한다
		- 메서드 선언부에 명시해서 예외처리를 강요할 수 있다
	
	- 메서드에 예외를 선언할 때 일반적으로 Runtime예외는 적지 않는다
		- 반드시 처리해야하는 checked예외를 선언한다

	- 메서드에 선언한 예외를 호출한 메서드에게 전달해서 예외처리를 떠 맡기는 것
		- 호출 스택에 있는 메서드들을 따라 전달되고 처리되지 않으면 종료된다
		- 어느한 곳에서는 예외처리를 해줘야 한다

- finally
	- 예외의 발생여부에 상관없이 실행된다
	- 예외문에서 return문을 만나도 finally블럭이다실행된다

- 자동 자원 반환 (try-with-resources)
	- 주로 입출력에 사용되는 클래스중에서 사용후 꼭 닫아줘야 하는 것들을 자동으로 닫아준다
	- 자동으로 객체의 close()가 호출 되기위해 AutoCloseable을 구현한 클래스 여야 한다
	- close()에서 예외가 발생할 수도 있다
		- 일반 try-catch문은 복수의 예외가 발생하면 이전의 예외는 무시된다
		- try-with-resources는 억제된 예외인스턴스를 실제발생한 예외 인스턴스에 저장한다
			- Throwable에 억제된 예외 관련메서드가 정의되있다
				- addSuppressed(), getSuppressed()

- 사용자 정의 예외 만들기
	- Exception을 상속받는 모든 예외클래스들은 생성 시에 문자열을 받아서 메시지로 저장할 수 있다
		- super(msg); 를 생성자에 추가해야한다
	
	- 요즘은 Exception을 상속받아서 'checked예외'로 작성하기 보다는 예외 처리를 선택적으로 할 수 있는 RuntimeException을 상속 받아서 작성하고 있다
		- 반드시 예외처리를 해줘야하면 코드가 복잡해진다
		- 필요에 따라 선택할 수 있는 'unchecked예외'가 더 환영받고 있다


- 예외 되던지기
	- 예외를 처리할 후에 인위적으로 다시 발생시키는 방법
		- catch문에서 throw문으로 예외를 다시 던진다
		- throws문을 선언부에 명시해 줘야 한다
	- 발생할 수 있는 예외가 여럿인 경우 자체적으로 처리하고 호출한 메서드로 전달 해서 나눠서 처리할 수 도 있다
	
	- 반환값이 있는 경우 catch문에도 return문이 있어야하는데 예외 되던지기를 하면 return문이 없어도 된다
		- finally문에 return문이 있으면 최종적으로 finally문의 값이 반환된다

- 연결된 예외
	- 예외 A가 예외 B를 발생 시켰다면 A를 B의 원인 예외 라고 한다
	- 예외인스턴스.initCause(발생한예외참조변수)
		- initCause로 원인예외를 등록
		- throw로 새로 생성된 인스턴스를 던진다
		- getCause()로 원인 예외를 반환할 수 있다
	
	- 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해 사용한다
	- checked예외를 unchecked예외로 바꾸기 위해서 사용한다
		- Exception의 자손을 RuntimeException으로 감싸서 unchacked로 만들 수도 있다	



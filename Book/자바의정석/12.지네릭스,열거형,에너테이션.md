# Generics
- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능
    - 런타임에러를 컴파일에러로 처리할 수 있도록 한다
    - 타입 안정성을 높이고 형변환의 번거로움이 줄어든다, 잘못 형변환 되어 발생할 수 있는 오류를 줄인다

- 선언
    - 지네릭 타입은 클래스와 메서드에 선언할 수 있다
    - ```class A<T> {} ```
        - 클래스 옆에 타입변수를 붙이면 지네릭 클래스로 변경된다
        - T(Type), E(Element), K(Key), V(Value)등의 타입이름을 사용한다
            - 기호만 다를 뿐 임의의 참조형 타입을 의미하는 것이다
        
        - Object타입은 인스턴스의 메서드를 사용하기위해 형변환이 불가피 했지만 이제 원하는 타입을 타입변수에 지정해주기만 하면 된다

    - ```A<String> a = new A<String>``한
        - 클래스내에 정의된 타입변수를 지정하지 않을 수 있지만 경고가 발생한다
            - Object타입을 지정하면 경고는 발생하지 않는다

        - 서로 다른 타입을 대입하여 호출한 것일 뿐, 매개변수의 값이 다른 메서드호출과 같다

    - 컴파일 후에 지네릭 타입은 모두 제거되고 원시 타입으로 바뀐다        
        - 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다


    - 용어
        - 원시타입, 타입변수, 지네릭 타입 호출
    
    - 제한
        - 동일하게 동작해야하는 static멤버의 타입변수 T를 사용할 수 없다
            - 클래스로더에 의해서 메모리에 올라갈 때 한번만 정의 되기 때문이다
            - T는 인스턴스 변수로 간주된다

        - 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다(new T[10])
            - 참조변수를 선언하는 것은 가능하다(T[] a;)

        - new, instanceof 연산자는 컴파일 시점에 타입이 뭔지 정확히 알아야 하기 때문에 T를 피연산자로 사용할 수 없다


- 생성과 사용
    - 지네릭을 이용해서 Collection의 클래스들이 한가지 타입만 갖도록 할 수 있다
    - ```A<String> a = new B<>```
        - 생성할 때는 참조변수와 생성자에 대입된 타입이 일치해야한
        - 타입변수는 상속관계를 제한하지 않으면 상속관계를 가리킬수 없다
        - 인스턴스가 참조변수의 상속관계이면서 같은 타입변수를 갖는 것은 괜찮다
        - jdk1.7부터 추정가능한 타입은 생략할 수 있게 됬다

    - ```void add(<T> item)```
        - 기존의 매개변수와 똑같이 대입된 타입의 상속관계를 받을 수 있다

    

- 제한된 지네릭 클래스
    - ```Class A<T extends Collection & Comparable> {}}```
        - 타입변수 T에 지정할 수 있는 타입을 Collection을 구현한 클래스로 제한할 수 있다, 동시에 다형성을 더 명확하게 유지할 수 있다
        - 인터페이스도 'extends'를 사용한다
        - 클래스와 인터페이스를 같이 구현할 경우 '&'로 구분해준다

- ***와일드 카드***
    - 종류
        - <? extends T> : T와 그 자손들만 가능, 상한 제한
        - <? super T>   : T와 그 조상들만 가능, 하한 제한
        - <?>           : 제한없음, (<? extends Object>와 같다)

    - ```static void add(B<? extends A> item)```
        - ***"A클래스를 구현한 클래스를 타입변수로"*** 받는 ***"B타입을 구현한 클래스"***를 매개변수로 받는다
    
    - ```static <T> void sort(List<T> list, Comparator<? supers T> c)``` 지네릭 메서드
        - -> static < String > void sort(List< String >, Comparator<? supers String>)
            - String타입변수를 가진 List, String의 조상타입변수를 가진 Comparator
            - 조상타입의 메서드를 사용할 수 있다
                - 새로운 자손이 생길 때마다 새로운 정렬방법을 정의해야하는 것을 막을 수 있다

            - Comparator는 항상 <? super T>가 따라 붙는다
        


- 지네릭 메서드
    - 선언부에 지네릭 타입이 선언된 메서드, 타입변수의 선언위치는 반환타입 바로앞이다
    - ```static <T> void sort(List<T> list, Comparator<? super T> c```
        - 같은 T문자를 사용해도 클래스에 정의된 타입 매개변수와 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다
            - 같은 이유로 내부 클래스와 외부 클래스의 타입문자가 같아도 구별된다

        - static 멤버는 타입 매개변수를 사용할 수 없지만 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다
            - 호출마다 정의 할 수 있기 때문

    - 호출
        ```java
        // 지네릭 인스턴스 생성
        List<String> info = new List<>();

        // 지네릭 메서드 호출
        class.<String>sort(info);

        // 추정가능한 타입변수 생략
        class.sort(info);  
        // info를 선언할 때 <String>을 명시했기 때문에 추정 가능하다
        ```
        - 대부분의 경우 컴파일러가 변수를 통해서 타입을 추정할 수 있기 때문에 생략해도 된다
        - 대입된 타입을 생략할 수 없는 경우에는 같은 클래스 안에서도 참조변수나 클래스 이름을 생략할 수 없다
            ```java
            class A {
                static <T> void a(~~) {}

                void b() {
                    a(x);
                    this.<Integer>a(x);
                    A.<Integer>a(x);
                    <Integer>a(x);  // 같은 클래스지만 에러발생!!
                }
            }
            ```
        
    - 매개변수에서 타입변수를 여러번 사용할때 지네릭메서드로 타입변수를 한번만 선언해서 코드를 간략히 할 수 있다

    - ```public static <T extends Comparable<? super T>> void sort(List<T> list)```
        - 타입변수가 복잡하게 선언되있을 때 와일드카드를 빼고 보면 된다
            -  ```public static <T extends Comparable<T>> void sort(List<T> list)```
            -  T를 받는 Comparable을 구현한 객체를 요소로 받는(타입변수로 받는) List를 매개변수로 받는다

        - T는 Comparable을 구현한 클래스여야 하고 T또는 그 조상 타입을 비교하는 Comparable 이어야 한다는 것

- 지네릭 타입의 형변환
    - ```a = (A)genericA; genericA = (A<Object>)a```
        - 지네릭 타입과 원시타입간의 형변환은 항상 가능하다
        - 다른 지네릭 타입간에는 형변환이 불가능하다

    - ```A<? extends Object> wA = new A<String>```
        - 형변환이 가능하다, 타입변수가 상속일때 상속된 타입변수는 모두 형변환 가능하다
        - 반대로도 형변환이 성립하지만 확인되지 않은 형변환이라는 경고가 발생한다
            ```java
            A<? extends Object> wA = null;
            A<String> sA = (A<String>)wA    // 미확인타입 형변환 경고
            ```
        
    - ```A<?> empty = new A<>```
        - (? = extends 클래스내에 정의된 조상클래스)와 같기 때문에 생성된 인스턴스의 참조변수에는 Object가 대입된다
            - 클래스에 정의된 타입변수가 T extends List이면 ?는 extends List가 된다

    - ```A<?> -> A<T>``` 
        - 와일드 카드가 포함된 지네릭은 T로 변환이 가능하다
            - Object타입변수를 T로 변환 할 수 는 없다
            - Object타입변수를 와일드 카드가 포함된 타입으로 형변환 하면 가능하다
                ```java
                A<Object> -> A<T> // 불가능
                A<Object> -> A<?> -> A<T> // 가능
                ``` 
        
- 지네릭 타입의 제거
    - 컴파일러는 지네릭타입을 이용해서 소스파일을 체크하고 형변환을 넣어준 다음 지네릭타입을 제거한다
        - 이전의 소스 코드와의 호환성을 유지하기 위해서이다
        - 가능하면 원시타입을 사용하지 않도록 해야 한다
    
    - 과정
        - 지네릭 타입의 경계를 제거 한다, T는 Object로 T extends List는 List로 치환 된다, 지네릭 선언은 제거 된다
        - 타입이 일치하지 않으면 형변환을 추가한다, 와일드 카드가 있는경우 적절한 타입으로 형변환 되어 추가된다
        
    
    


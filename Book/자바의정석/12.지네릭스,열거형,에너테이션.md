# Generics
- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능
    - 런타임에러를 컴파일에러로 처리할 수 있도록 한다
    - 타입 안정성을 높이고 형변환의 번거로움이 줄어든다, 잘못 형변환 되어 발생할 수 있는 오류를 줄인다

- 선언
    - 지네릭 타입은 클래스와 메서드에 선언할 수 있다
    - ```class A<T> {} ```
        - 클래스 옆에 타입변수를 붙이면 지네릭 클래스로 변경된다
        - T(Type), E(Element), K(Key), V(Value)등의 타입이름을 사용한다
            - 기호만 다를 뿐 임의의 참조형 타입을 의미하는 것이다
        
        - Object타입은 인스턴스의 메서드를 사용하기위해 형변환이 불가피 했지만 이제 원하는 타입을 타입변수에 지정해주기만 하면 된다

    - ```A<String> a = new A<String>```
        - 클래스내에 정의된 타입변수를 지정하지 않을 수 있지만 경고가 발생한다
            - Object타입을 지정하면 경고는 발생하지 않는다

        - 서로 다른 타입을 대입하여 호출한 것일 뿐, 매개변수의 값이 다른 메서드호출과 같다

    - 컴파일 후에 지네릭 타입은 모두 제거되고 원시 타입으로 바뀐다        
        - 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다


    - 용어
        - 원시타입, 타입변수, 지네릭 타입 호출
    
    - 제한
        - 동일하게 동작해야하는 static멤버의 타입변수 T를 사용할 수 없다
            - 클래스로더에 의해서 메모리에 올라갈 때 한번만 정의 되기 때문이다
            - T는 인스턴스 변수로 간주된다

        - 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다(new T[10])
            - 참조변수를 선언하는 것은 가능하다(T[] a;)

        - new, instanceof 연산자는 컴파일 시점에 타입이 뭔지 정확히 알아야 하기 때문에 T를 피연산자로 사용할 수 없다


- 생성과 사용
    - 지네릭을 이용해서 Collection의 클래스들이 한가지 타입만 갖도록 할 수 있다
    - ```A<String> a = new B<>```
        - 생성할 때는 참조변수와 생성자에 대입된 타입이 일치해야한
        - 타입변수는 상속관계를 제한하지 않으면 상속관계를 가리킬수 없다
        - 인스턴스가 참조변수의 상속관계이면서 같은 타입변수를 갖는 것은 괜찮다
        - jdk1.7부터 추정가능한 타입은 생략할 수 있게 됬다

    - ```void add(<T> item)```
        - 기존의 매개변수와 똑같이 대입된 타입의 상속관계를 받을 수 있다

    

- 제한된 지네릭 클래스
    - ```Class A<T extends Collection & Comparable> {}}```
        - 타입변수 T에 지정할 수 있는 타입을 Collection을 구현한 클래스로 제한할 수 있다, 동시에 다형성을 더 명확하게 유지할 수 있다
        - 인터페이스도 'extends'를 사용한다
        - 클래스와 인터페이스를 같이 구현할 경우 '&'로 구분해준다

- ***와일드 카드***
    - 종류
        - <? extends T> : T와 그 자손들만 가능, 상한 제한
        - <? super T>   : T와 그 조상들만 가능, 하한 제한
        - <?>           : 제한없음, (<? extends Object>와 같다)

    - ```static void add(B<? extends A> item)```
        - ***"A클래스를 구현한 클래스를 타입변수로"*** 받는 ***"B타입을 구현한 클래스"***를 매개변수로 받는다
    
    - ```static <T> void sort(List<T> list, Comparator<? supers T> c)``` 지네릭 메서드
        - -> static < String > void sort(List< String >, Comparator<? supers String>)
            - String타입변수를 가진 List, String의 조상타입변수를 가진 Comparator
            - 조상타입의 메서드를 사용할 수 있다
                - 새로운 자손이 생길 때마다 새로운 정렬방법을 정의해야하는 것을 막을 수 있다

            - Comparator는 항상 <? super T>가 따라 붙는다
        


- 지네릭 메서드
    - 선언부에 지네릭 타입이 선언된 메서드, 타입변수의 선언위치는 반환타입 바로앞이다
    - ```static <T> void sort(List<T> list, Comparator<? super T> c```
        - 같은 T문자를 사용해도 클래스에 정의된 타입 매개변수와 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다
            - 같은 이유로 내부 클래스와 외부 클래스의 타입문자가 같아도 구별된다

        - static 멤버는 타입 매개변수를 사용할 수 없지만 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다
            - 호출마다 정의 할 수 있기 때문

    - 호출
        ```java
        // 지네릭 인스턴스 생성
        List<String> info = new List<>();

        // 지네릭 메서드 호출
        class.<String>sort(info);

        // 추정가능한 타입변수 생략
        class.sort(info);  
        // info를 선언할 때 <String>을 명시했기 때문에 추정 가능하다
        ```
        - 대부분의 경우 컴파일러가 변수를 통해서 타입을 추정할 수 있기 때문에 생략해도 된다
        - 대입된 타입을 생략할 수 없는 경우에는 같은 클래스 안에서도 참조변수나 클래스 이름을 생략할 수 없다
            ```java
            class A {
                static <T> void a(~~) {}

                void b() {
                    a(x);
                    this.<Integer>a(x);
                    A.<Integer>a(x);
                    <Integer>a(x);  // 같은 클래스지만 에러발생!!
                }
            }
            ```
        
    - 매개변수에서 타입변수를 여러번 사용할때 지네릭메서드로 타입변수를 한번만 선언해서 코드를 간략히 할 수 있다

    - ```public static <T extends Comparable<? super T>> void sort(List<T> list)```
        - 타입변수가 복잡하게 선언되있을 때 와일드카드를 빼고 보면 된다
            -  ```public static <T extends Comparable<T>> void sort(List<T> list)```
            -  T를 받는 Comparable을 구현한 객체를 요소로 받는(타입변수로 받는) List를 매개변수로 받는다

        - T는 Comparable을 구현한 클래스여야 하고 T또는 그 조상 타입을 비교하는 Comparable 이어야 한다는 것

- 지네릭 타입의 형변환
    - ```a = (A)genericA; genericA = (A<Object>)a```
        - 지네릭 타입과 원시타입간의 형변환은 항상 가능하다
        - 다른 지네릭 타입간에는 형변환이 불가능하다

    - ```A<? extends Object> wA = new A<String>```
        - 형변환이 가능하다, 타입변수가 상속일때 상속된 타입변수는 모두 형변환 가능하다
        - 반대로도 형변환이 성립하지만 확인되지 않은 형변환이라는 경고가 발생한다
            ```java
            A<? extends Object> wA = null;
            A<String> sA = (A<String>)wA    // 미확인타입 형변환 경고
            ```
        
    - ```A<?> empty = new A<>```
        - (? = extends 클래스내에 정의된 조상클래스)와 같기 때문에 생성된 인스턴스의 참조변수에는 Object가 대입된다
            - 클래스에 정의된 타입변수가 T extends List이면 ?는 extends List가 된다

    - ```A<?> -> A<T>``` 
        - 와일드 카드가 포함된 지네릭은 T로 변환이 가능하다
            - Object타입변수를 T로 변환 할 수 는 없다
            - Object타입변수를 와일드 카드가 포함된 타입으로 형변환 하면 가능하다
                ```java
                A<Object> -> A<T> // 불가능
                A<Object> -> A<?> -> A<T> // 가능
                ``` 
        
- 지네릭 타입의 제거
    - 컴파일러는 지네릭타입을 이용해서 소스파일을 체크하고 형변환을 넣어준 다음 지네릭타입을 제거한다
        - 이전의 소스 코드와의 호환성을 유지하기 위해서이다
        - 가능하면 원시타입을 사용하지 않도록 해야 한다
    
    - 과정
        - 지네릭 타입의 경계를 제거 한다, T는 Object로 T extends List는 List로 치환 된다, 지네릭 선언은 제거 된다
        - 타입이 일치하지 않으면 형변환을 추가한다, 와일드 카드가 있는경우 적절한 타입으로 형변환 되어 추가된다
        
    
# 열거형(enums)
- 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 유용하다.
    - 값 뿐만 아니라 타입도 관리한다
    - 값을 명시하지 않으면 인덱스 값을 상수의 값으로 사용함..

    - 타입에 안전한 열거형(typesafe enum)
        - 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다

    - 상수의 값이 바뀌면 상수를 참조하는 모든 소스를 다시 컴파일해야 한다
       - 열거형 상수를 사용하면 기존의 소스를 다시 컴파일 하지 않아도 된다

- 열거형의 정의와 사용
    - ```enum 열거형이름 {상수명1, 상수명2, ...}```
        - 열거형이름.상수명 으로 상수값을 사용 할 수 있다
    
    - 열거형 상수간의 비교
        - '==' 를 사용할 수 있지만 '<','>'는 사용할 수 없다
        - 대소비교는 compareTo()를 사용해야 한다
        - switch문의 조건식에 열거형을 사용할 수 있다
            - 열거형 이름은 빼고 상수명만 적어야 한다

- *java.lang.Enum*
    - 모든 열거형의 조상클래스
    - aptjem
        - getDeclaringClass : 열거형의 Class객체를 반환한다
        - name      : 열거형 상수의 이름을 문자열로 반환
        - ordinal   : 열거형 상수가 정의된 순서를 반환
            - 이 값은 내부적인 용도로만 사용되기 위한 메서드이다
        - 이 메서드는 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가해준다
            - valueOf   : 지정된 열거형에서 name매개변수와 일치하는 상수를 반환
                - 열겨형이름.상수명 == 열거형이름.valueOf("상수명")
            - values    : 모든 상수를 배열에 담아 반환한다

    - 열거형에 멤버 추가
        ```java
        enum 열거형이름 {
            상수명1(1, 'a'), 상수명2(10, 'b');  
            private final int value;    
            private final char ch;      
            생성자(int value, char ch) { 
                this.value = value; this.ch = ch;}
        
            
            public int getValue() {return value;}
            public int getCh() {return ch;}
        }
        ```
        - 열거형 상수의 값이 불연속적인 경우 괄호로 정의할 수 있다
        - 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 추가해야 한다
            - 인스턴스 변수는 상수의 인덱스순서와 따라서 상수 값을 사용할 수 있게 해준다
            - 하나의 열거형 상수에 여러 값을 지정할 경우 인스턴스 변수와 생성자의 매개변수도 동일하게추가해야한다

        - 열거형 생성자의 제어자는 묵시적으로 private여서 외부에서 생성자를 사용할 수 없다
        
    - 열거형에 추상메서드 추가
        ```java
        enum A {
            TIME1(30) {
                int addMinute(int time) { return time+minute;}
            }

            abstract int addMinute(int time);  // 상수가 구현할 추상메서드
            protected final int minute;     // 상수값에 접근할 이름, protected로 해야 각 상수에서 접근 가능
        }
        ```
        - 추상메서드를 추가해서  상수 블럭안에서 구현할 수 있다    
            - 각 상수마다 다르게 구현하기 위해서 추상메서드를 선언한 것이다
            - 각 상수값들은 enum에 정의된 것들을 상속받는 익명클래스와 비슷한 역할을 한다

    - 열거형의 이해
        ```java
        class A{
            static final A a = new A("a");  // static상수의 값은 객체의 주소로 '=='로 비교할 수 있다
            private String name;
            private A(String a){
                this.name = a;
            }
        } 
        -> enum A{a}    // 위의 클래스와 같은 의미이다 
                        // a는 "a"값으로 생성한 A클래스의 객체인 것
        ```
        - 열거형 상수 하나하나가 열거형의 객체,인스턴스 이다
        

# 에너테이션(annotation)
- 프로그램 소스코드안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함 시킨 것
    - 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다
    - javadoc.exe
        - 주석 /** ~ */에 소스코드에 대한 정보를 저장해서 HTML문서를 생성 
        - 미리 정의된 @태그를 이용해서 주석안에 정보를 저장, 문서를 작성한다
    
    - @Test
        - 이 에너테이션을 메서드 앞에 붙이면 테스트 프로그램에게 테스트 할 메서드를 알려줄 수 있다

    - 에너테이션은 JDK에서 기본으로 제공하는 것과 다른 프로그램에서 제공하는 것들이 있다

- 표준 에너테이션
    - 표준 에너테이션은 주로 컴파일러를 위해서 유용한 정보를 제공한다(java.lang.annotation)
    - 에터테이션
        - @Override : 메서드가 오버라이딩했다는 것을 알린다
            -  같은 이름의 메서드가 조상에 있는지 확인, 없으면 에러
            
        - @Deprecated : 사용하지 않을 것을 권장
            - 컴파일 할때 deprecated기능이라는 것을 메시지를 출력한다
            - "-Xlint:deprecation" 옵션을 붙여서 컴파일하면 자세한 내용을 출력한다
        
        - @SuppressWarning : 특정 경고메시지를 무시
            - 매개변수로 경고메시지의 종류를 문자열로 지정하면 해당 경고메시지를 무시한다
                - 컴파일 후에 어떠한 메시지도 나타나지 않도록 모두 확인하고 처리해야 한다
                - 경고 억제는 해당 대상에게만 붙여서 억제 범위를 최소화 해야한다
                    - 에너테이션을 붙인 곳에만 경고무시가 적용된다

            - {"deprecation", "unchecked", "rawtypes", "varargs"} 가 있다
            - unchecked : 지네릭스 타입 미지정
            - rawtypes : 지네릭스 미사용
            - varargs : 가변인자의 타입이 지네릭스

        - @SafeVarargs : 지네릭스타입의 가변인자에 사용 
            - 메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우, 선언과 호출하는 부분에서 "unchecked"경고가 발생한다
                - SafeVarargs로 경고를 억제할 수 있다
                - "varargs" 경고는 억제 할 수 없기 때문에 @SuppressWarnings("varargs")와 습관적으로 함께 사용된다
            
            - static, final이 붙은 메서드와 생성자에만 붙일 수 있다
                - 선언부에 붙이면 이 메서드를 호출하는 곳의 경고도 억제된다
            
            - reifiale : 컴파일 후에도 제거되지 않는 타입
            - non_reifiable : 컴파일 후에 제거되는 타입

        - @FunctionalInterface : 함수형 인터페이스에 사용
            - 함수형 인터페이스가 올바르게 선언됬는지 컴파일러가 확인하고 잘못된 경우 에러발생

        - @Nativd : native메서드에서 참조되는 상수앞에 사용 
            - 네이티브 메서드에 의해 참조되는 상수필드에 붙이는 에너테이션이다
                - 네이티브 메서드 : JVM이 설치된 OS의 메서드(보통 C언어)
                    - 자바에서는 선언부만 정의한다
                    - Object클래스의 메서드들은 대부분 네이티브 메서드이다
                    - JNI가 자바에 정의된 네이티브메서드와 OS의 메서드를 연결해준다

    - 메타 에너테이션 "에너테이션을 위한 에너테이션"
        - 에너테이션의 적용대상, 유지기간등을 지정하는데 사용된다(java.lang.annotation)
        - @Target : 에너테이션이 적용가능한 대상을 지정하는데 사용
            - 적용가능한 대상을 지정하는데 사용된다
            - 대상타입 
                - ANNOTATION_TYPE,CONSTRUTOR, FIELD(기본형(멤버변수,enum상수)), LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE(클래스,인터페이스, enum), TYPE_PARAMETER, TYPE_USE(참조형)

        - @Documented : 에너테이션 정보가 javadoc의 문서에 포함되게한다
            - 에너테이션에 대한 정보가 문서에 포함 되도록 한다
            - @Override, @SuppressWarnings 제외하고 모두 이 에너테이션을 포함한다

        - @Inherited : 에너테이션이 자손 클래스에 상속되게 한다

        - @Retention : 에너테이션이 유지되는 범위를 지정
            - 에너테이션의 유지기간을 지정한다
            - 유지 정책
                - SOURCE : 소스파일에만 존재, 클래스파일에서는 삭제
                    - 이 유지정책은 컴파일러를 직접 작성해야해서 사용하지 않는다

                - CLASS : 클래스 파일에 존재, 실행시 사용불가(기본값)
                    - JVM에 로딩 될때 무시되서 실행시 정보를얻을 수 없어서 잘사용되지 않음

                - RUNTIME : 클래스 파일에 존재, 실행시 사용가능
                    - 지역변수에 붙은 에너테이션은 컴파일러만 인식할 수 있어서 실행시 인식되지 않는다

        - @Repeatable : 에너테이션을 반복 적용 할수 있게 한다
            - 하나의 대상에 한 종류의 에너테이션을 여러번 붙일 수 있다
            - 매개변수로 적용할에너테이션명.class 를 지정해야 한다
            - 적용된 에너테이션은 배열타입으로 적용할 값들을 선언할 수 있다
                - 이름이 반드시 value여야 한다

- 에너테이션 타입 정의
    - ```@interface 에너테이션이름 {타입 요소이름(); // 에너테이션의 요소를 선언}```
        - '@' 기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일하다
        - 인터페이스처럼 상수를 정의할 수 있지만 디폴트 메서드는 정의할 수 없다
        - 에너테이션의 요소(메서드)
            - 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가진다
            - 상속으로 구현하지 않아도 된다, 하지만 에너테이션을 적용할 때 요소들의 값들을 모두 "이름=값"으로 지정해줘야 한다
                - ```int cout() default 1; ``` 디폴트 값을 가질 수 있다
                - 요소의 타입이 배열인 경우, 괄호{}를 사용해서 여러 값을 지정할 수 있다
                - 요소가 하나뿐이고 이름이 value인 경우 이름을 생략하고 값만 적어도 된다

- java.lang.annotation.Annotation
    - 모든 에너테이션의 조상은 Annotation이다, 그러나 에너테이션은 상속이 허용되지 않는다
        - Annotation은 인터페이스로 정의되어 있다
        - 에터테이션 객체는 equals, hashCode, toString 메서드를 호출할 수 있다

- 마커 에너테이션 
    - 요소가 하나도 정의 되지 않은 에너테이션이다
    - @Override, @Test 등

- 에너테이션 요소의 규칙
    - 기본형, String, enum, 에너테이션, Class만 타입으로 허용된다
    - ()안에 매개변수를 선언할 수 없다
    - 예외를 선언할 수 없다
    - 요소를 타입 매개변수로 정의 할 수 없다
 
- 클래스 객체
    - 해당 클래스에 대한 모든 정보를 저장, 에너테이션의 정보도 포함되어 있다
    - 클래스이름.class 로 클래스 객체를 참조할 수 있다
    - getAnnotation{s} : 특정, 모든 에너테이션 정보를 반환한다

            







        


            
 
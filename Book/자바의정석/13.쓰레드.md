# 프로세스와 쓰레드
- 프로세스, 쓰레드  
    - '실행 중인 프로그램', OS로 부터 필요한 자원(메모리)을 할당받아서 프로세스가 된다
        - 쓰레드를 경량 프로세스(LWP)라고 부르기도 한다

    - 필요한 데이터, 메모리 등의 자원, 쓰레드로 구성되어있다
        - 자원을 이용해서 실제로 작업을 수행하는 것은 쓰레드이다

    - 둘 이상의 쓰레드를 멀티쓰레드 프로세스라고 한다
        - 쓰레드가 작업을 수행하는데 개별적인 메모리 공간을 필요로 하기 때문에 프로세스의 메모리 한계에 따라 쓰레드의 수가 결정된다

        
- 멀티태스킹, 멀티쓰레딩
    - 멀티 태스킹(다중작업) : 여러개의 프로세스가 동시에 실행되는 것
    - 멀티 쓰레딩 : 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것
        - cpu의 코어가 한번에 단하나의 작업만 수행, 동시에 처리되는 작업의 개수는 코어의 개수와 일치
        - 각 코어가 여러 작업을 번갈아 가며 수행해서 동시에 수행되는 것처럼 보이게 한다
        - 성능이 쓰레드의 개수에 비례하는 것은 아니다
    
    - ***멀티쓰레딩 장단점***
        - CPU의 사용률을 향상 시킨다
        - 자원을 보다 효율적으로 사용할 수 있다
        - 사용자에 대한 응답성이 향상된다
        - 작업이 분리되어 코드가 간결해진다
    
    - 서버 프로그램의 경우 멀티쓰레드로 작성하는것은 필수다
        - 여러개의 쓰레드로 쓰레드와 사용자의 요청이 일대일로 처리되도록 해야 한다
        - 싱글 쓰레드는 사용자의 요청마다 새로운 프로세스를 생성해야하고 쓰레드 보다 더 많은 시간과 메모리가 필요하다
    
- 동기화(synchronization), 교착상태(deadlock) 같은 문제를 고려해야 한다
    > 교착상태
    - 두 쓰레드가 자원을 점유한 상태에서 서로 상대편이 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태


# 쓰레드의 구현과 실행
- Thread클래스 상속, Runnable인터페이스 구현 두가지 방법이 있다
    - 두가지 방법모두 run메서드를 오버라이딩, 구현 해서 쓰레드에서 할 작업을 정의한다(run이 main과 같은 역할)
    - 자바는 다중상속을 지원하지 않기 때문에 Runnable인터페이스를 구현하는 것이 일반적이다
    - Runnable 인터페이스를 구현하는 방법은 재사용성이 높고 일관성을 유지할 수 있기 때문에 보다 객체지향적인 방법이다

- ***Thread클래스***
    - 생성
        ```java
        class T1 extends Thread {public void run() {}}
        T1 th1 = new T1();      // 쓰레드 인스턴스 생성
        ```
        - 상속받은 메서드를 run메서드 블럭에서 직접 호출할 수 있다
            - getName()으로 쓰레드이름을 얻을 수 있다


- ***Runnable인터페이스***
    - run만 정의되어 있는 간단한 인터페이스 이다
    - 생성
        ```java
        class T1 implements Runnable {public void run(){}}
        Runnable r = new T1();      // Runnable구현 인스턴스 생성
        Thread th1 = new Thread(r); // Runnable인스턴스로 쓰레드인스턴스 생성
        
        Thread th2 = new Thread(new T1()); // 한줄로 정의
        ```
        - Runnable 인스턴스를 멤버로 포함해서 정의된 run을 제공받는다
        - Thread클래스의 static메서드인 currentThread()를 호출해서 쓰레드에 대한 참조를 얻어와야만 Thread클래스의 메서드를 run()안에서 호출 할 수 있다
            - Thread.currentThread().getName()으로 쓰레드이름을 얻을 수 있다

- 쓰레드 이름
    - 'Thread-번호' 가 쓰레드이름의 기본값이다
    - Thread 생성자의 매개변수로 이름을 지정할 수 있다

- 쓰레드의 실행순서
    - OS의 스케줄러가 작성한 스케줄에 의해 결정된다
        
- *start(), run()*
    - run()
        - 호출하면 쓰레드와 별개로 작업명령들을 실행할 뿐이다

    - start()
        - 호출하면 새로운 쓰레드 작업을 실행하기 위해 필요한 call stakc을 생성한 다음에 run()을 호출해서 call stack에 첫번째로 올라가게 한다
            - 각 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 한다
                - main메서드의 작업을 수행하는 것은 main쓰레드이다

            - 새로운 쓰레드를 생성하고 실행할 때마다 새로운 호출 스택이 생성되고 쓰레드가 종료되면 호출스택은 소멸한다

    - 쓰레드 실행, 종료 
        - 쓰레드가 둘 이상일 때는 호출스택의 최상위에 있는 메서드라도 대기상태에 있을 수 있다
        - 쓰레드는 주어진 시간동안 작업을 하고 끝난 쓰레드는 종료되고 작업이 남은 쓰레드는 다시 대기상태로 있게 된다
        - 한번 종료된 쓰레드는 다시 실행 할 수 없다
            - 두번 실행하면 IllegalThreadStateException이 발생
        
        - 예외가 발생해서 종료되어도 다른 쓰레드의 영향을 미치지 않는다
        - 실행중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다

# 싱글쓰레드와 멀티쓰레드
- 싱글 쓰레드
    - 하나의 쓰레드로 여러작업을 수행
    - 한 작업을 완료하고 다른 작업을 시작한다
    - 단순히 CPU만을 사용하는 계산작업에 더 유리하다

- 멀티 쓰레드
    - 여러 쓰레드로 여러작업을 수행
    - 짧은 시간동안 쓰레드들이 번갈아 가면서 작업을 수행해서 거의 동시에 작업을 시작하고 완료된다
        > 컨텍스트 스위칭(context switching)
        - 프로세스 또는 쓰레드 간의 작업 전환을 의미한다
    
    - 쓰레드가 각자 서로 다른 자원을 사용하는 작업의 경우 멀티 쓰레드 프로세스가 더 효율적이다
        - 사용자로부터 데이터를 입력받는 작업, 네트워크로 파일을 주고받는 작업, 프린터로 파일을 출력하는 작업, 외부기기와의 입출력을 필요로 하는 작업의 경우
        - 입출력을 기다려야하는 구간에 다른 쓰레드를 실행시킬 수 있게 된다
    
    - 멀티 쓰레드가 느린 경우
        - 쓰레드를 번갈아가면서 작업을 처리하기 때문에 작업전환시간이 소요 된다
        - 한 쓰레드가 '출력'같은 작업을 하는 동안 다른 쓰레드는 기다려야 하는데 이때 발생하는 대기 시간때문이다
        
    - 싱글 코어와 멀티 코어
        - 싱글 코어인 경우 쓰레드의 작업시간이 절대 겹치지 않는다
        - 멀티 코어인 경우 동시에 두 쓰레드가 수행될 수 있어서 작업이 겹치는 부분이 발생한다, 그래서 두 쓰레드가 자원을 놓고 경쟁을 한다
        > 병행(concurrent) 
        - 여러쓰레드가 여러 작업을 동시에 진행하는 것
        > 병렬(parallel)
        - 하나의 작업을 여러 쓰레드가 나눠서 처리하는 것

- 스케줄러
    - 프로세스는 OS프로세스 스케줄러의 영향을 받기 때문에 매번 실행마다 다른 결과를 얻을 수 있다
        - 자바는 쓰레드에 대해서 OS종속적이다

    - 쓰레드는 JVM의 쓰레드 스케줄러에 의해서 어떤쓰레드를 얼마나 실행할지 결정된다 
        - JVM의 종류에 따라 스케줄러의 구현방법이 다를 수 있어서 멀티 쓰레드 프로그램을 여러 OS에서 테스트 해볼 필요가 있다

    - 프로세스와 쓰레드의 불확실성을 염두에 두어야한다 

- 쓰레드의 우선순위
    - 쓰레드는 우선순위(priority)라는 속성(멤버변수)을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다
        - 시각적인 부분이나 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선 순위는 다른 잡업을 수행하는 쓰레드에 비해 높아야한다
    
    - ***setPriority(int)***
        - 1 ~ 10의 범위를 갖고 높을수록 우선순위가 높다
        - 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다
            - main쓰레드는 우선순위가 5이고 main메서드내에서 생성하는 쓰레드의 우선순위는 자동으로 5가 된다
        
        - 쓰레드가 실행되기 전에만 우선순위를 변경 할 수 있다
        - ***getPriority()***

    - 싱글, 멀티 코어
        - 싱글 코어에서 두개의 쓰레드에 다른 우선순위를 주면 우선순위가 높은 쓰레드가 더 많은 실행시간을 갖는다
        - 멀티 코어에서는 우선순위에 따른 차이가 전혀없다
            - 차라리 쓰레드의 우선순위보다 작업에 우선순위를 둬서 PriorityQueue에 저장해서 우선순위가 높은 작업이 먼저 처리되도록 하는 방법이 있다

# 쓰레드 그룹(thread group) 
- 관련된 쓰레드를 그룹으로 다루기 위한 것이다
    - 보안상의 이유로 도입된 개념으로 자신이 속한 그룹이나 하위그룹이 아니면 다른 그룹의 쓰레드를 변경할 수 없다
    - 그룹을 지정하지 않는 쓰레드는 기본적으로 자신을 생성한 쓰레드와 같은 그룹에 속한다
        - 참조변수 없이 쓰레드를 생성해서 바로 실행해도 쓰레드가 속한 그룹에서 참조하고 있기 때문에 제거 대상이 되지 않느다
            - ```new Thread().start();``` main그룹에 속한다

- main쓰레드 그룹, system쓰레드 그룹
    - JVM은 이 두 그룹을 생성해서 JVM운영에 필요한 쓰레드를 포함시킨다
    - main 그룹에는 main쓰레드가 속한다
    - system 그룹에는 가비지컬렉션을 수행하는 Finalizer쓰레드가 속한다


- 생성자
    - 지정된 이름의 새로운 쓰레드 그룹을 생성하거나 쓰레드 그룹에 포함된 하위 그룹을 생성할 수 있다
    - 쓰레드를 쓰레드 그룹에 포함시키려면 Thread생성자의 매개변수로 그룹을 지정해야 한다

- 메서드
    - active{Group}Count : 그룹에 포함된 활성상태 쓰레드, 그룹수 반환
    - checkAccess   : 실행중인 쓰레드의 그룹을 변경할 권한이 있는지 체크, 없으면 예외
    - destroy   : 그룹과 하위그룹까지 모두 삭제, 그룹이 비어있어야가능
    - enumerate : 그룹의 목록을 배열에 담고 개수를 반환
    - {get, set}MaxPriority : 그룹의 최대우선순위를 반환, 설정
    - get{Name, Parent} : 그룹이름, 상위그룹을 반환
    - parentOf  : 지정된 그룹의 상위그룹인지 확인
    - interrupt : 그룹에 속한 모든 쓰레드를 interrupt
    - {is, set}Daemon  : 데몬 쓰레드그룹 확인, 설정/해제
    - isDestroyed   : 삭제 됬는지 확인
    - list  : 그룹과 하위그룹에 대한 정보를 출력

- Thread클래스의 그룹관련 메서드
    - getThreadGroup    : 자신이 속한 쓰레드 그룹을 반환
    - uncaughtException : 그룹의 쓰레드가 처리되지 않은 예외에 의해 실행이 종료되었을 때, JVM에 의해 자동적으로 호출된다

# 데몬 쓰레드(daemon thread)

- 다른 일반 쓰레드 작업을 돕는 보조적인 역할을 수행한 쓰레드
    - 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제로 종료된다
    - 가비지 컬렉터, 자동저장, 화면자동갱신등이 있다

- 작성, 실행
    - 일반 쓰레드의 생성, 실행방법과 같고 start() 호출전에 setDaemon(true)을 호출하기만 하면 된다
    - 데몬 쓰레드는 무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정조건 만족되면 작업을 수행하고 다시 대기한다

# 쓰레드의 실행제어
- 쓰레드를 제어하기 위해서 동기화, 스케줄링으로 효율적인 프로그램을 만들어야한다

- Thread의 스케줄링 메서드
    - sleep : 지정된 시간동안 쓰레드를 정지후 다시 실행대기
        - try-catch문이 필수이다(메서드로 만들기도 한다)
        - static메서드로 항상 현재 실행 중인 쓰레드에 대해 작동한다
        - 가비지 컬렉터와 같은 데몬 쓰레드의 우선순위를 낮추기 보다는 sleep()을 이용해서 주기적으로 실행되게 하다가 필요할 때 interrupt()로 바로 호출하는 것이 좋다

    - join  : 지정된 시간동안 다른쓰레드를 실행, 끝나면 호출한 쓰레드로 다시 돌아와 실행을 계속한다
        - try-catch문 필수
        - 인스턴스 메서드이다, 실행할 쓰레드로 호출해야한다
        - 쓰레드들은 스케줄링에 의해서 실행 되기 때문에 각 쓰레드에 조건문이 값에 바로바로 반응하지 못한다
            - 그래서 값을 바꾸는 주체가 되는 쓰레드에서 조건이 충족되면 쓰레드를 실행하도록 join()을 조건문안에 작성해야 한다
            - 그렇지 않으면 값이 조건문의 경계를 한참 넘어서 나중에 쓰레드가 실행됬을 때 조건문을 만나게 된다

    
    - deprecated
        - suspend(일시정지 시킨다), stop(즉시 종료)
        - 이 메서드들은 교착상태를 일으키기 쉽게 작성되서 쓰면안된다
        - resume(일시정지를 실행대기로)는 suspend와 연결된 기능이기때문에 쓰지 않게 된다
    
    - suspend, stop을 대체할 방법
        ```java
        class T1 implements Runable {
            volatile boolean suspended   = false;
            volatile boolean stopped     = false;

            Thread th;

            T1(String name) {
                th = new Thread(this, name);
            }

            public void run() {
                while(!stopped){
                    if(!suspended){
                        // 작업내용
                    }
                }
            }  
            public void suspend() {suspended = true;}
            public void resume() {suspended = false;}
            public void stop() {stoped = true;}
            public void start() {th.start();}
        }
        ```
        - 직접 run()블럭안의 실행을 인스턴스변수를 이용해서 제어하면 같은 기능을 구현할 수 있다
        - 이 경우 쓰레드들이 실행제어를 공유하면 안되기 때문에 해당 인스턴스로 하나의 쓰레드만 생성해야한다, 위와 같이 쓰레드 인스턴스를 포함해서 객체지향적으로 구현할 수 있다

    - yield : 실행시간을 다른 쓰레드에게 양보하고 실행대기
        - interrupt와 같이 사용하면 프로그램의 응답성을 높이고 효율적인 실행이 가능하게 할 수 있다
            ```java
            while(!stopped){
                if(!suspend){
                    try {
                        Thread.sleep(1000);
                    } catch(InterruptException e) {}
                } else { Thread.yield(); }
            ```
            - '바쁜 대기상태(busy-waiting)'
                - suspended값이 true일때 yield()가 없으면  while문을 반복하면서 시간을 낭비하게 된다

            - yield를 호출해서 if문이 실행되지 않으면 시간을 양보하게 되서 더 효율적인 코드가 된다

    - interrupt : 일시정상태인 쓰레드를 깨워서 실행대기로 만든다, 
        - 쓰레드의 interrupted(인스턴스변수)값을 바꿔서 작업취소를 요청한다(강제하지 못한다)
        - 해당 쓰레드에서 InterruptedException 발생시킨다
            - 예외 발생후 interrupted값이 false로 초기화된다
            - catch문에서 interrupt 추가해서 true로 다시 바꿔줘야 한다

        - isInterrupted : 변수 값 반환
        - interrupted   : 변수 값 반환 후 false로 변다
        - 위 예제코드에 적용
            ```java
            public void suspend() {
                suspended = true;
                th.interrupt();
            }
            public void stop() {
                stopped = true;
                th.interrupt();
            }
            ```
            - 원래대로 라면 suspend 시켜도 조건문을 만나기 전까지 명령문을 모두 실행하게 된다
            - interrupt로 예외를 일으켜서 하던 작업을 중단하고 바로 조건문을 만나도록 해서 더 빠른 응답성을 갖도록 했다



- 쓰레드의 상태
    - NEW   : 생성되고 나서 호출되기 전
    - RUNNABLE  : 실행중, 실행 가능한 상태
    - BLOCKED   : 동기화 블럭에 의해 일시정지된 상태
    - WAITING   : 일시정지 상태
    - TIMED_WAITING : 지정된 시간동안 일시정지인 상태
    - TERMINATED    : 종료된 상태

    - 쓰레드 실행과정
        - start()를 호출하면 실행대기열(queue같은 구조)에 저장
        - 차례가 되면 실행상태가 된다
        - 실행시간이 다되거나 yield()를 만나면 실행대기상태가 된다
        - supend(), sleep(), wait(), join(), I/O block에 의해 일시정지 상태가 될 수 있다
            - I/O block은 입출력 작업에서의 지연상태이다
        
        - 지정된 일시정지 시간이 다되거나 notify(), resume(), interrupt()가 호출되면 다시 실행대기열에 저저아
        - 실행을 마치거나 stop()이 호출되면 소멸된다

# 쓰레드의 동기화
- 쓰레드의 동기화(임계영역(critical section), 잠금(lock))의 필요성
    - 스케줄러는 쓰레드가 작업을 완료할때까지 기다리지 않는다
        - 쓰레드들이 같은 데이터(공유데이터)을 가지고 동시에 수정하게 되면 의도하지 않은 결과를 얻게 된다 

    - 그래서 공유데이터를 사용하는 코드 영역을 임계영역으로 지정
    - 공유데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 임계영역의 코드를 수행할 수 있게 한다
    - 작업을 완료하면 lock을 반납하고 다른 쓰레드에서 lock을 획득해서 접근할 수 있다

    - 이렇게 다른 쓰레드의 간섭을 막는 것을 '쓰레드의 동기화(synchronization)'라고 한다

- 쓰레드 동기화 구현
    - synchronized 메서드, 블럭
    - jdk1.5 ~
        - java.util.concurrent.locks 
        - java.util.concurrent.atomic
    
- ***sysnchronized 키워드***
    - 가장 간단한 방법, 임계영역만 설정해 주면 된다
    - 임계영역 설정
        - ```public synchronized void A() {//임계영역}``` 
        - ```synchronized(객체의 참조변수){//임계영역}```
            - 참조변수는 락을 걸고자 하는 객체를 참조
        - 임계영역에 들어오면 lock을 얻고 나가면 반납한다
    
    - 임계영역은 멀티쓰레드 프로그램의 성능을 좌우한다, 영역을 최소화 하는 것이 효율적인 프로그램을 만드는 방법이다
    - 임계영역을 설정하더라도 공유데이터가 private가 아니면 외부에서 직접 접근 할 수 있기 때문에 동기화를 해도 값의 변경을 막을 길이 없다
	- 동기화를 하지 않은 공유데이터가 있으면 ConcurrentModificationException, IndexOutOfBoundsException등이 발생할 수 있다
    
	- ***wait(), notify()***
		- 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것도 중요하다
			- 다른 쓰레드들은 모두 객체의 락을 기다리느라 다른 작업들도 원활히 진행되지 않을 것

		- wait, notify는 특정객체에 대한 명령임으로 Object클래스에 정의되어 있다
			- 동기화 블록(synchronized)내에서만 사용 할 수 있다

		- wait() 	: 쓰레드가 락을 반납하고 객체마다 존재하는 waiting pool에서 기다리도록 한다
			- 시간을 지정하면 시간이 지난후 자동으로 notify()를 호출한다

		- notify()	: 명령을 처리할 수 있는 상황이 되면 호출해서 waiting pool에 알린다, 쓰레드는 다시 실행대기 상태가 된다
			- 특정쓰레드에게만 알릴수 없고 대기중인 임의의 쓰레드에게 전달된다
			- notifyAll() 로 전체에게 알릴수 있지만 여전히 특정 쓰레드에게 알릴수는 없다

		- 문제점
			- 기아(starvation)현상 : notify로 통지를 받지 못하고 오랫동안 기다리게 되는 현상
			- 경쟁(race condition)상태 	: 여러 쓰레드가 lock을 얻기 위해서 서로 경쟁하는 상태



		


# 람다식
- 메서드를 하나의 '식(expression)'으로 표현한다, 익명함수라고도 한다
    - ```() -> //식``` 
    - 메서드의 이름과 반환타입을 제거한다
    - 연산결과가 자동으로 반환 값이 된다
    - 식이 아닌 문장인 경우 { };블럭 안에 작성한다 
        - return문을 작성해야 한다

    - 매개변수의 타입은 보통 추론가능하기때문에 생략할 수 있다
        - 지네릭타입이나 메서드선언부로 추론가능하다
        - 매개변수중 하나만 생략 할 수는 없다
    
    - 매개변수가 하나이면 ()를 생략할 수 있다
    
    - 람다식은 메서드의 매개변수, 반환값 모두 될 수 있다
        - 그러기 위해 함수형 인터페이스를 매개변수, 반환값의 타입으로 지정해야한다

- 함수형 인터페이스(Functional Interface)
    - 람다식은 익명클래스의 객체인 익명 객체와 같다
        - 익명클래스의 역할을 하는것이 함수형 인터페이스이다

    - 람다식의 메서드를 호출하기 위해서는 동등한 메서드가 정의된 참조변수가 필요하다
        - 람다식과 동일한 추상메서드가 정의된 함수형 인터페이스타입으로 참조할 수 있다
        - 매개변수의 타입과 개수, 반환값이 일치해야 한다

    - 함수형 인터페이스
        - 람다식과 1대1로 연결하기위해 오직 하나의 추상 메서드만 정의해야 한다
        - static메서드와 default메서드의 개수는 제약이 없다
    
    - 매개변수와 반환타입을 함수형 인터페이스로 하면 해당 인터페이스를 구현한 람다식을 참조하는 참조변수나 람다식 자체를 지정해야한다
        - 변수처럼 메서드, 사실상 객체를 주고 받는 것이다

    - 람다식은 익명객체이고 익명객체는 타입이 없다, 그래서 함수형 인터페이스로 형변환을 해줘야 하는데 생략가능하다
        - 컴파일러가 형변환을 대신 해준다, 람다식을 오직 함수형 인터페이스로만 형변환이 가능하다
            - 함수형 인터페이스에서 Object로의 형변환은 가능하다

        - 타입(클래스명)은 컴파일러가 임의로 정한다
            - 일반적인 익명객체는 '외부클래스이름$번호', 람다식의 타입은 '외부클래스이름$$Lambda$번호'와 같은 형식으로 되어있다

    - 외부 변수 참조
        - 람다식은 익명객체(익명클래스의 인스턴스)이다, 그래서 외부의 변수에 접근하는 규칙은 익명클래스와 동일하다
        - 람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주되서 어느 곳에서도 변경할 수 없다
        - 외부 지역변수와 같은 이름의 람다식 매개변수는 허용되지 않는다
    
- java.util.funtion 패키지
    - 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 정의해 놓았다
        - 가능하면 이 패키지를 사용하는 것이 재상용성, 유지보수 측면에서 좋다
    
    - 정의된 함수형 인터페이스
        - java.lang.Runnable{void run()}
            - 매개변수 x, 반환값 x
        
        - Supplier```<T>```{T get()}
            - 매개변수 x, 반환값 o
        
        - Consumer```<T>```{void accept(T t)}
            - 매개변수 o, 반환값 x
        
        - Function```<T,R>```{R apply(T t)}
            - 매개변수 o, 반환값 o
        
        - Predicate```<T>```{boolean test(T t)}
            - 매개변수 o, 반환값 o(bool)
            - 조건식을 람다식으로 표현한다
        
        - 매개변수가 두 개인 경우
            - BiConsumer```<T,U>```{void accept(T t, U u)}
                - 매개변수가 2개인 경우 기존의 인터페이스 앞에 'Bi' 접두사가 붙는다

            - 두 개 이상의 매개변수는 함수형 인터페이스를 직접 만들어서 사용해야 한다
        
        - UnaryOperator, BinaryOperator
            - UnaryOperator```<T>```{T apply(T t)}
                - 매개변수타입과 반환타입의 타입이 일치한다
                - Bi는 2개 

        - 기본형을 사용하는 함수형 인터페이스
            - 오토방식, 언박싱을 최소화해서 더 효율적이다
            - 'A'To'B'Function
                - A(입력), B(출력)
                - DoubleToIntFunction
            
            - To'B'Function```<T>```
                - 지네릭(입력), B(출력)
            
            - 'A'Funcrion```<R>```
                - A(입력), 지네릭(출력)
            
            - Obj'A'Function
                - 지네릭, A (입력), 출력없음

    - 함수형 인터페이스의 합성
        - java.util.function에 정의된 디폴트 메서드, static메서드는 주 기능인 추상메서드를 합성, 결합할 수 있게 해준다

        - 메서드
            - default ```<V>``` Function```<T,V>``` andThen (Function```<? super R, ? extends V>``` after)
            - default ```<V>``` Function```<V,T>``` andThen (Function```<? super V, ? extends T>``` after)
            - static```<V>``` Function```<T,T>```identity
                - 항등함수로 람다식 'x -> x'와 같다

            - 람다식 f, g가 있을 때
                - f.andThen(g)는 함수 f를 먼저 적용하고 반환값을 g에게 전달해서 값을 얻는 것이다(compose는 반대)
                - 서로 결합된 방향의 반환타입, 매개변수타입이 같아야 에러없이 값을 대입 할 수 있다
                    ```java
                    Function<String, Integer> f = s -> Integer.parseInt(s, 16);
                    Function<Integer, String> g = i -> Integer.toBinaryString(i);
                    Function<String, String> h = f.andThen(g);
                    ```
                    - 합성된 람다식의 참조변수에서는 결합부분이 아닌 부분의 타입을 정의한다
            

        
        - Predicate 메서드
            - default Predicate```<T>``` and(Predicate```<? super R>``` other)
            - default Predicate```<T>``` or(Predicate```<? super R>``` other)
            - default Predicate```<T>``` negate 
            - static ```<T>``` Predicate```<T>``` isEqual(Object targetRef) 

            - 조건식의 결합
                ```java
                Predicate<Integer> p = i -> i < 100;
                Predicate<Integer> notP = p.negate();            
                ```
                - and, or, negate로 조건식인 람다식의 값을 바꿀 수 있다

    - Colletion에 추가된 함수형 인터페이스를 사용하는 디폴트 메서드 
        - Collection
            - boolean removeIf(Predicate```<E>``` filter)  
                - 조건에 맞는 요소를 삭제
            
        - List
            - void replaceAll(UnaryOperator```<E>```)
                - 모든 요소를 변환하여 대체
            
        - Iterable
            - void forEach(Consumer```<T>``` action)
                - 모든 요소에 action을 수행
            
        - Map
            - V compute(K key, BiFuncion```<K, V, V>``` f)
                - 지정된 키의 값에 작업 f를 수행
            
            - V computeIfAbsent(K key, Function```<K, V, V>``` f)
                - 지정된 키가 없으면 작업 f를 수행
                - computePresent(지정된 키가 있으면 f 수행)
                
            - V merge(K key, V value, BiFunction```<V, V, V>``` f)
                - 모든 요소에 병합작업 f를 수행
            
            - void forEach(BiConsumer```<K, V>``` action)
            - void replaceAll(BiFunction```<K, V, V>``` f)

- 메서드 참조
    - 람다식이 하나의 메서드만 호출하는 경우 더 간결하게 표현할 수 있는 방법이다
        ```java
        변수 = s -> Integer.parseInt(s); 
        변수 = Integer::parseInt;
        ```
        - 컴파일러는 생략된 부분을 메서드의 선언부, 지네릭 타입을 통해서 쉽게 알아 낼 수 있다
    
    - 메서드 참조 종류
        - static 메서드 : 클래스명::메소드명
        - 인스턴스 메서드 : 클래스명::메소드명
        - 특정객체의 인스턴스 메서드 : 객체명::메소드명
            - 생성된 객체의 메서드를 호출한다
        
        - 생성자 메서드 : 클래스명::new
        - 배열 생성 : 타입[]::new

# 스트림(stream)
- 컬렉션의 클래스마다 같은 기능을 따로 정의해놓고 있는데 이런 문제점을 해결하기 위해서 만들어 졌다
    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html
    - 데이터 소스를 추상화하고 자주 사용되는 메서드들을 정의했다
        - 여러 데이터 소스를 하나의 스트림 형태로 추상화 할 수 있어서 재사용성이 높아진다


- 생성자
    - Stream```<String>``` stream1 = new List().stream();
    - Stream```<String>``` stream1 = Arrays.stream(arr);
    - 컬렉션 클래스에서 스트림객체를 생성할 수 있다
    - 사용 예
        - stream1.sorted().forEach(System.out::println);
        - stream1 에는 컬렉션의 데이터 소스들을 대입할 수 있다

- 스트림의 특징
    - 스트림은 데이터 소스원본을 변경하지 않는다
        - 데이터를 읽기만 하고 변경하지 않는다, 결과를 반환할 수도 있다
    - 스트림은 일회용이다(Iterator처럼)
    - 스트림은 작업을 내부 반복으로 처리한다

- 스트림의 연산
    - 중간 연산(반환값 Stream)
        - Stream을 반환하기 때문에 반환값에 다시 메서드를 호출할 수 있다
        - 메서드
            - distinct      : 중복 제거
            - filter        : 조건(Predicate)에 안맞는 요소 제외
            - limit         : 스트림의 일부를 잘라낸다
            - skip          : 일부를 건너뛴다
            - peek          : 요소에 작업(Consumer) 수행
            - sorted        : 정렬
            - ***map, flatMap***  : 요소를 변환한다
                - mapTo{Double, Int, Long}(To{Double,Int, Long}Function```<T>``` mapper)
                - 함수형 인터페이스를 이용한 변환

    - 최종 연산(반환값 특정 값)
        - 스트림의 요소를 소모해서 한번만 연산을 수행하기 한다, 마지막에 호출되서 결과 값을 얻을 수 있다
        - 메서드
            - forEach       : 각 요소에 작업(Consumer)수행
            - count         : 요소의 개수 반환
            - find{Any, First}  : 아무거나,첫번째 요소 반환
            - {all, any, none}Match : 조건(Predicate)을 모두, 하나, !모두 만족하는지 확인
            - ***reduce***        : 요소를 하나씩 줄여서 계산한다
            - ***collect***       : 요소를 수집한다
            - toArray
            - max, min





        


        
    


# 연산자
- 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다

### 연산자의 우선순위와 결합규칙
- 우선순위
    - 산술연산자가 비교연산자보다 먼저 수행된다
    - 비교연산자가 논리연산자보다 먼저 수행된다
    - 쉬프트 연산자는 덧셈 연산자보다 우선순위가 낫다
    - 비트 연산자는 비교 연산자보다 우선순위가 낮아서 비교연산 후에 비트 연산이 수행된다
    - '&','&&'가 '|','||'보다 우선순위가 높다

- 산술>비교>논리>대입 의 우선순위를 갖는다
- 단항>이항>삼항 의 우선순위를 갖는다
    - 단항 연산자와 대입연산자만 오른쪽에서 왼쪽으로 연산을 진행한다

### 산술 변환
- 산술변환 규칙
    - 두 연산자의 타입을 같게 일치 시킨다(보다 큰타입)
    - 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다
        - int/int의 결과값은 int이다
    

# 단항 연산자
### 증감 연산자
- 오직 대입연산자와 증감연산자만 피연산자의 값을 변경한다
- 식에 두번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야한다

### 부호 연산자
- 부호연산자'-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다
- 부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다

# 산술 연산자
- x/0 
    - 3/0 -> ArithmeticException 발생
    - 3/0.0 -> Infinity 출력

- 이미 오버플로우가 발생한 값을 더 넓은 타입의 변수에 저장해도 소용없다
    ``` java
    long a = 1_000_000 * 1_000_000;
    // 연산결과가 먼저 정의된 후에 대입되기 때문에 int형에서 오버플로우된 값이 저장된다
    long b = 1_000_000 * 1_000_000L;
    // L 을 붙여서 long타입을 연산에 넣었기 때문에 오버플로우가 발생하지 않는다
    ```

- 문자형의 산술변환
    ``` java
    char x = 'a';
    
    int y1 = x+1; // 연산하면 int 값으로 변환되서 반환한다
    char y2 = x++; // 형변환 없이 저장된 값을 1 증가시킨다
    ``` 
    - 'a'+1 리터럴 간의 연산 이기 떄문에 컴파일 도중 컴파일러가 계산해서 그 결과로 대체한다
        - 'a'+1 -> 'b'로 컴파일러가 미리계산한다
        - 변수가 들어간 수식은 미리 계산할수 없기 때문에 형변환을 해줘야 한다

- 실수형 
    - Math.round()로 반올림을 할 수 있다

# 비교연산자
- float == double
    - 10.0 == 10.0f -> true
    - 0.1 == 0.1f -> false
    - 0.1f는 변환하는 과정에서 오차가 발생해서 기본형인 double타입의 값과 다르다
    - double과 float을 비교하려면 double타입을 float으로 형변환 하고 비교해야 한다

- 문자열 비교
    - 비교연산자 '==' 대신 equals()라는 메서드를 사용한다
    - equalsIgnoreCase()로 대소문자 구별없이 비교할 수 있다


# 논리 연산자
- 10 < x < 20 과 같은 표현은 허용되지 않는다
    - 10 < x && x < 20 로 표현할 수 있다

- 효율적인 연산
    - '||' 연산의 경우 '참'일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더빠른 연산결과를 얻고 더 효율적으로 처리된다

- 논리부정 연산자 !
    - 어떤 값에 논리 부정 연산자'!'를 반복 적용하면 참과 거짓이 차례대로 반복된다
        - 토글 버튼을 논리적으로 구현할 수 있다.
    
    - ~~가 아니다 라는 논리는 '!'를 사용하는 쪽이 가독성이 높다

    - !!true 
        - 중첩되있는 경우 피연산자와 가까운 연산자가 먼저 연산된다

# 비트 연산자
- '|' : or, 특정 비트의 값을 변경할 때 사용한다
- '&' : and, 특정 비트의 값을 뽑아낼 때 사용한다
    - 1010 1011 1100 1101 & 0000 0000 0000 1111
    - -> 0000 0000 0000 000 1101
    - 원하는 위치의 비트만 1로 채우고 &연산을 하면 원하는 비트만 얻을 수 있다

- '^' : xor, 간단한 암호화에 사용 할 수 있다
- '~' : '1의보수' 연산자
    - toBinaryString(~x+1)으로 x값의 음수를 구할 수 도 있다

- '<<','>>' : 쉬프트연산자, 특정 방향으로 비트를 옮긴다
    - '>>'의 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채운다
    - x << n 은 x * (2**n)과 같다
    - x >> n 은 x / (2**n)과 같다
    - n이 비트의 크기보다 크면 비트단위로 나눈 나머지 만큼 이동한다
    - 쉬프트 연산자로 /,*을 훨씬 빠르게 수행할 수 있다
        - 8/4 는 8>>2 와 같다

    
- toBinaryString() : 값을 2진수로 출력한다
- 비트연산에도 피연산자의 타입을 일치시키는 산술변환이 일어난다
    - int 보다 작으면 int로 자동형변환

# 조건 연산자 ?:
- x = 조건식 ? 식1 : 식2  (삼항연산자 이다)
- 중첩해서 사용할 수 있지만 가독성에 유의해야 한다
- 식1과 식2의 타입이 다르면 산술변환이 발생한다

# 대입 연산자 op=
- 복합대입 연산자
    - %=, <<=, >>==, &=, ^=, |= 등




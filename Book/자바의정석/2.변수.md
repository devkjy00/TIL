# 변수
### 선언, 초기화
- 선언
    - int age; 
    - 변수타입 변수이름;

- 초기화
    - 쓰레기 값이 남아있을 수 있기 때문에 초기화해야한다
    - ','콤마를 구분자로 여러 변수를 한 줄에 선언하기도 한다
    - 지역변수는 사용전 반드시 초기화를 해야하지만 클래스변수, 인스턴스변수는 초기화를 생략할 수 있다

### 변수 명명규칙
- 클래스 이름의 첫글자는 항상 대문자로한다
    - 변수와 메서드의 첫글자는 항상 소문자

- 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로한다
- 상수의 이름은 모두 대문자로 하고 _로 단어를 구분한다


# 변수의 타입
- 기본 자료형은 값이 저장될 공간의 크기와 저장형식을 정의한 것

- 기본형과 참조형
    - 기본형
        - 실제 값을 저장
        - 자료형(data type)
    - 참조형
        - 기본형으로 null 값을 갖는다
        - 객체의 주소를 저장한다
        - 타입(type)0000000000000000
        - 클래스의 이름이 참조 변수의 타입이 된다
        - 선언(인스턴스 생성)
            - Data today = new Date();
            - 클래스이름 변수이름 = new 클래스();
        - 모든 참조형 변수는 4byte이다
            - JVM이 64bit라면 참조형 변수의 크기는 8byte이다

    
### 기본형
- 8개의 자료형이 있다
- char은 유니코드로 값(정수)을 저장하기 때문에 정수,실수와 연산이 가능하다
    - boolean을 제외한 자료형들은 서로 연산이 가능

- int는 CPU가 가장 효율적으로 처리할 수 있는 타입
    - byte, short로 메모리를 절약할 수 있다

- 기본자료형의 종류, 크기
    - boolean: 1byte
    - char: 2byte
    - byte: 1byte, short: 2byte, int: 4byte, long: 8byte
    - float: 4byte, double: 8byte

- 정수형의 경우 -2**(n-1) ~ 2**(n-1)-1의 범위를 갖는다(n=bit)


### 상수와 리터럴
- 상수는 선언과 초기화를 동시에 해야 한다
    - final int x = 10;
    - final 키워드를 사용

- 리터럴(literal)
    - 값 그자체

- 리터럴의 타입과 접미사
    - int : 없음
    - double : 없음(d는 생략가능)
    - long : l,L
    - float : f,F
    - long,float만 접미사를 신경쓰면 된다

- 타입이 달라도 저장 범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다
    - int i = 'A' 
    - 할당할 값이나 타입이 선언된 타입의 범위를 넘어서면 컴파일 에러가 발생

- 진법의 접미사
    - 2진수 : 0b, 0B
    - 8진수 : 0
    - 16진수 : 0x, 0X(대문자로 반환)

- 문자 리터럴, 문자열 리터럴
    - ''는 문자, ""는 문자열
    - 문자열은 빈값("")을 가질수 있지만 문자는 빈값('')을 가질수 없다
    - 문자열은 원래 String 클래스이다
    - 덧셈 연산자의 피연산자중 한쪽이 String이면 나머지쪽도 String으로 변환한다 (기본형,참조형 구분없이)

- printf() 형식화된 출력
    - 지시자를 통해 값을 변환하여 출력한다, 줄바꿈을 하지 않는다
        - 줄바꿈은 %n
    - %b: 불리언
    - %d: 10진 정수
    - %o: 8진 정수
    - %x, %X: 16진 정수
    - %f : 부동 소수점
    - %e, %E: 지수 표현식
    - %g: 소수르 간략하게 표현
    - %c: 문자
    - %s: 문자열
    - %앞에 5,-5,05을 붙이면 출력공간을 확보한다
    - %전체자리.소수점아래자리f 로 소수점출력을 설정할 수 있다
    - 8,16진수의 %앞에#을 붙이면 0, 0x가 같이 출력된다

### 화면에서 입력받기
``` java
{
import java.util.*; // Scanner 클래스사용을 위해

Scanner scanner = new Scanner(System.in); // 객체 생성

String inputh = scanner.nextLine(); // 입력받은 내용을 저장
int num = Integer.parseInt(input);  // 타입 변환
}
```
- nextInt(), nextFloat()으로 입력받은 값을 바로 변환할 수 도 있다

# 진법
### 10진법,2진법
- 전기회로는 전압이 불안전해서 전압을 10단계로 나누어 처리하기 힘들다
- 2진법은 전기회로에 적합하다
- n비트로 2**n의 값을 표현할 수 있다

### 8진법, 16진법
- 2진법은 자리수가 길기 때문에 사용한다
- 8진수는 2진수를 3자리씩, 16진수는 4자리씩 묶어서 한자리로 표현한다

### 정수의 진법 변한
- 10진수를 n진수로 변환
    - 10진수를 반복해서 나누고 나머지를 오른쪽으로 쌓아가면 된다

- n진수를 10진수로 변환
    - 각 자리의 수에 해당 단위의 값을 곱해서 모두 더하면 된다

### 실수의 진법 변환
- 10진 소수점수를 2진 소수점수로 변환
    - 10진 소수에 2를 곱한다
    - 결과에서 소수만 가져와서 다시 2를 곱한다
    - 소수가 0이 될때 까지 반복
    - 정수를 위에서 아래로 순서대로 적고 0. 을 붙이면 된다

- 2진 소수점수를 10진 소수점수로 변환
    - 각 자리수에 해당 단위를 곱한고 더한다
    - 2**-1, 2**-2....

### 음수의 2진 표현 - 2의 보수법
- '2의 보수관계' : 더해서 2가 되는 두수의 관계
    - 2의 보수법은 절대값이 같고 부호가 다른 두 10진수를 표현하는 것

- 음수를 2진수로 표현하기
    - 절대값을 2진수로 변환후 2의 보수를 구하면 된다
    - 2의보수 = 1의 보수 + 1

# 기본형(privitive type)
### 논리형 - boolean
- 1 bit만으로 충분하지만 Java에서 최소단위는 byte이기 때문에 1byte로 표현한다
- 다른 자료형이나 값과 연산할 수 없다
- true, false로만 표현한다

### 문자형 - char
- 문자의 유니코드(정수)가 저장된다
- 문자,유티코드(정수)는 같은 결과를 얻는다
    ```java
    char ch = 'A';  // 문자 'A'를 char타입의 변수에 저장
    char ch = 65;   // 문자의 코드를 직접 변수에 저장
    // ch + 5 -> 70 으로 int값이 된다
    ```
    - 문자를 int형으로 변환하면 유니코드를 알수 있다

- 특수 문자 다루기
    - \t : tab, \b : backspace, \f : form feed, \n : new line...

- char 타입의 표현형식
    - char타입의 크기는 2byte
        - 문자 'A'는 2진수로 '0000000001000001'
    
    - 문자가 아닌 유니코드(정수)가 저장되고 표현형식 역시 정수형과 동일
        - 정수형과 다르게 char은 부호없는 정수 범위('0~65535')를 갖는다

    - 정수형에 65를 저장하거나 문자형에 'A'를 저장하거나 둘다 같은 값인 65를 갖는다 
    - println()은 변수 타입이 정수형이면 10진수로 해석 문자형이면 해당하는 유니코드 문자를 출력한다

- 인코딩과 디코딩(encoding & decoding)
    - 문자 인코딩 : 문자를 코드로 변환
        - encode는 ~를 코드화, 암호화하다 라는 뜻
    - 문자 디코딩 : 코드를 문자로 변환
        - 인코딩 방법을 알아야 올바은 디코딩이 가능하다
        - 웹페이지의 인코딩정보를 모르고 잘못 디코딩하면 웹의 문자가 다 깨져서 나오게 된다

- 아스키(ASCII)
    - 128개(2**7)의 문자집합
    - '0~9', 'A~Z', 'a~z'가 연속적으로 배치되어있다

- 확장 아스키(Extended ASCII)와 한글
    - 2**8개의 문자집합
    - 여러 확장 아스키중 표준이 되는 'ISO 8859-1'
        - 서유럽에서 일반적으로 사용하는 문자 포함
    
    - 두개의 문자코드로 한글을 표현하는 '완성형'으로 한글을 표현
        - 확장 완성형(CP-949): 한글 윈도우에서 사용하는 문자 인코딩

- 코드페이지(code page, cp)
    - 지역, 국가에 따라 여러버젼의 확장 아스키 필요
    - 각 코드 페이지에 'CP xxx'와 같은 형식으로 이름을 붙였다

- 유니코드(Unicode)
    - 2byte(16bit)에서 21bit로 확장되었다
        - 새로 추가된 보충 문자들은 int타입으로 표현한다
    
    - 유니코드 인코딩에는 UTF-8, UTF-16, UTF-32등 여러가지종류가 있다
        - -16은 모든 문자를 2byte로 고정하고 -8은 1~4byte의 가변크기를 표현한다
        - Java에서는 UTF-16을 사용한다
        - 처음 128문자가 아스키와 동일하다, 그대로 포함하고 있다

    - UTF-16은 편하지만 크기가 크다는 단점을 가지고 있다
    - UTF-8은 크기가 가변적이어서 다루기 어렵지만 크기가 작아서 속도가 중요한 웹문서에서 많이 사용된다

### 정수형 - byte, short, int, long
- byte:1 < short:2 < int:4 < long:8
- 정수형의 표현형식과 범위
    - 부호비트(1bit), 타입의 크기(byte-1bit)로 표현
    - 8비트로 표현할 수 있는 정수의 개수 : 2**8개
    - 8비트로 표현할 수 있는 부호있는 정수의 범위 : -2 ** 7 ~ 2 ** (7-1), (-128 ~ 127)

- 정수형의 선택기준
    - byte, short는 메모리를 조금 절약할수 있지만 잘못된 결과를 얻기 쉽다
    - ***JVM의 피연산자 스택이 피연산자를 4byte단위로 저장한다***
        - byte, short는 연산시 4byte로 변환된다
        - byte의 범위는 -128 ~ 127
        - int를 사용하는 것이 더 효율적이다
    
- 정수형의 오버플로우
    - 값의 범위를 넘어서는 것
        - 에러가 발생하지는 않지만 예상못한 결과를 얻게 된다
    
    - MSB에서 반올림이 발생하면 값은 버려진다
        - 최대값 +1 -> 최소값

    - '0000'인 2진수에서 1을 빼면 가장 위에 저장되지않은 1이 있다고 가정하고 '1111'된다
        - 최소값 -1 -> 최대값

- 부호있는 정수의 오버플로우
    - 부호있는 정수는 부호비트가 0에서 1이 될때 오버플로우가 발생한다
        - 값이 이어지지 않고 확 바뀐다
        - 0111 : 7(최대값), 1000 : -8(최소값)
        - 계속 값을 더하면 '-8 ~ 7'이 무한 반복된다


### 실수형 - float, double
- 실수형의 범위와 정밀도
    - 부호비트, 지수비트, 가수비트로 표현된다
    - float의 정밀도 : 7자리, double의 정밀도 : 15자리
    - float타입의 표현범위중 0에 가까운 (-1.4 * 10 ** -45 ~ 1.4 * 10 ** -45, 0에 가까운 소수범위가 긴 수)는 표현하지 못하고 '0'이 된다
    - 실수형에서 오버플로우가 발생하면 변수의 값은 무한대가 된다
    - 실수형에서 언더플로우(최소값보다 작은값)는  0이 된다

- 실수형의 저장형식
    - 부동소수점수의 형태로 저장된다
        - 부호, 지수, 가수로 이루어짐( +- M * 2**E)
    
- 부동소수점의 오차
    - 10진수로는 유한소수여도 2진수로 변환하면 무한소수가 되는 경우가 있다
    - 정규화
        - 2진수의 실수를 저장할 때 소수점위에 한자리만 남도록 값을 만든다
        - '1.'을 제외한 2진수가 가수로 저장되고 범위를 넘으면 잘려나간다
        - 지수는 기저법으로 저장된다
            - 기저법은 '2의 보수법'처럼 부호있는 정수를 저장하는 방법
            - 저장할 때 특정값을 더했다가 읽어올 때는 다시 뺀다
        

# 형변환
- 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
    - (타입)피연산자 : ()는 캐스트 연산자, 형변화 연산자라고 한다
    - 형변환된 피연산자는 변화가 없고 연산된 값이 반환된다

### 정수형 간의 형변환
- 큰 타입에서 작은 타입으로 변환하면 값 손실이 발생할 수 있다
- 음수를 작은 타입에서 큰 타입으로 변환할 때는 부호를 유지하기 위해 빈공간을 1로 채운다

### 실수형 간의 형변화
- 작은 타입에서 큰타입으로 변환(float -> double)
    - 지수는 float의 기저인 127을 빼고 doulble의 기저인 1023을 더해서 변환한다
    - 가수는 값을 먼저 채운후에 남은 뒤의 공백을 0으로 채운다

- (double -> float)
    - 지수는 위의 경우와 반대로 연산한다
    - 가수에서 잘려나간 부분은 버려진다
        - 반올림이 발생할 수 있다
        - float타입의 범위를 넘는 값을 float으로 형변환 하면 무한대나 0이 나온다

### 정수형과 실수형 간의 형변환
- 정수형을 실수형으로 변환
    - 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장된다
    - 정밀도 제한으로 오차가 발생할 수 있다
        - int의 최대자리는 10자리, float은 7자리의 정밀도를 제공

- 실수형을 정수형으로 변환
    - 소수점이하 값은 버려진다
    - 반올림이 발생하지 않는다

### 자동 형변환
- 대입이나 연산 할 때 컴파일러가 생략된 형변환을 자동적으로 추가한다
- 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생한다
    - 명시적으로 형변환을 했을 경우 의도적인 것으로 간주하고 컴파일러가 에러를 발생시키지 않는다

- 계산식 연산과정에서 형변환이 자동적으로 이루어진다
    - 피연산자의 타입중 더 넓은 타입으로 형변환 된다

- 자동 형변환 규칙
    - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
    - 자동형변환의 방향: byte -> short, char -> int -> long -> float -> double 
        - 실수형이 정수형보다 더 큰 표현범위를 갖기 때문에 정수를 자동 형변환한다
        - char과 short는 2byte로 같지만 서로 범위가 달라서 자동형변환이 수행될수 없다


    
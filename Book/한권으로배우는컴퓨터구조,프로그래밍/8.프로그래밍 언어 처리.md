## 어셈블리 언어
- 어셈블리 언어는 명령어의 비트 조합을 외우지 않아도 니모닉을 통해 명령어를 사용하 수 있게 한다
    - 명령어의 주소에 레이블을 붙이고 주석을 달아서 쉽게 이해하도록 해준다

- 어셈블러(assembler) : 어셈블리 언어를 읽어서 기계어 코드를 생성해주는 프로그램
    
## 고수준 언어
- 어셈블리 언어보다 더 높은 추상화 단계로 컴파일러가 소스코드를 기계어, 목적코드로 번역한다
    
- 포트란, 베이직등의 초창기 언어는 비구조적 언어로 구조를 강요하지 않았고 이로 인해 스파게티 코드가 만들어져서 이를 개선하기 위해서 구조적 프로그래밍 개념이 생겼다

## 어휘 분석
- 어휘 분석은 코드를 기호로부터 단어와 같은 성격의 토큰으로 변환하는 과정이다
    - 이름, 숫자, 연산자 등 다양한 토큰들을 구분해야 한다

- **베커스-나우르 표기법(BNF) : 언어를 정의하는 형식적인 방법**
- **상태기계(state machine) : 상태로 이뤄진 집합과 다른 상태로 전이되는 원인의 목록으로 이뤄져있다**
- **정규식 : 언어를 지정하기위한 언어**

## 파스 트리
- **파스트리는 언어 문법으로 부터 만들어낸 유향 비순환 그래프(DAG)데이터 구조이다**
    - DAG : 무한한 노드와 간선으로 구성되어있고 순환이 없다
- 인터프리터(interpret) : 자신만의 기계어를 제공하는 가상머신을 통해서 소스 코드를 실행한다
    - 인터프리터 언어는 가상머신으로 실행하거나 중간어로 컴파일 하기도 한다

- 컴파일은 영문을 번역한 책, 인터프리터는 영문을 바로 번역하는 번역가

- ### 인터프리터
    - 입력 -> 어휘분석 -> 문법파싱 -> 파스 트리(중간언어) -> 기계 n(백엔드)
- ### 컴파일러
    - 입력 -> 어휘분석 -> 문법파싱 -> 파스 트리(중간언어) -> 기계 n(코드 생성기) -> 기계 n(어셈블리어) -> 기계 n(어셈블러) -> 기계 n(기계어)

## 최적화
- 대부분의 언어 도구에는 optimizer라는 추가 단계가 파스트리와 코드 생성기 사이에 들어간다
    - 파스트리를 분석하고 더 효율적인 코드를 생성하도록 변환한다
    - 모든 피연산자가 상수라면 컴파일 시점에 식을 미리 계산해서 실행 시점에 수행할 필요가 없게 할 수 있다
        - **루프 불변요소(loop invariant) : 반복해도 값이 바뀌지 않으면 루프 밖으로 위치를 옮긴다**
        - **강도 절감(strength reduction): 비용이 많이 드는 연산을 비용이 더 적은 연산으로 대신한다(2*2 -> 2+2)**

- 하드웨어를 조작하는 코드를 최적화하면 예기치 못한 문제가 발생할 수도 있다
    - 전통적으로 소프트웨어를 일반적인 파일과 하드웨어에 따라 달라지는 파일로 나누고 일반적인 파일에 대해서만 최적화를 적용한다

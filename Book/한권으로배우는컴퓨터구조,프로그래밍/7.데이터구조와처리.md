메모리 시스템의 특성을 염두에 두고 데이터를 조직적으로 잘 정리하면 더 나은 성능을 얻을 수 있다

- 참조 지역성(locality of reference)
    - 필요한 데이터를 메모리에서 서로 근처에 유지하라

## 기본 데이터 타입
- 타입 데이터는 크기와 해석이라는 두가지 측면이 존재
    - 포인터는 부호가 없는 정수, 메모리로 주소로 해석한다

## 배열
- 상대주소지정
    - 기저주소로 부터 얼마나 멀리 떨어져있는지를 나타내는 오프셋으로 각 원소의 주소를 지정한다
    - 기저주소 : 0번째 원소의 주소
- 배열의 메모리 주소 공간상에서는 열 인덱스가 바뀌는 것보다 행 인덱스가 바뀔 때 더 많은 이동이 일어난다
- 배열의 범위를 넘어가면 의도와 다른 결과가 생기기 때문에 배열의 길이가 미리 정의되서 프로그래밍 언어가 검사를 해준다

## 비트맵
- 비트의 배열, 각 원소는 0 아니면 1 이다
    - boolean보다 작고 같은 역할
- 비트 설정, 지우기, 1 또는 0인지 검사하는 연산을 비트연산자를 통해서 할 수 있다

## 문자열
- 여러문자로 이뤄진 시퀀스
- 문자열은 길이가 바뀔 수 있기 때문에 배열과 같이 길이를 저장하지 못한다
    - 문자열 안에 길이를 저장할 수 있다(첫 번째 바이트에 저장, 255자로 제한)
    - C언어에서는 문자열 데이터 타입대신 1차원 바이트 배열을 사용한다(배열의 끝에 \n(null)을 추가)
        - 저장이 쉽고 각 문자를 다루기 쉽다
        - 문자열 길이를 알아내려면 문자 수를 세어야 하고 중간에 null문자를 넣을 수 없다

## 복합 데이터 타입
- 구조체, suite : 원하는 대로 데이터 타입을 저장
    - 각 자료형이 다르기 때문에 데이터의 크기도 다르다, 메모리 정렬을 위해서 패딩을 추가한다
    - 패딩(padding) : 메모리정렬을 맞추기 위해서 데이터가 최대한 하나의 긴워드 주소 안에 들어가도록 빈 공간을 중간에 추가해서 접근 횟수를 줄인다

- 유니언(union) : 여러 데이터를 하나의 데이터로 해석하고 활용한다(8byte 4개 -> 32byte)
    - 메모리 공간이나 내용을 여러가지 관점으로 바라볼 수 있다
    - 구조체와 다르게 모든 멤버들은 메모리를 공유할 수 있다

## 단일 연결 리스트
- 내용을 변경하는데 많은 비용이 드는 배열의 단점을 보완한다
    - 데이터필드, 링크필드로 각 원소를 연결

## 동적 메모리 할당
- MMU는 프로그램에게 필요한 메모리 용량을 판단해서 OS에 요청한다
    - 별도의 메모리 관리 유닛(MMU)이 없다면 힙 영역이 프로그램이 사용할 수 있는 모든 데이터 메모리이다

- 배열같은 정적인 변수에 할당된 주소는 바뀌지 않지만 리스트같이 동적인 변수는 변경될 수 있고 이런 동적 대상은 힙에서 다룬다
    - 프로그램은 힙을 관리할 수 있어야 한다(C의 malloc, free)
    - malloc는 미리 가지고 있던 가용 메모리 블럭을 요청받은 크기만큼만 포인터로 반환하고 free로 메모리를 해제하면 다시 가지고 있던 연결리스트에 추가된다
    - 부작용이나 버그를 발생시키기 쉬운 방법이다

## 더 효율적인 메모리 할당
- 문자열 리스트를 생성하는 경우 배열과 문자열을 각각 메모리에 생성해서 연결하면 포인터와 크기 정보가 각각 생성되서 부가 비용이 많이 든다
    - 데이터 필드에 문자열의 메모리 주소가 아닌 문자열데이터를 할당하면 효율적으로 할당할 수 있다
    - free호출도 한번으로 메모리를 해제할 수 있다

## 가비지 컬렉션
- 자바, 파이썬은 포인터 없이도 가비지 컬렉터를 통해 malloc, free같은 동적 메모리 할당을 지원한다
    - new 연산자를 통해서 데이터요소와 함께 사용할 메모리 주소도 할당한다
    - 참조횟수를 통해서 변수를 참조되지 않으면 메모리를 해제 한다

- 가비지 컬렉터는 제어할 수 없다
    - 불필요한 참조가 남을 수 있고 메모리 재활용을 방해하게 되면 프로그램이 느려 질 수 있다(순환참조)

## 이중 연결 리스트
- 링크 필드가 인접한 원소 앞, 뒤를 가리 킨다, 공간/시간의 트레이드 오프라 할 수 있다

## 대용량 저장장치
- 기본 단위(블록), 연속적인 블록(클러스터), 클러스터는 한 트랙안에 연속적인 섹터로 이뤄진다
    - 데이터를 한 클러스터에만 저장하는게 효율적이지만 데이터는 사용 가능한 섹터가 있으면 위치와 관계없이 저장된다
    - 동적 메모리 할당 처럼 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 이런 블록에 나눠 담아야 한다
        - 블록중 일부를 아이노드로 지정한다
            - inode : 디스크 블록에 대한 인덱스와 노드를 합친단어
        - 아이노드는 파일관련 정보와 파일 데이터가 들어있는 블록에 대한 인덱스가 포함된다
            - 계층적 파일 시스템이다
            - 링크를 통해 같은 파일이 여러 디렉터리에 나타날 수 있다
            - 링크 : 아이노드가 블록을 참조하는 것
            - 심볼릭 링크 : 디렉터리에 대한 링크이다
        
    - 사용가능한 섹터를 연결 리스트로 관리하면 순회에 시간이 너무 오래 걸린다
        - 비트맵을 사용할 수 있지만 크기가 커지거나 가용공간과 비트맵의 동기화가 깨질 수 있다
        - fsck : 파일 시스템 그래프를 통해 가용블록 데이터를 비교해서 가용공간을 저장한다
        - 지금은 저널링(journaling) 파일 시스템이 쓰이고 있다

## 데이터 베이스
- 데이터 베이스는 B트리라는 데이터 구조를 활용한 시스템이다
    - B트리 : 2진 트리보다 더 많은 자식노드를 가진다, 자식 수는 디스크 블록하나를 정확히 꽉 채울수 있는 숫자로 결정된다
        - 2진 트리보다 공간을 덜 효율적으로 사용하지만 성능은 더 좋다
- 데이터 베이스 관리시스템(DBMS)는 데이터베이스에 정보를 저장하고 읽도록 도와준다

## 인덱스
- 데이터에 접근하는 방법이 여러가지 일 수 있다, 정렬되는 기준이 다른 인덱스는 데이터를 효율적으로 검색할 수 있게 한다
    - 데이터가 바뀌면 변경할 인덱스가 더 많기 때문에 유지보수를 해야한다는 트레이드 오프가 있다

## 데이터 이동
- 프로그램은 한 지점에서 다른 지점으로 데이터를 이동시키기 위해 많은 시간을 소비한다
    - 값을 변경하는 것 자체보다 위치를 검사하고 인덱스를 유지하는등에 시간이 더 걸릴 수 있다
    - 루프 언롤링(loop unrolling) : 검사보다 값 변경에 더 많은 시간을 쓰게 한다
        - 반복문에 검사는 1번 변경은 여러번 하는등의 방식으로 구현할 수 있다
    
## 효율성과 성능
- 데이터베이스 샤딩(수평 파티셔닝) : 데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식
    - 컨트롤러가 각 샤드의 연산결과를 하나로 모은다, 각 샤드가 병렬적으로 연산하기 때문에 성능이 향상된다

- 맵리듀스(map reduce) : 샤딩처럼 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다
   
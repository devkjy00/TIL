- 올바른 객체생성 방법, 불필요한 생성을 피하는 방법, 올바른 파괴를 위한 방법

## 1.생성자 대신 정적 팩터리 메서드를 고려하라
- 정적 팩터리 메서드(static factory method) : 해당 클래스의 인스턴스를 반환하는 정적 메서드
- 장점 
    1. 이름을 가질 수 있다
        - 객체의 특성에 대해 팩토리 이름으로 설명할 수 있다
            ```java
            BigInteger(int, int, Random);
            // 더 명시적으로 의도를 나타낸다
            BinInteger.probablePrime;
            ```
        
        - 시그니쳐의 제약이 없다, 똑같은 타입을 파라미터로 가져도 다른 객체를 만들 수 있다
    
    2. 호출 될때마다 인스턴스를 새로 생성하지는 않아도 된다
        - 불변 클래스의 경우 인스턴스를 미리 만들어 놓고 인스턴스를 캐싱해서 불필요한 객체 생성을 피할 수 있다
            - 불변 타입을 연산하면 새로운 객체를 생성

        - 인스턴스 통제 클래스: 반복되는 요청에 같은 객체를 반환하는 방식으로 인스턴스의 생사를 통제할 수 있다
            - 인스턴스를 통제하면 클래스를 싱글턴 이나 인스턴스화 불가로 만들수도 있다

    3. 반환타입의 하위 타입 객체를 반환할 수 있다
        - 인터페이스를 통해 반환할 객체의 클래스를 자유롭게 선택하는 '유연성'을 제공한다
            - 구현 클래스를 공개하지 않고도 객체를 반환할 수 있다
            - 자바9부터 인터페이스에 정적메서드를 추가할 수 있게 되면서 인스턴스화 불가인 동반 클래스 없이 인터페이스만으로도 다룰 수 있다
        
        - 인스턴스화 불가 클래스인 java.util.Collections에서는 45개의 유틸리티 구현체를 정적 팩토리 메서드를 통해서 제공한다

        - 알아야할 개념의 수를 줄여서 개념적 무게를 낮춘다
    
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다
        - EnuSet 클래스는 정적 팩토리 메서드 allOf(), of()등에서 원소의 길이에 따라 RegularEnumSet, JumboEnumSet 둘중 하나의 인스턴스를 반환한다
        - 클라이언트는 팩터리가 반환하는 객체에 대해 인터페이스만큼만 알면 된다
    
    5. 정적 팩토리 메서드를 구현하는 시점에 반환할 객체의 클래스가 존재하지 않아도 된다
        - 이런 유연함을 기반으로 서비스 제공자 프레임워크가 만들어진다
            - 프레임워크는 서비스(구현체)를 통제해서 클라이언트로부터 분리해준다
        
        - 서비스 제공자 프레임워크 컴포넌트
            - 서비스 인터페이스 : 구현체의 동작을 정의
            - 제공자 등록 API : 제공자가 구현체를 등록할 때 사용
            - 서비스 접근 API : 클라이언트가 서비스에 접근할 때 사용
                - 서비스의 유연함을 제공해 준다
            
        - 자바5부터 ServiceLoader라는 범용 서비스 제공자 프레임워크가 제공된다
    
- 단점 
    1. 상속을 하려면 public나 protected 생성자가 필요, 정적 팩토리 메서드만 있으면 하위 클래스를 만들 수 없다

    2. 정적 팩토리 메서드는 개발자가 찾기 어렵다
        - 생성자 처럼 API설명에 명확히 드러나지 않는다
        - 정적 팩토리 메서드 명명 방식
            - Date.from(), EnumSet.of(), Integer.valueOf(), instance(), getInstance(), create(), newInstance(), getType()...

- public 생성자보다 정적 팩토리 메서드가 유리한 경우가 더 많다
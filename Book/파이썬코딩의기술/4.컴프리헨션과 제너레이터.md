# 컴프리헨션과 제너레이터

- 컴프리핸션 코딩 스타일은 제너레이터를 사용하는 함수로 확장할 수 있다
- 이터레이터를 사용하는 곳이라면 어디서나 제너레이터 함수를 호출한 결과를 사용할 수 있고 제너레이터를 사용하면 선능을 향상시키고, 메모리 사용을 줄이고, 가독성을 높일 수 있다.

# 27.map과 filter 대신 컴프리헨션을 사용하라
- 인자가 하나인 함수를 적용하는 경우가 아니면 보통 map보다 컴프리헨션이 더 명확하다고 간단하다
- 리스트 컴프리헨션은 filter를 사용해야하는 map과 달리 쉽게 원소를 건너뛸 수 있다
- 딕셔너리와 집합도 컴프리헨션으로 생성할 수 있다


# 28.컴프리헨션 내부에 제어 하위 식을 세개 이상 사용하지 말라
- 2단계 깊이로 구성된 리스트 컴프리헨션
    ```py
    matrix = [[2, 5, 7], [11, 4, 6], [6, 2, 7]]
    squared = [[x+2 for x in row] for row in matrix]
    # 2차원 리스트를 중첩괄호를 사용해서 다시 2차원 리스트로 반환한다
    print(squared)
    # -> [[4, 7, 9], [13, 6, 8], [8, 4, 9]]
    ```
- 컴프리헨션에서 if문을 2번 쓰는 건 and와 같다
    ```py
    a = [1,2,3,4,5,6]
    b = [x for x in a if x > 3 if x % 2 == 0]
    c = [x for x in a if x > 3 and x % 2 == 0]

    # 각 괄호마다 하나씩 if문을 사용해서 수준마다 조건을 지정할 수 있다
    filtered = [[x for x in row if x % 3 == 0] 
            for row in matrix if sum(row) >= 10]
            # 코드는 짧지만 가독성이 떨어진다
    ```
    - 컴프리헨션에 들어가는 하위 식이 세개 이상 되지 않게 해야 한다
    - 세 개 이상의 하위식은 일반 if,for문을 사용하고 도우미 함수를 작성하라

# 29.대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라
- 딕셔너리 컴프리헨션에서 조건문을 사용 할 때 왈러스 연산자를 통해서 반복을 줄일 수 있다
    ```py
    a = [2, 4, 6, 7, 8]
    result = {f'{i}에10을 더한수': i+10
            for i in a
            if (i+10) > i+9}
    print(result)
    # 조건문이 좀 억지지만 예제를 위해 ...
    # i+10이 중복된다, 실수할 가능성이 늘어난다


    # 대입식 사용
    result = {f'{i}에10을 더한수': x for i in a
            if (x := i+10) > i+9}
    # 왈러스 연산자를 사용해서 중복되지않게 만들었다
    ```
    - 같은 연산을 두번하지 않아도 되기 때문에 성능도 향상된다
    - 문제는 컴프리헨션이 평가되는 순서(일반for,if문의 순서) 때문에 실행 시점에 오류가 발생 할 수 있다
        ```py
        result = {f'{i}에10을 더한수': x := i+10
                for i in a
                if x > i+9}
                # 대입식을 값에 넣으면 NameError예외가 발생한다 
                # 값이 정의 되기전에 if문에서 값을 참조하려고 하기 때문이다
        ```
    - 컴프리헨션의 값 부분에서 왈러스 연산자를 사용할 때 그 값에 대한 조건 부분이 없다면 루프 밖(for문 바깥)영역으로 루프 변수가 누출된다
        - 따라서 조건문에만 대입식을 써야 변수가 누출되지 않게 할 수 있다

# 30. 리스트를 반환하기보다는 제너레이터를 사용하라

- 함수내에서 시퀀스 값을 반환할 때 리스트에 값을 append함수를 사용해서 결과 값을 반환하면 삽입된 값의 중요성을 희석해버린다(append덩어리가 커서)
- 제너레이터를 사용해서 개선 할 수 있다
    ```py
    def print_only_2(text):
        result = []
        for idx, letter in enumerate(text):
            if (idx+1) % 2 == 0:
                result.append(letter)
    print_only_2('abcdefg')


    def yield_only_2(text):
        for idx, letter in enumerate(text):
            if (idx+1) % 2 == 0:
                yield letter
    # 더 간결하게 중요한 값이 뭔지 볼수 있다
    it = yield_only_2('abcdefg')
    print(next(it))
    # 다음 yield 반환값을 반환
    # list(it)로 리스트로 변환할 수 있다
    ```
    - 제너레이터를 사용하면 결과를 리스트에 합쳐서 반환 하는 것보다 깔끔하다
    - 제너레이터를 사용하면 작업 메모리에 모든 입력과 출력을 저장할 필요가 없으므로 입력이 아주커도 출력 시퀀스를 만들수 있다

# 31. 인자에 대해 이터레이션 할 때는 방어적이 돼라
- 함수의 인자가 이터레이터면 이상하게 작동하거나 결과가 없을 수 있다
- 제너레이터는 한번 StopIteration예외가 발생하면(한번 값을 다 반환하면) 다시 이터레이션해도 아무런 값도 반환하지 않는다
    - 때문에 함수의 인수값으로 쓰면 주의가 필요하다
    - 이미 소진된 이터레이터를 다시 수행해도 오류가 발생하지 않는다
    - 표준 라이브러리에 있는 많은 함수가 연산 도중에 StopIteration예외가 발생해서 소진된 데이터를 구분하기 힘들다
- 그래서 제너레이터를 list()함수로 다른 변수에 복사해서 그 시퀀스를 반복사용하는 방어적인 방법이있다
    - 하지만 그렇게 되면 제너레이터를 사용한의미가 없다, 메모리사용량이 많아질 것이다
- 함수내에서 매번 제너레이터를 호출해서 새 이터레이터를 만들면 소진되도 다시 만들어서 사용할 수 도 있다
- 또는 인수값으로 바로 제너레이터를 생성하는 함수를 호출할 수도 있다
- 이터레이터 작동절차
    - for x in foo -> iter(foo) / foo.```__iter__``` -> 이터객체 반환 ->next()호출 ->StopIteration예외까지 반복
    - 클래스에서 ```__iter__```메서드를 제너레이터로 구현하면 이모든 동작을 만족시킬수 있다
        ```py
        class get_generator():
            def __init__(self, num):
                self.num = num

            def __iter__(self):
                for i in self.num:
                    yield i

        def sequence(x):
            y = list(x)
            # 이터레이션를 한번 했다
            for i in y:
                print(i)
            # 반복된 이터레이션도 정상작동

        a = get_generator([1, 2, 3, 4, 5, 6, 7, 8, 9])
        sequence(a)
        ```
    - 정상적으로 작동하는 이유는 list()와 for문에서 각각 ```__iter__```메서드를 호출해서 각각의 제너레이터를 생성하기 때문에 독립적으로 진행되고 소진되는 것이다
    - 이 접근 방법의 유일한 단점은 클래스속성으로 입력한 데이터를 여러번 읽는 다는 것이다
- 하지만 만약 컨테이너형이 아니라 이터레이터가 iter내장 함수에 전달되면 새로 생성되지 않고 그대로 반환된다
    - 이런 경우 is 로 id 값을 비교해서 iter함수로 반환된 값이 그 이전의 값과 같은지 비교할 수 있다
    - 다른 대안으로 collections.abc 내장 모듈을 isinstance를 사용해 잠재적인 문제를 검사할 수 있는 Iterator 클래스를 제공한다
        ```py
        from collections.abc import Iterator
        if isinstance(num, Iterator):
            raise TypeError('컨테이너 필요')
        ```
    - 비동기 이터레이터에 대해서도 같은 접근 방식을 사용할 수 있다

# 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라
- 리스트 컴프리헨션에서 입력값이 커지면 메모리를 상당히 많이 사용하고 프로그램이 중단될 수 있다.
- 제너레이터 식을 사용하면 된다
    - 시퀀스 전체를 실체화 하지 않고 원소를 하나씩 만들어 내는 이터레이터가 생성된다
        ```py
        foo = (x for x in list)
        # 제터레이터 객체 반환
        ```
- 제너레이터는 두개의 식을 합성할 수 있다
    ```py
    bar = ((x,x**0.5) for x in foo)
    # 제너레이터 객체를 연산해서 제너레이터 객체를 만들 수 있다
    ```
    - 연쇄적으로 루프가 실행되서 조건식을 평가하고 입력과 출력을 서로 주고 받는다
    - 서로 연결된 제너레이터 식은 매우 빠르고 메모리를 효율적으로 사용할 수 있다

# 33. yield from을 사용해 여러 제너레이터를 합성하라
- 제너레이터를 연결해서 사용할 수 있다
    ```py
    def get_a(x: list):
        for i in x:
            yield i

    def get_b(x: list):
        for i in x:
            yield i+10

    def get_both(x: list, y: list):
        yield from get_a(x)
        yield from get_b(y)
        # 각 제너레이터의 이터레이션이 끝날때까지
        # 2중 for문과 같은 느낌이다
    x = [1, 2, 3]
    result = get_both(x, x)
    print(list(result)
    # [1, 2, 3, 11, 12, 13]이 출력된다
    ```
    - 더 명확하고 직관적이다
    - 인터프리터가 for루프를 내포시키고 yield식을 처리하도록 만든다. 성능도 향상
    - 제너레이터를 합성한다면 yield from이 최선

# 34. send로 제너레이터에 데이터를 주입하지 말라
- yield식을 사용해 만든 데이터 채널은 단방향이다
- 제너레이터의 send문은 데이터채널을 양방향으로 
만들어준다
    - 제너레이터 최초 send의 인수값으로 None만 전달 가능
    - 제너레이터가 재개될 때 send의 인수값을 yield에 대입해준다
- 문제점
    - 대입문의 오른쪽에 yield를 사용하는건 직관적이지 않다
    - send와 yield사이의 연결을 알아보기어렵다
    - yield from에서 다음 제너레이터로 옮길 때마다 항상 None값을 반환해야 한다
- 복잡한 send보다 이터레이터를 인수값으로 사용하라
    ```py
    # 좀더 공부해야겠다
    ```


# 35. 제너레이터 안에서 throw로 상태를 변화 시키지 말라
- throw는 제너레이터에서 예외를 일으키는 메서드 이다
    - generator.throw(에러명('출력문'))
    - 예외 값은 이전의 yield문에 대입됨
    - 제너레이터와 제너레이터를 호출하는 쪽의 양방향 통신을 제공한다
    - 가독성이 나빠진다

- 제너레이터에 예외를 일으키는 동작은 ```__iter__```메서드를 구현하는 클래스를 사용하면서 예외적인 경우를 정의해놓는 것이 가장 좋은 방법이다

# 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라
- itertools 내장 모듈에는 이터레이터를 조직화 하거나 사용 할 때 쓸모 있는 여러 함수가 들어 있다
    - 복잡한 이터레이션 코드를 작성할 때 항상 itertools를 살펴보라

- 여러 이터레이터 연결하기
    - chain : 여러 이터레이터를 하나의 순차적인 이터레이터로 합칠 때
        ```py
        import itertools
        it = itertools.chain([1,2,3],[4,5,6])
        ```
    - repeat : 한 값을 반복해서 사용할 때, 두번째 인자로 횟수를 제한
        ```py
        it = itertools.repeat('안녕', 3)
        ```
    - cycle : 어떤 이터레이터가 내놓는 원소들을 계속 반복하고 싶을 때
        ```py
        it = itertools.cycle([1, 2])
        # 조심해라 메모리 터진다
        ```
    - tee : 한 이터레이터를 병렬적으로 두번째 인자로 지정된 개수의 이터레이터를 만든다
        - 소진하는 속도가 다르면 처리가 덜된 이터레이터의 원소를 큐에 담아놔야해서  메모리사용량 증가
        ```py
        it1, it2, it3 = itertools.tee(['하나','둘'], 3)
        ```
    - zip_longest : 여러 이터레이터 중 짧은 쪽 이터레이터의 원소를 다 사용한 경우 fillvalue로 지정한 값을 채워 넣어준다
        ```py
        it = itertools.zip_longest([[1],['사과','귤']] fillvalue='없음')
        # [1,'사과'],['없음','귤']
        ```

- 이터레이터에서 원소 거르기

    - islice : 이터레이터를 복사하지 않고 슬라이싱할 수 있다
        - 끝을 정하거나, 시작과 끝을 정하거나, 시작, 끝, 증가값을 지정할 수 있다
        ```py
        it = itertools.islice([1,2,3,4], 0,1)
        ```

    - takewhile : 이터레이터에 주어진 조건식,함수 반환값이 True인 동안 원소를 반환한다
        ```py
        it = itertools.takewhile(lambda x: x<2, [1,2,3])
        # [1]
        ```
    
    - dropwhile : takewhile의 반대, 조건에 True인 원소는 건너뛰고 False를 반환
        ```py
        it = itertools.dropwhile(lambda x: x<2, [1,2,3])
        # [2,3]
        ```
    
    - filterfalse : filter의 반대, 이터레이터가 조건에 False인 원소를 반환
        ```py
        it = itertools.filterfalse(lambda x: x>2, [1,2,3])
        # [2,3]
        ```
    
- 이터레이터에서 원소의 조합 만들어 내기
    - accumulate : 이항 함수를 반복 적용하면서 이터레이터 원소를 누적된 값 리스트로 만든다
        - 함수를 적용하지 않으면 누적합을 구함
        ```py
        it = itertools.accumulate([1,2,3])
        # [1,3,6], accmulate(함수, 값)
        ```
    
    - product : 하나 이상의 이터레이터에 들어있는 아이템들의 데카르트 곱을 반환
        ```py
        it = itertools.product([1,2],['a','b'])
        # [(1,'a'), (1,'b'), (2,'a'), (2,'b')]
        ```
    - permutations : 이터레이터가 내놓는 원소들로부터 만들어낸 길이 N인 순열을 반환
        ```py
        it = itertools.permutations([1,2,3],2)
        # [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
        ```
    
    - combinations : 이터레이터가 내놓는 원소들로부터 만들어낸 길이 N인 조합을 반환
        ```py
        it = itertools.combinations([1, 2, 3], 2)
        # [(1, 2), (1, 3), (2, 3)]
        ```


    
    
# 컴프리헨션과 제너레이터

- 컴프리핸션 코딩 스타일은 제너레이터를 사용하는 함수로 확장할 수 있다
- 이터레이터를 사용하는 곳이라면 어디서나 제너레이터 함수를 호출한 결과를 사용할 수 있고 제너레이터를 사용하면 선능을 향상시키고, 메모리 사용을 줄이고, 가독성을 높일 수 있다.

# 27.map과 filter 대신 컴프리헨션을 사용하라
- 인자가 하나인 함수를 적용하는 경우가 아니면 보통 map보다 컴프리헨션이 더 명확하다고 간단하다
- 리스트 컴프리헨션은 filter를 사용해야하는 map과 달리 쉽게 원소를 건너뛸 수 있다
- 딕셔너리와 집합도 컴프리헨션으로 생성할 수 있다


# 28.컴프리헨션 내부에 제어 하위 식을 세개 이상 사용하지 말라
- 2단계 깊이로 구성된 리스트 컴프리헨션
    ```py
    matrix = [[2, 5, 7], [11, 4, 6], [6, 2, 7]]
    squared = [[x+2 for x in row] for row in matrix]
    # 2차원 리스트를 중첩괄호를 사용해서 다시 2차원 리스트로 반환한다
    print(squared)
    # -> [[4, 7, 9], [13, 6, 8], [8, 4, 9]]
    ```
- 컴프리헨션에서 if문을 2번 쓰는 건 and와 같다
    ```py
    a = [1,2,3,4,5,6]
    b = [x for x in a if x > 3 if x % 2 == 0]
    c = [x for x in a if x > 3 and x % 2 == 0]

    # 각 괄호마다 하나씩 if문을 사용해서 수준마다 조건을 지정할 수 있다
    filtered = [[x for x in row if x % 3 == 0] 
            for row in matrix if sum(row) >= 10]
            # 코드는 짧지만 가독성이 떨어진다
    ```
    - 컴프리헨션에 들어가는 하위 식이 세개 이상 되지 않게 해야 한다
    - 세 개 이상의 하위식은 일반 if,for문을 사용하고 도우미 함수를 작성하라

# 29.대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라
- 딕셔너리 컴프리헨션에서 조건문을 사용 할 때 왈러스 연산자를 통해서 반복을 줄일 수 있다
    ```py
    a = [2, 4, 6, 7, 8]
    result = {f'{i}에10을 더한수': i+10
            for i in a
            if (i+10) > i+9}
    print(result)
    # 조건문이 좀 억지지만 예제를 위해 ...
    # i+10이 중복된다, 실수할 가능성이 늘어난다


    # 대입식 사용
    result = {f'{i}에10을 더한수': x for i in a
            if (x := i+10) > i+9}
    # 왈러스 연산자를 사용해서 중복되지않게 만들었다
    ```
    - 같은 연산을 두번하지 않아도 되기 때문에 성능도 향상된다
    - 문제는 컴프리헨션이 평가되는 순서(일반for,if문의 순서) 때문에 실행 시점에 오류가 발생 할 수 있다
        ```py
        result = {f'{i}에10을 더한수': x := i+10
                for i in a
                if x > i+9}
                # 대입식을 값에 넣으면 NameError예외가 발생한다 
                # 값이 정의 되기전에 if문에서 값을 참조하려고 하기 때문이다
        ```
    - 컴프리헨션의 값 부분에서 왈러스 연산자를 사용할 때 그 값에 대한 조건 부분이 없다면 루프 밖(for문 바깥)영역으로 루프 변수가 누출된다
        - 따라서 조건문에만 대입식을 써야 변수가 누출되지 않게 할 수 있다

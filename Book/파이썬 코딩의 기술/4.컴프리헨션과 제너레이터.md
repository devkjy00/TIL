# 컴프리헨션과 제너레이터

- 컴프리핸션 코딩 스타일은 제너레이터를 사용하는 함수로 확장할 수 있다
- 이터레이터를 사용하는 곳이라면 어디서나 제너레이터 함수를 호출한 결과를 사용할 수 있고 제너레이터를 사용하면 선능을 향상시키고, 메모리 사용을 줄이고, 가독성을 높일 수 있다.

# 27.map과 filter 대신 컴프리헨션을 사용하라
- 인자가 하나인 함수를 적용하는 경우가 아니면 보통 map보다 컴프리헨션이 더 명확하다고 간단하다
- 리스트 컴프리헨션은 filter를 사용해야하는 map과 달리 쉽게 원소를 건너뛸 수 있다
- 딕셔너리와 집합도 컴프리헨션으로 생성할 수 있다


# 28.컴프리헨션 내부에 제어 하위 식을 세개 이상 사용하지 말라
- 2단계 깊이로 구성된 리스트 컴프리헨션
    ```py
    matrix = [[2, 5, 7], [11, 4, 6], [6, 2, 7]]
    squared = [[x+2 for x in row] for row in matrix]
    # 2차원 리스트를 중첩괄호를 사용해서 다시 2차원 리스트로 반환한다
    print(squared)
    # -> [[4, 7, 9], [13, 6, 8], [8, 4, 9]]
    ```
- 컴프리헨션에서 if문을 2번 쓰는 건 and와 같다
    ```py
    a = [1,2,3,4,5,6]
    b = [x for x in a if x > 3 if x % 2 == 0]
    c = [x for x in a if x > 3 and x % 2 == 0]

    # 각 괄호마다 하나씩 if문을 사용해서 수준마다 조건을 지정할 수 있다
    filtered = [[x for x in row if x % 3 == 0] 
            for row in matrix if sum(row) >= 10]
            # 코드는 짧지만 가독성이 떨어진다
    ```
    - 컴프리헨션에 들어가는 하위 식이 세개 이상 되지 않게 해야 한다
    - 세 개 이상의 하위식은 일반 if,for문을 사용하고 도우미 함수를 작성하라

# 29.대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라
- 딕셔너리 컴프리헨션에서 조건문을 사용 할 때 왈러스 연산자를 통해서 반복을 줄일 수 있다
    ```py
    a = [2, 4, 6, 7, 8]
    result = {f'{i}에10을 더한수': i+10
            for i in a
            if (i+10) > i+9}
    print(result)
    # 조건문이 좀 억지지만 예제를 위해 ...
    # i+10이 중복된다, 실수할 가능성이 늘어난다


    # 대입식 사용
    result = {f'{i}에10을 더한수': x for i in a
            if (x := i+10) > i+9}
    # 왈러스 연산자를 사용해서 중복되지않게 만들었다
    ```
    - 같은 연산을 두번하지 않아도 되기 때문에 성능도 향상된다
    - 문제는 컴프리헨션이 평가되는 순서(일반for,if문의 순서) 때문에 실행 시점에 오류가 발생 할 수 있다
        ```py
        result = {f'{i}에10을 더한수': x := i+10
                for i in a
                if x > i+9}
                # 대입식을 값에 넣으면 NameError예외가 발생한다 
                # 값이 정의 되기전에 if문에서 값을 참조하려고 하기 때문이다
        ```
    - 컴프리헨션의 값 부분에서 왈러스 연산자를 사용할 때 그 값에 대한 조건 부분이 없다면 루프 밖(for문 바깥)영역으로 루프 변수가 누출된다
        - 따라서 조건문에만 대입식을 써야 변수가 누출되지 않게 할 수 있다

# 30. 리스트를 반환하기보다는 제너레이터를 사용하라

- 함수내에서 시퀀스 값을 반환할 때 리스트에 값을 append함수를 사용해서 결과 값을 반환하면 삽입된 값의 중요성을 희석해버린다(append덩어리가 커서)
- 제너레이터를 사용해서 개선 할 수 있다
    ```py
    def print_only_2(text):
        result = []
        for idx, letter in enumerate(text):
            if (idx+1) % 2 == 0:
                result.append(letter)
    print_only_2('abcdefg')


    def yield_only_2(text):
        for idx, letter in enumerate(text):
            if (idx+1) % 2 == 0:
                yield letter
    # 더 간결하게 중요한 값이 뭔지 볼수 있다
    it = yield_only_2('abcdefg')
    print(next(it))
    # 다음 yield 반환값을 반환
    # list(it)로 리스트로 변환할 수 있다
    ```
    - 제너레이터를 사용하면 결과를 리스트에 합쳐서 반환 하는 것보다 깔끔하다
    - 제너레이터를 사용하면 작업 메모리에 모든 입력과 출력을 저장할 필요가 없으므로 입력이 아주커도 출력 시퀀스를 만들수 있다

# 31. 인자에 대해 이터레이션 할 때는 방어적이 돼라
- 함수의 인자가 이터레이터면 이상하게 작동하거나 결과가 없을 수 있다
- 제너레이터는 한번 StopIteration예외가 발생하면(한번 값을 다 반환하면) 다시 이터레이션해도 아무런 값도 반환하지 않는다
    - 때문에 함수의 인수값으로 쓰면 주의가 필요하다
    - 이미 소진된 이터레이터를 다시 수행해도 오류가 발생하지 않는다
    - 표준 라이브러리에 있는 많은 함수가 연산 도중에 StopIteration예외가 발생해서 소진된 데이터를 구분하기 힘들다
- 그래서 제너레이터를 list()함수로 다른 변수에 복사해서 그 시퀀스를 반복사용하는 방어적인 방법이있다
    - 하지만 그렇게 되면 제너레이터를 사용한의미가 없다, 메모리사용량이 많아질 것이다
- 함수내에서 매번 제너레이터를 호출해서 새 이터레이터를 만들면 소진되도 다시 만들어서 사용할 수 도 있다
- 또는 인수값으로 바로 제너레이터를 생성하는 함수를 호출할 수도 있다
- 이터레이터 작동절차
    - for x in foo -> iter(foo) / foo.```__iter__``` -> 이터객체 반환 ->next()호출 ->StopIteration예외까지 반복
    - 클래스에서 ```__iter__```메서드를 제너레이터로 구현하면 이모든 동작을 만족시킬수 있다
        ```py
        class get_generator():
            def __init__(self, num):
                self.num = num

            def __iter__(self):
                for i in self.num:
                    yield i

        def sequence(x):
            y = list(x)
            # 이터레이션를 한번 했다
            for i in y:
                print(i)
            # 반복된 이터레이션도 정상작동

        a = get_generator([1, 2, 3, 4, 5, 6, 7, 8, 9])
        sequence(a)
        ```
    - 정상적으로 작동하는 이유는 list()와 for문에서 각각 ```__iter__```메서드를 호출해서 각각의 제너레이터를 생성하기 때문에 독립적으로 진행되고 소진되는 것이다
    - 이 접근 방법의 유일한 단점은 클래스속성으로 입력한 데이터를 여러번 읽는 다는 것이다
- 하지만 만약 컨테이너형이 아니라 이터레이터가 iter내장 함수에 전달되면 새로 생성되지 않고 그대로 반환된다
    - 이런 경우 is 로 id 값을 비교해서 iter함수로 반환된 값이 그 이전의 값과 같은지 비교할 수 있다
    - 다른 대안으로 collections.abc 내장 모듈을 isinstance를 사용해 잠재적인 문제를 검사할 수 있는 Iterator 클래스를 제공한다
        ```py
        from collections.abc import Iterator
        if isinstance(num, Iterator):
            raise TypeError('컨테이너 필요')
        ```
    - 비동기 이터레이터에 대해서도 같은 접근 방식을 사용할 수 있다

# 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라
- 리스트 컴프리헨션에서 입력값이 커지면 메모리를 상당히 많이 사용하고 프로그램이 중단될 수 있다.
- 제너레이터 식을 사용하면 된다
    - 시퀀스 전체를 실체화 하지 않고 원소를 하나씩 만들어 내는 이터레이터가 생성된다
        ```py
        foo = (x for x in list)
        # 제터레이터 객체 반환
        ```
- 제너레이터는 두개의 식을 합성할 수 있다
    ```py
    bar = ((x,x**0.5) for x in foo)
    # 제너레이터 객체를 연산해서 제너레이터 객체를 만들 수 있다
    ```
    - 연쇄적으로 루프가 실행되서 조건식을 평가하고 입력과 출력을 서로 주고 받는다
    - 서로 연결된 제너레이터 식은 매우 빠르고 메모리를 효율적으로 사용할 수 있다

# 33. yield from을 사용해 여러 제너레이터를 합성하라
- 제너레이터를 연결해서 사용할 수 있다
    ```py
    def get_a(x: list):
        for i in x:
            yield i

    def get_b(x: list):
        for i in x:
            yield i+10

    def get_both(x: list, y: list):
        yield from get_a(x)
        yield from get_b(y)
        # 각 제너레이터의 이터레이션이 끝날때까지
        # 2중 for문과 같은 느낌이다
    x = [1, 2, 3]
    result = get_both(x, x)
    print(list(result)
    # [1, 2, 3, 11, 12, 13]이 출력된다
    ```
    - 더 명확하고 직관적이다
    - 인터프리터가 for루프를 내포시키고 yield식을 처리하도록 만든다. 성능도 향상
    - 제너레이터를 합성한다면 yield from이 최선
# 5.클래스와 인터페이스
- 파이썬은 상속, 다형성, 캡슐화등 객체지향 언어로서의 기능을 제공한다
- 때로는 새로 작성한 클래스들이 인터페이스와 계층 구조를 통해 상호작용하는 방식을 정의 해야 한다
- 클래스와 상속을 사용하면 의도하는 프로그램의 행동 방식을 객체를 통해 쉽게 표현할 수 있고 확장하고 요구사항에 유연하게 대처할 수 있다
-> 유지보수 하기 쉬운 코드

# 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라

- 사전형 타입을 사용하면 객체의 생명 주기동안 동적인 내부 상태를 유지 할 수 있다
    - 동적이라는 말은 미리 알 수 없는 값의 식별자를 유지한다는 뜻
    - 과하게 확장하면 깨지기 쉬운 코드가 될 수 있다

- 사전형의 특정키가 값으로 또 다른 사전을 맵핑할 수 있다
    ```py
    a = {}
    b = a['a'] = defaultdict(list)
    b['b'] = 10
    print(a['a'] is b)
    # True
    ```
    - 이런식으로 데이터를 계속 내포하면 복잡도를 제어하기 힘들다
    - 유지보수가 힘들어진다

- ***복잡도가 높은 데이터는 클래스로 리팩터링해야한다***
    - 튜플 언패킹을 위치인자로 받으면 인자가 늘었을때 처리할 게 많아진다
        - 네임드 튜플을 사용해라
            - 위치,키워드 인자를 사용할 수 있고
            - 클래스로 변경하기도 쉽다
        - 네임드 튜플의 한계
            - 네임드튜플 클래스에는 디폴트 인자값을 지정할 수 없다
                - 프로퍼티가 많은 데이터에는 사용하기 어렵다
            - 네임드튜플 인스턴스의 속성값을 숫자 인덱스로 접근하거나 이터레이션도 가능해서 다른 프로그램과 연결되면 실제 클래스로 변경하기 어려울 수 있다
                - 명시적으로 새로운 클래스를 정의하는게 더 좋다
        ```py
        from collections import namedtuple

        # 이름과 거주지 저장하기
        A_list = []
        A_list.append(['주영', '순천'])
        A_list.append(['james','newyork'])
        [print(name, city) for name,city in A_list]
        # 위치인자에 의존한 언패킹으로 값의 개수가 변하면 대응하기 힘들다

        B_list = []
        person = namedtuple('person',('name','city'))

        B_list.append(person('주영','순천'))
        B_list.append(person('james','newyork'))
        [print(a.name, a.city) for a in B_list]
        # 키워드,위치로 값에 접근 훨씬 직관적이다
        ```
    
    - 클래스로 리팩토링 하기
        
        ```py
        # 거주자를 포함하는 단일 나라를 표현하는 클래스
        class country:
            def __init__(self):
                self._person = []
            
            def report_resident(self, name, city):
                self._person.append(person(name, city))
                # 속성값에 네임드 튜플을 append

        # country클래스를 활용
        class city:
            def __init__(self):
                self._city = defaultdict(country)

            def get_city(self, name):
                return self._city[name]
        ```

- 정리
    - 여러 타입이 복잡하게 내포된 데이터를 값으로 갖는 딕셔너리를 만들지 말라
    - 클래스의 유연성이 필요치 않고 가벼운 불변 데이터 컨테이너는 namedtuple을 사용하라
    - 내부 상태를 표현하는 딕셔너리가 복잡해지면 데이터를 관리하는 여러 클래스로 분리하라

# 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라
API가 실행될 때 인자값으로 전달된 함수를 실행하는 경우, 이런 함수를 훅(hook)이라고 한다
- 함수는 클래스보다 정의하기 쉽다, 훅으로 사용하기 이상적
- defaultdict의 디폴트 값으로 함수, 클로저, 클래스를 써서 로그를 남기고 값을 반환할 수도 있다
    - 클로저보다는 작은 클래스를 정의하는 것이 더 직관적이다
        - 클래스의메서드나 더 좋은 방법으로는```__call```을 정의해서 훅으로 사용할 수있다

- 정리
    - 간단한 인터페이스가 필요할 때 함수를 사용
    - 함수나 함수참조를 식에 사용할 수 있다
    - ```__call```을 정의하면 더 직관적이고 캡슐화에 도움이된다

# 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라
파이썬은 객체뿐 아니라 클래스도 다형성을 지원한다
- 여러 계층을 이루는 파생클래스들이 자신에게 맞는 메서드 버전을 구현한다
- 추상 인터페이스를 정의, 구체적 하위 클래스를 구현하는 방법도 있다
- @classmethod를 사용한 다형성 
    ```py
    class A:
        def __init__(self, value):
            self.value = value

        @classmethod
        def Do(value):
            return cls(value) # 생성자 정의
    ```
- 정리
    - 클래스 생성자는 ```__init__``` 메서드 뿐
    - @classmethod를 사용하면 클래스에 다른 생성자를 정의할 수 있다
    - 다형성을 활용하면 하위클래스의 객체를 만들고 연결하는 제너릭한 방법을 제공

# 40. super로 부모 클래스를 초기화 하라
- 부모클래스명.```__init__```메서드로 부모클래스를 초기화 하는 것
    - 다중상속에 의해 예측하지 못한 방식으로 작동할 수 있다
    - 클래스 상속순서와 일치하지 않을 수 있고 이는 발견하기 어렵다
    - 다이아몬드 상속으로 문제가 생길 수 있다
        > 다이아몬드 상속
        - 부모 클래스가 같은 조상클래스를 상속받아서 조상클래스의 메서드가 여러번 호출되는 것
    
- super().```__init__```메서드로 부모클래스를 초기화 하는 것
    - super내장 함수는 다이아몬드 상속을 받아도 조상클래스가 한번만 호출되도록 보장 한다
    - 표준 메서드 결정 순서(MRO)는 상위클래스를 초기화하는 순서를 정의한다
        - C3선형화 라는 알고리즘 사용
    - mro()메서드로 메서드 결정순서를 확인 할 수 있다
    - super는 첫번째 부터 super가 정의된 계층의 끝까지 호출해서 역순으로 계층의 위에서 부터 작업을 수행한다
    - 클래스 명이 바뀌어도 똑같이 동작해서 유지보수가 편하다
    - 선택적 사용가능한 파라미터 값
        1. 접근하고 싶은 MRO뷰를 제공할 클래스(보통```__class__``)
        2. MRO뷰에 접근할 때 사용할 인스턴스(보통self)
        - 값을 입력하지 않아도 자동으로(```__class__, self```를 넣어준다)
        - 자식 클래스에서 상위 클래스의 특정 기능을 감싸거나 재사용하기 위해 파라미터 값을 사용한다


- 정리
    - 파이썬 표준 메서드 결정순서(MRO)를 활용해 상위 클래스 초기화 순서와 다이아몬드 상속 문제를 해결
    - super를 아무 인자없이 호출하면 파이썬 컴파일러가 자동으로 파라미터를 넣어준다


# 41. 기능을 합성할 때는 믹스인 클래스를 사용하라
다중 상속은 피하는 편이 좋다
- 믹스인은 자식 클래스가 사용할 메서드 몇개 만 정의하는 클래스
    - 자체 속성이 없어서 ```__init__```을 정의할 필요가 없다

- 제너릭 기능을 쉽게 연결할 수 있고 기존 기능을 다른 기능으로 오버라이딩해서 변경할 수 있는것이 장점이다



- 정리
    - 믹스인을 사용해 구현할 수 있는 기능을 인스턴스 속성,```__init__```을 구현한 다중상속으로 구현하지 말라
    - 믹스인 클래스별로 특별한 메서드가 필요하다면 인스턴스수준에서 인스턴스가 제공하게 만들어라
    - 믹스인에는 클래스 메서드가 포함될 수 있다
    - 믹스인 합성으로 복잡한 기능도 만들수 있다

# 42. 비공개 속성보다는 공개 속성을 사용하라
파이썬에서 클래스의 속성에 대한 가시성을 공개,비공개 두가지 뿐이다
- __속성은 비공개 필드가 된다
    - 클래스 메서드는 비공개 필드에 접근할 수 있다
    - 하위 클래스는 부모의 비공개 필드에 접근할 수 없다
    - 비공개 필드는 속성의 이름을 바꾼다, 바뀐이름으로 접근할 수 있다
    - 하위 클래스의 필드와 이름이 충돌할수 있을 때 사용된다
        - API를 외부에 제공하는 경우 하위 클래스 작성이 제어밖에서 일어나기 때문에 자주 쓰이는 이름은 맹글링을 통해서 위험을 줄 일수 있다

- 보호해야할 속성에는 _를 사용해야 한다
    - __를 사용해도 여전히 접근할 수 있지만 작성한 코드가 깨질 위험이있다
    - 보호 필드에 대해서 문서에 작성하는 방법이 있다

- 정리
    - 파이썬 컴파일러는 비공개 속성을 엄격하게 금지하지 않는다
    - 속성을 비공개로 하기보다 사용자들이 속성을 사용해서 더 많은 일을 할 수 있게 하는 것이 파이썬스러운것
    - 맹글링으로 API 외부 하위 클래스를 정의할 때 속성명이 겹치지 않도록 할 수 있다
    - _를 사용해서 속성을 보호하라
    - 
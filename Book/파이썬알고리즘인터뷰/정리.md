# 6.문자열 조작
## Timsort 알고리즘
- 파이썬의 sorted()는 Timsort 알고리즘을 사용한다
  - 파이썬을 위해 C로 구현한 알고리즘으로 현업에서 가장 널리 쓰인다
  - 데이터가 어느정도 정렬되어있을 것을 가정하고 고성능을 낼 수 있도록 설계한 알고리즘
    - 이미 정렬된 데이터는 비교를 건너뛴다  
 
  - 삽입정렬과 병합정렬을 휴리스틱하게 적절히 조합해 구현되었다

- 자바의 Array.sort()는 병합 정렬의 개선버전을 사용한다 
  - Timsort 알고리즘이 Collections의 정렬 알고리즘으로 적용되었다


## 유니코드와 UTF-8
- UTF-8은 가변길이 문자로 데이터의 크기에 따라서 바이트 크기를 조절해서 저장한다
  - 시작 바이트에서 길이를 표현하는 이진수가 사용된다
  - 값이 127이하이면 1바이트로 표현하게 된다

- UTF-8을 쓰면 길이가 각각 달라서 인덱스로 접근하기 힘들기 때문에 파이썬에서는 사용하지 않는다

# 7.배열
## 자료구조
- 메모리공간 공간의 기반의 연속(Contiguous) 방식과 포인터 기반의 연결(Link)방식으로 나뉜다

## 브루트 포스 최적화
- for문을 in연산자로 바꿀 수 있으면 더 빨라진다
- 정렬된 리스트를 투 포인터로 비교하면서 값을 찾는 방법
  - 정렬하면 원래의 인덱스가 망가지기 때문에 주의

## 투 포인터
- 하나의 반복문에서 오른쪽 인덱스(시작 위치), 왼쪽 인덱스(끝 위치) 투 포인터를 사용해서 구현

# 8.연결리스트
## 러너(Runner) 기법
- 연결리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법
- 한 포인터가 다른 포인터보다 앞서게 해서 병합지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있다
  - 주로 느린 러너 한 칸씩, 빠른 러너 두 칸씩 이동한다

# 11. 해시 테이블
- 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수 
- 파이썬은 해싱 충돌 해결방법으로 오픈 어드레싱(선형 탐사)을 사용한다 
  - 체이닝 시 메모리 할당하는 오버헤드가 높다
  - load factor를 0.6 이하로 유지하면 성능이 떨어지지 않는다
  - 자바는 개별 체이닝 방식을 사용한다

## Q.상위K빈도요소
- zip() 
  - 제너레이터를 반환한다, list()를 사용해서 변환
  - 요소를 합쳐서 튜플 시퀀스를 만든다

# 12.그래프
## 그래프 문제 
- 해밀턴 경로 : 한 번만 방문하는 경로
- 해밀턴 순환 : 한 번만 방문하여 출발지로 돌아오는 경로
- 외판원 문제 : 한 번만 방문하여 출발지로 돌아오는 경로 중 가장 짧은 경로


## 백 트래킹
- 해결책에 대한 후보를 만들고 가능성이 없다고 판단되면 바로 포기(백트랙)해서 정답을 찾아가는 범용적인 알고리즘
  - 제약 충족 문제에 특히 유용하다
  - DFS와 같은 방식으로 탐색하는 모든 방법

- 주로 재귀로 구현하며 알고리즘마다 DFS 변형이 조금씩 일어나지만 모두 DFS 범주에 속한다
- 브루트 포스와 유사하지만 가능성이 없는 후보는 포기한다는 점에서 더 우아한 방식이다

## 제약 충족 문제
- CSP(Constraint Stisfaction Problems, 제약 충족 문제)
  - 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제(대표적으로 스도쿠)
  - 백트래킹은 CSP를 풀이하는데 필수적인 알고리즘이다

## 중첩 함수
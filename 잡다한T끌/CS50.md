# 컴퓨팅적 사고

## 2진법
- 각 자리수가 2의 거듭제곱을 의미한다
- 2진법에서 100은 2²x1 + 2¹x0 + 1x0 = 4이다

-  비트
    - 0,1 두가지 값만 가지는 측정 단위

- 비트열
    - 바이트는 8개의 비트가 모여 만들어진 것

## 정보의 표현
- 문자의 표현
    - 아스키코드(ASCII:American Standard Code for Information Interchange) : 128개의 부호로 정의
        - A는 65, 2진법으로 1000001

    - 유니코드(Uniccode) : 더 많은 비트를 사용, 다른문자들도 표현가능 하도록 지원
    - 픽셀 : RGB로 표현

    - CS50 -> 67, 83, 50 -> 1000011, 1010011, 110010
        - 몫넘기고 나머지 <-방향으로 적기, 몫0 될때까지
        - 10진법으로 변환할때는 1자리의 2의n승을 더하기
## 알고리즘
- 입력받은 자료를 출력 형태로 만드는 처리과정
- 규칙들의 순서적 나열

# C
- clang : 컴파일러
- 부동 소수점 부정확성
    - float은 저장 가능한 비트수가 유한하기 때문에 소수점이 길어지면 부정확한 결과를 낸다

- 정수 오버플로우
    - int타입이 저장할 수 있는 수를 넘어서면 에러와 함께 0이 출력된다

## 컴파일링
- make, clang의 단계
    - 전처리 : #include는 전처리기에게 다른파일의 내용을 포함시키라고 알려준다
    - 컴파일링 : C코드를 어셈블리어로 컴파일 한다
    - 어셈블링 : 어셈블리 코드를 오브젝트 코드로 변환시킨다, 연속된 0과 1들로 바꾸는 작업
    - 링킹 : 프로그램이 라이브러리를 포함해 여러개의 파일로 이루어져있다면 링크를 통해 여러개의 오브젝트 코드 파일을 하나의 오브젝트 코드파일로 합쳐준다

## 디버깅
- 디버거로 프로그램을 특정 행(중지점)에서 멈춰서 버그를 찾는다

## 자료
- 자료형의 크기
    - bool : 1 bit
    - char : 1 bit
    - int : 4 bit
    - float : 4 bit
    - long : 8 bit
    - double : 8 bit
    - string : ? 

# 알고리즘

## 검색 알고리즘
- 선형 검색
    - 배열의 인덱스를 하나씩 증가시켜서 값을 확인한다

- 이진 검색
    - 배열이 정렬되어있다면 배열 중간부터 값을 비교하여 작은 인덱스나 큰 인덱스로 이동하면서 반복

## 알고리즘 표기법
- Big O
    - 실행시간의 상한을 의미
    - O는 "on the order fo"의 약자이다
    - O(n)은 n만큼 커지는 것으로 n과 비례해서 선형적으로 증가한다
    - O(n^2): 선택 정렬, 버블 정렬
    - O(n log n)
    - O(n) - 선형 검색
    - O(log n) - 이진 검색
    - O(1)
- Big Ω
    - 실행시간의 하한, 최소값을 의미
    - 최대 n번의 검색을 해야할때 상한이 O(n)이 되지만 한번에 끝날 수도 있기 때문에 하한은 Ω(1)이다
    - Ω(n^2): 선택 정렬, 버블 정렬
    - Ω(n log n)
    - Ω(n) - 배열 안에 존재하는 값의 개수 세기, 버블 정렬(상황에 따라)
    - Ω(log n)
    - Ω(1) - 선형 검색, 이진 검색

## 선형 검색
- 정확하지만 아주 효율적이지 못한 방법
    - 최악의 경우 리스트전부를 확인해야 한다
- 정렬되어있지 않거나 아무런 정보가 없어 하나씩 찾아야 할 때 유용하다
- 따라서 정렬을 해주면 이진검색으로 검색 시간을 단축시킬 수 있다

## 버블 정렬
- 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법
    - 거품이 위로 올라오는 듯한 모양
- 단 하나의 요소를 정렬하기 위해 너무 많은 교환을 발생시킬수 있다
- 버블 정렬 실행 시간의 상한은 O(n^2)
- 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)

## 선택 정렬
- 배열안에 가장 작은 수를 찾아 첫 번째 위치의 수와 교환해주는 방식의 정렬
    - 교환 횟수는 최소화, 비교하는 횟수는 증가
- 소요 시간의 상한은 O(n^2)
- 하한도 마찬가지로 Ω(n^2)

## 재귀
- 함수가 본인 스스로를 호출하는 것

## 병합 정렬
- 원소가 한 개가 될 때까지 반으로 나누다가 다시 합치는 정렬 방식
    - 재귀적으로 구현되는 방식

7 | 4 | 5 | 2 | 6 | 3 | 8 | 1 → 가장 작은 부분 (숫자 1개)으로 나눠진 결과입니다.

4   7 | 2   5 | 3   6 | 1   8 → 숫자 1개씩을 정렬하여 병합한 결과입니다.

2   4   5   7 | 1   3   6   8 → 숫자 2개씩을 정렬하여 병합한 결과입니다.

1   2   3   4   5   6   7   8 → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과입니다. 

- 병합 정렬 실행시간 상한은 O(n log n)
- 반으로 나누는데 O(log n)의 시간이 들고, 다시 정렬해서 병합하는데 O(n)의 시간이 걸린다
- 실행 시간의 하한도 역시 Ω(n log n)

# 메모리

## 메모리 주소
- 16진수
    - 16진수는 10진수보다 2진수를 간단하게 나타낼 수 있다
    - 2의4승이 16이기 때문에 0000부터 1111까지 16진수로 표현 가능
    - 10은 a, 11은 b...15는 f를 대입하여 사용(4bit당 한자리수만  써야하기 때문)
    - 0x를 붙혀 뒤에 오는 문자들이 16진수임을 알려준다
    - 유용성
        - ASCII 코드는 2진수로 변환하면 너무 길다, 16진수로 표현하면 간단 2개의 16진수는 1byte의 2진수로 변환되기 때문에 유용하다
    - C에서 &로 얻을 수 있는‘0x7ffe00b3adbc’같은 값은 16진법으로 표현된 메모리 주소이다

## 포인터
- 배열은 첫 인덱스를 가리키는 포인터이다
- 문자열도 배열이다
        - typedef char *string
        - 문자형을 포인터로 가리켜서 문자열로 선언

## 문자열 비교
- 문자열을 비교하는 것은 첫 인덱스의 주소값에서 하나씩 증가 시키면서 문자하나씩 비교하는 것이다

## 문자열 복사
- 문자열은 배열, 포인터이기 때문에 대입식에 사용하면 같은 메모리 주소를 가리키게 된다
- 따라서 C에서는 메모리 할당함수를 사용해서 복사한다
    - malloc() : 인수크기 만큼의 메모리를 할당(문자열의 끝에 null값도 포함해야한다)
    - for 문으로 문자하나씩 메모리가 할당된 배열에 대입

## 메모리 할당, 해제
- malloc함수로 메모리를 할당한 후에는 free함수로 메모리를 해제해줘야한다
    - 그러지 않으면 쓰레기 값으로 남아 낭비가 발생하는 '메모리 누수'가 생긴다

## 메모리 교환, 스택, 힙
- 메모리 안에는 데이터 저장구역이 나눠져 있다
    - 머신 코드영역 : 프로그램이 실행될 때 컴파일된 바이너리가 저장된다(코드)
    - 글로벌 영역 : 프로그램에서 저장된 전역 변수가 저장된다
    - 힙 영역 : malloc로 할당된 메모리의 데이터가 저장된다
    - 스택 영역 : 프로그램 내의 함수와 관련된 것들이 저장된다
    - 힙, 스택은 하나의 영역을 나눠서 사용하고 있다 

- 같은 스택영역에서도  다른 함수의 변수는 서로다른 위치에 저장되서 서로 참조하지 못한다

- 힙 오버플로우, 스택 오버플로우
    - 힙 영역에서 malloc에 의해 메모리가 많이 할당되거나 스택영역에 함수가 더 많이 호출 될수록 제한된 메모리 범위가 기존의 값을 침범하는 현상

# 자료 구조

## malloc, 포인터
```c
int *x;
// x = malloc(sizeof(int));
*x = 4;
```
- 포인터를 선언후에는 malloc로 특정 메모리를 가리키도록 정의 해야한다
- 만약 정의 하지 않으면 초기화 되지않은 포인터가 임의로 메모리주소를 가리키고 오류가 발생할 수 있다

## 배열 크기 조정
- 이미 정해진 크기의 배열을 키우려면 새로운 공간에 원하는 크기의 메모리를 다시 할당하고 값들을 옮겨 줘야 한다
    - O(n) 소요된다

## 연결 리스트
- 데이터 필드에 값을 저장 링크필드에 다음값의 주소를 저장한다
    - C의 구조체와 같은 구조이다

- 연결리스트 크기가 n일 때 탐색 시간은 O(n)이다
    - 배열의 이진검색에 비해 분리

- 트리
    - 이진 검색 트리의 실행,삽입 시간은 모두 O(log n)이다

## 해시 테이블
- 해시테이블은 "연결 리스트의 배열" 이다
    - 해시함수로 각 값들을 고유한 인덱스에 대입한다
    - 하나의 해시값에 하나의 값만 들어있다면 검색 시간은 O(1)이 된다

## 트라이
- 기본적으로 '트리'형태의 자료구조이다
- 각 노드가 배열로 이루어져 있다
- 예    
    - 노드는 a부터 z까지값을 가지는 배열이고 알파벳은 다음층의 노드(a~z)를 가리키는 방향을 저장하는 것
    - 그렇게 이어서 문자열을 생성할 수 있다
    - 값을 검색하는데 걸리는 시간은 '문자열의 길이', O(n)이지만 그리 크지않은 경우 O(1)이나 마찬가지

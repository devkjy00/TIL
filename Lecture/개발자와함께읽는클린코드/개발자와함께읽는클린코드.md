## 1,2장 
### 현업 코드
- 서버 health 체크를 위한 health check api
	```java
	/**
	 * @auther : kjy
	 */

	@RestController
	public class HealthCheckController {
	    @GetMapping("/api/ping")
	    public String ping() {
	        return "ok";
	    }
	}
	```

- 인텔리j의 Http 파일로 테스트 하기
	- src/test/http 폴더 생성
	- ping.http 파일 생성
		```http
		GET http://localhost:8080/api/ping

		<!--환경 변수로 값 대입-->
		GET {{host}}/api/ping
		```

	- 환경변수 파일 http-client.env.json 생성
		```json
		{
			"dev": {
				"host": "http://localhost:8080"
			},
			"prod": {
				"host": "http://..."
			}
		}
		```
	
## 3장 함수
- SOLID
	- SRP(단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 한다.
	- OCP(개방-폐쇄 원칙) : 확장에는 열려있고 변경에는 닫혀있어야 한다.
		- 추상화와 다형성 활용
	- LSP(리스코프 치환 원칙) : 자식 클래스는 부모 클래스로 교체 가능해야 한다.
		- 서브타입은 기반타입의 규칙(접근제한자, 예외 포함)을 지켜야 한다
	- *ISP(인터페이스 분리 원칙)* : 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
		- 가능한 최소한의 인터페이스만 구현해야 한다
		- *하나의 클래스에 클라이언트가 여러개 이고 이들이 클래스의 일부분만 사용한다면 인터페이스를 분리해서 필요한 기능만 전달한다*
	- DIP(의존관계 역전 원칙) : 추상화에 의존해야지 구체화에 의존하면 안된다.
		- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다
		- 추상화를 매개로 메시지를 전달해서 의존성을 역전시킨다
			- 클라이언트가 구현 클래스를 직접 호출하면 새로 추가된 구현 클래스를 사용할 수 없다 -> 추상화로 의존성을 역전, 다형성을 얻는다
		
- 간결한 함수 작성
	- 함수를 작게 쪼깨고 추상화 수준을 동일하게 유지한다
	- ***한가지만 하기, 변경에 닫힌 구현***
		```java
		// bad - 계산과 생성 두가지 기능, 새로운 타입이 추가되면 switch문에 새로운 타입을 추가해야 한다
		// Employee의 멤버를 사용하는 계산을 Employee 클래스 밖에서 처리한다
		public Money calculatePay(Employee e) throws InvalidEmployeeType { 	// 타입에 따른 Money 반환
		    switch (e.type) {
		        case COMMISSIONED:
		            return calculateCommissionedPay(e);
		        case HOURLY:
		            return calculateHourlyPay(e);
		        case SALARIED:
		            return calculateSalariedPay(e);
		        default:
		            throw new InvalidEmployeeType(e.type);
		    }
		}	

		// good - 계산과 타입관리를 분리, 타입에 대한 처리는 최대한 Factory에 위임
		// Employee의 멤버를 사용하는 계산은 Employee 클래스에 정의해서 응집도를 높였다
		public abstract class Employee {  // 계산에 대한 처리를 위임
		    public abstract boolean isPayday();
		    public abstract Money calculatePay();
		    public abstract void deliverPay(Money pay);
		}

		public interface EmployeeFactory { // 타입에 대한 처리를 위임
		    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
		}

		public class EmployeeFactoryImpl implements EmployeeFactory {
		    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		        switch (r.type) {
		            case COMMISSIONED:
		                return new CommissionedEmployee(r);
		            case HOURLY:
		                return new HourlyEmployee(r);
		            case SALARIED:
		                return new SalariedEmployee(r);
		            default:
		                throw new InvalidEmployeeType(r.type);
		        }
		    }
		}
		```
		> 타입에 대한 처리는 최대한 Factory에 위임하라

	- 함수 인수가 3개 이상이면 객체로 바꿔서 전달
		- 가변인자는 잘 사용하지 않는다
	
- 안전한 함수 작성
	- 부수 효과(Side Effect)없는 함수 
		- 값을 반환하는 함수가 관계없는 외부 상태를 변경하면 안된다

- 함수 리팩터링

### 현업 코드
- *enum 타입을 정의할 때 속성 값으로 타입에 대한 description을 정의해주는게 좋다*
- 타입을 생성하는 로직과 비즈니스 로직은 항상 분리하라
	- private 메서드, factory 클래스로 분리
		- if문은 복잡한 조건으로 객체를 생성할 때 사용하기 좋다
		- case문에 enum을 사용해서 객체를 생성할 수 있다
		- 예전에 난 enum에 데이터와 생성자 구현했다 -> 커스텀 예외를 던질 수 없다
	> 도메인 모델에 대한 타입 생성은 변경/추가 되기 쉽기 때문에 항상 분리하는 것이 좋다

- 중복되는 내용을 인터페이스의 defalut 메서드로 구현하고 추상 메서드를 호출하도록 하는 템플릿 메서드 패턴을 고려해보자
- 소프트웨어는 이전처럼 계속 동작하도록 유지하는 것이 아니라 시간에 따라서 계속 변화해야 한다

- 비용을 증가시키는 예
    - 반복해서 쓴 코드를 수정해야 하는 경우
    - 변수의 값이 예상치 못하게 바뀌는 경우
    - 조건문에 새로운 조건추가를 할때 모든 조건문에 추가하는 경우 

    - 코드 분석, 변경 시간이 증가하게 된다

- 객체지향은 캡슐화, 다형성(추상화)로 비용을 낮춰준다

## 객체
- 객체는 기능으로 정의 된다(데이터가 아닌 메서드로)
    - 메서드의 선언부에 기능을 명세한다

- 메시지 : 객체와 객체의 상호작용을 표현하는 말
    - 호출, 리턴, 예외

- 특별한 기능이 없이 데이터만 가지고 있으면 데이터클래스라고 한다

## 캡슐화

- 객체 구현내용을 감춤으로써 외부에 영향 없이 객체 내부 구현변경을 할 수 있다
    - 데이터와 관련되 기능을 하나로 묶는다(명확한 이름의 메서드 하나로 정의하는 것)
    - 요구 사항이 바뀌어도 최소한의 코드를 변경하면 된다
        - 요구사항이 바뀌면 변경 될 만한 값들은 캡슐화를 해야 한다
    - 기능에 대한 이해도를 높일 수 있다

- Tell. Don't Ask(데이터를 달라고 하지 말고 해달라고 하기)
    - if(a.getNum() == "10") -> if(a.hasNum10())

- Demeter's Law
    - 메서드에서 생성한 객체의 메서드만 호출
    - 피라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출
    - a.getNum().isNum10() -> a.hasNum10()
        - 메서드 하나를 호출하도록 바꿔라
    
## 다형성, 추상화
- 다형성 : 한 객체가 여러 타입을 갖는것
    - 여러 타입에서 동일한 기능을 제공
    - 상속으로 다형성 구현

- 추상화 : 비슷한 개념이나 의미있는 표현으로 정의하는 과정
    - 공통 성질을 가진 타입을 정의한다
    - 주로 인터페이스 타입으로 추상화 한다
    
    - 추상화는 의존대상이 변경하는 시점 해야한다
        - 추상화 -> 추상타입증가 -> 복잡도 증가
        - 실제 변경,확장이 발생할 때 추상화를 해야한다
    
    - 추상화를 할 때는 구현을 한 목적이 무엇인지 고려해야한다

## 상속보단 포함
- 상속은 상위 클래스 변경이 어렵고 클래스 수가 많아지고 상속을 오용할 수 있다
    - 상위 클래스가 변경되면 하위클래스가 다 영향을 받게 된다
    - 상위 클래스는 하위클래스에 대해서 캡슐화가 약해지고 변경이 어렵다

- 포함하면 다양한 클래스를 활용할 수 있다
    - 더 많은 이점이 있다

## 기능과 책임분리
- 클래스나 메서드가 커지면 절차 지향의 문제 발생
    - 많은 필드, 변수를 공유하게 되고 여러 기능이 섞여있게 된다

- 책임 분리
    - 패턴 적용
        - 웹 : 컨트롤러, 서비스, DAO
        - 복잡한 도메인 : 엔티티, 밸류, 리포지토리, 도메인 서비스
        - AOP : Aspect
        - GoF : 팩토리, 빌더, 전략, 템플릿 메서드, 플록시/데코레이터 등

    - 계산 분리
    - 연동 분리
        - 네트워크, 메시징, 파일등 연동 처리 코드 분리

    - 조건 분기는 추상화
        - 연속적인 조건문 추상화 고민
    
    - 책임을 분리해서 각 코드가 독립적이여지기 때문에 테스트가 더 쉬워진다

    - 주의 할 점 : 의도가 잘 드러나는 이름을 사용해야 한다

## 의존과 DI
- 의존 : 구현을 위해 다른 구성요소를 사용하는것(객체 생성, 호출, 데이터사용)
    - 의존하는 대상이 바뀌면 많은 코드를 변경해야 할 가능성이 높아진다
    - 순환의존 : 변경이 연쇄 전파 되기 때문에 만들면 안된다
    - 의존하는 대상이 적을 수록 좋다

- 의존 대상이 많을때
    - 기능이 많으면 기능별 각각 클래스로 정의하는 것이 좋다
    - 의존 대상을 단일 기능으로 묶어서 줄일 수 도 있다

- 의존 주입(Dependency Injection) 
    - 외부에서 생성자나 메서드를 이용해서 의존 객체의 값을 주입한다
    - 조립기(Assembler)가 객체 생성, 의존 주입을 처리한다
        - 의존대상이 바뀌면 조립기만 변경하면 된다
        - 의존하는 객체 없이 대역 객체를 사용해서 테스트 가능
    
- 의존 역전 원칙(DIP)
    - 고수준 모듈은 저수준 모듈의 구현에 의존하면 안된다
        - 추상화클래스를 정의 할 때 저수준을 기준으로 하면 안된다, 고수준의 입장에서 추상화해야 한다
        - 저수준 모듈에 대해 아무것도 몰라야 한다
    - 저수준 모듈은 고수준 모듈에서 정의한 추상타입에 의존해야한다

    - 고수준 모듈의 변경을 최소화하면서 저수준 모듈의 변경 유연성을 높인다
    - 처음부터 바로 좋은 설계가 나오지는 않지만 요구사항의 이해도가 높아지면 상위 수준 관점에서 추상화 할 수 있게된다

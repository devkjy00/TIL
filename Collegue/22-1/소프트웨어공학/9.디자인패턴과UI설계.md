# 디자인 패턴
> 학습내용
- 디자인 패턴 정의 및 특징
- 패턴의 분류와 종류

## 디자인 패턴 정의
- 자주 사용하는 설계 형태를 유영별로 정형화한 것
    - 생성패턴 5개, 구조패턴 7개, 행위패턴 11개로 구성

- 장점 
    - 의사소통, 구조 파악에 용이
    - 개발 시간 단축, 변경에 유연한 대처

- 단점
    - 객체 지향 설계/구현 위주
    - 초기 투자 비용 부담(초기에 설계방향을 정하고 패턴을 정해야 한다)

## 패턴의 분류와 종류
- 패턴 분류
    - 생성적
        - 클래스 : 팩토리 메서드
        - 객체 : 추상 팩토리, 싱글톤, 프로토타입, 빌더

    - 구조적 
        - 클래스 : 어댑터(클래스)
        - 객체 : 어댑터(객체), 브리지, 컴포지트, 데코레이션, 퍼싸드, 플라이웨이트, 프록시

    - 행위적
        - 클래스 : 인터프리터, 템플릿 메서드
        - 객체 : 커맨드/반복자, 중재자/메멘토, 옵저버, 상태, 전략, 비지터, 책임 체인

- 생성적 패턴
    - 정의 
        - 객체 인스턴스 생성을 위한 패턴, 사용자와 사용자가 생성해야할 객체 인스턴스 사이의 연결을 끊어주는 패턴
        - 클래스 정의와 객체 생성방식을 구조화, 캡슐화하여 객체가 생성 되거나 변경에 유연하게 해준다
    
    - 유형
        - 팩토리 메서드(Factory Method)
            - 상위 클래스(인터페이스)에서 객체를 생성하는 인터페이스 정의, 하위 클래스에서 인스턴스를 생성하도록 구현
            - 객체를 생성해야 하지만 정확히 어떤객체를 생성해야 할지 모를때 하위 클래스에 위임하여 해결
        
        - 싱글톤(Singleton)
            - 정확히 하나의 요소만 갖는 집합로 클래스의 객체가 오직 한개만 존재하도록 보장
            - 동일한 자원이나 데이터를 처리하는 객체가 불필요하게 여러개 만들어질 필요가 없는 경우
        
        - 프로토타입(Prototype)     
            - 인스턴스를 복제해서 사용하는 구조
                - new Object()보다 clone()을 이용해 기존의 것을 복사 해서 일부만 변경한 인스턴스 생성
                - 일반적인 프로토타입을 만들어 놓고 그것을 사용해서 확장된 인스턴스를 생성

            - 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용

        - 빌더(Builder)
            - 복잡한 인스턴스를 조립하여 만드는 구조
                - 객체 생성 방법과 객체 구현 방법을 분리한다
            
           - 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있다 

        - 추상 팩토리 패턴(abstract factory)
            - 여러개의 구현 클래스를 추상화 시킨것, 사용자에게 API를 제공하고 인터페이스만 사용해서 조립하여 생성한다
                - 추상적인 부품을 조합해서 추상적인 제품을 만드는 것
            
- 구조적 패턴
    - 정의
        - 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴
            - 별도로 구성된 클래스 라이브러리를 통합하는데 유용
        - 객체를 구성하는 방식 자체에 초점
            - 시스템 내의 개체들 사이의 관계를 정립하는 데 도움이 된다
        - 런타임에 객체 컴포지션 구조를 변경할 수 있어서 객체 구성의 유동성있게 확장할 수 있다
    
    - 유형
        - 어댑터 패턴(Adapter)
            - 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할
                - 특정 기능을 감싸서 원하는 형태로 변환
            
            - 호환성이 없는 클래스를 재사용 할 수 있게 해준다

            - 클래스 어댑터 패턴 : 상속을 통한 패턴적용
            - 인스턴스 어댑터 패턴 : 위임을 통한 패턴적용

        - 퍼싸드 패턴(facade, 정면)
            - 여러 클라이언트 클래스와 서브시스템의 클라이언트 사이에 facade라는 객체를 정의해서 복잡한 관계를 정리(구조화)한 것
                - 모든 관계가 전면에 facade객체를 통해서만 이뤄지도록 단순한 인터페이스(창구역할)을 하는 것
            
        - 브릿지 패턴(bridge)
            - 두 장소를 연결하는 역할
                - 구현(동물)과 기능(사냥방식)에 대해 별도의 추상 클래스, 인터페이스로 정의한다

            - 구현과 인터페이스를 분리해서 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다
            
        - 컴포지트 패턴(composite)
            - 사용자가 단일 객체(내용물)와 복합 객체(그릇) 모두 동일하게 다루도록 한 것
                - 객체를 트리 구조로 구성, 객체들의 공통 인터페이스를 정의한다
                    - Entry(공통인터페이스) -> File, Directory
                - 그릇 객체는 다른 그릇이나 내용물 객체를 참조할 수 있다(재귀적 구조)
                    - Directory에 ```ArrayList<Entry>```를 정의

        - 데코레이터 패턴(decorator)
            - 기존의 구현되혀 있는 클래스에 그때그때 필요한 기능을추가 하는 패턴
            - 기능 확장이 필요할 때 상속의 대안으로 사용
        
        - 플라이웨이트 패턴(Flyweight)
            - 인스턴스를 필요한대로 다 만들지 말고 동일한 것은 가능하면 공유해서 객체 생성을 줄이는 것
            - 메모리 사용량을 줄여준다
                
        - 프록시 패턴(Proxy)
            - 특정 로직을 처리하는 프로세스를 별도로 두고 운영하는 설계
    
    - 행위적 패턴
        - 정의
            - 반복적으로 사용되는 객체들의 상호작용을 패턴화 한것
                - 객체의 행위를 조직화, 관리, 연합하는 패턴
            
            - 객체간의 기능을 배분하는 일등 알고리즘 수행에 주로 이용된다
        
        - 유형
            - 인터프리터 패턴(interpreter)
                - 간단한 언어의 문법을 정의하고 해석하는데 사용
                - 문법 규칙을 클래스화한 SQL이나 통신 프로토콜을 개발할 때 사용한다
            
            - 템플릿 패턴(Template)
                - 상위클래스를 추상적으로 표현하고 하위클래스에서 구현하는 패턴

            - 커맨드 패턴(Commend)
                - 명령어를 각각 구현하는 것보다 다형성을 이용해서 추상클래스에 명령어를 호출하면 그에 맞는 서브 클래스를 선택해 실행하도록 하는 패턴 
                    - 명령어에 따른 취소(undo)기능까지 포함
            
            - 이터레이터 패턴(Itorator)
                - 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근하도록 작성(리스트)
                    - iterator 객체에 넣고 객체의 메서드로 자료를 활용한다

            - 메디에이터 패턴(Mediator)
                - 관제탑처럼 중간에서 연결하고 통제하는 역할
                    - 객체 간의 상호작용을 객체로 캡슐화함
            
            - 메멘토 패턴(Memento)
                - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용
                    - 데이터를 저장할 객체를 포함
                - undo 기능을 개발할 때 유용

            - 옵저버 패턴(Observer)
                - 일대다의 객체 의존 관계를 정의한 것
                - 특정 클래스에 변화가 생기면 의존관계인 다른 클래스에 변화를 알리는 역할
            
            - 스태이트 패턴(State)
                - 객체의 상태를 캡슐화, 클래스화 해서 참조하는 방식
                    - on, off
                - 동일한 동작을 객체 상태에 따라 다르게 처리해야 할 때 사용
                - 변경 시(신규 상태 추가) 수정을 최소화
            
            - 스트레이트지 패턴(Strategy)
                - 동일 목적의 여러 알고리즘 중 선택해서 적용 가능하게 하는 패턴
                    - Sort -> quickSort, selectSort...

            - 비지터 패턴(visitor)
                - 각 클래스의 데이터 구조에서 처리기능을 분리해서 별도의 클래스로 정의
                    - 각 클래스에 특정 작업을 수행한다(유틸리티 클래스)
                - 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용(Arrays, Collections..)
            
            - 책임 사슬 패턴(chain of responsibility)
                - 책임을 연결해서 책임 지지 못하는 처리는 다음 책임자에게 자동으로 넘기는 구조
                    - 학생(사용자) -> 학생 지원과 -> 병역 담당, 휴/복학 담당, 취업 담당
# 디자인 패턴
> 학습내용
- 디자인 패턴 정의 및 특징
- 패턴의 분류와 종류

## 디자인 패턴 정의
- 자주 사용하는 설계 형태를 유영별로 정형화한 것
    - 생성패턴 5개, 구조패턴 7개, 행위패턴 11개로 구성

- 장점 
    - 의사소통, 구조 파악에 용이
    - 개발 시간 단축, 변경에 유연한 대처

- 단점
    - 객체 지향 설계/구현 위주
    - 초기 투자 비용 부담(초기에 설계방향을 정하고 패턴을 정해야 한다)

## 패턴의 분류와 종류
- 패턴 분류
    - 생성적
        - 클래스 : 팩토리 메서드
        - 객체 : 추상 팩토리, 싱글톤, 프로토타입, 빌더

    - 구조적 
        - 클래스 : 어댑터(클래스)
        - 객체 : 어댑터(객체), 브리지, 컴포지트, 데코레이션, 퍼싸드, 플라이웨이트, 프록시

    - 행위적
        - 클래스 : 인터프리터, 템플릿 메서드
        - 객체 : 커맨드/반복자, 중재자/메멘토, 옵저버, 상태, 전략, 비지터, 책임 체인

- 생성적 패턴
    - 정의 
        - 객체 인스턴스 생성을 위한 패턴, 사용자와 사용자가 생성해야할 객체 인스턴스 사이의 연결을 끊어주는 패턴
        - 클래스 정의와 객체 생성방식을 구조화, 캡슐화하여 객체가 생성 되거나 변경에 유연하게 해준다
    
    - 유형
        - 팩토리 메서드(Factory Method)
            - 상위 클래스(인터페이스)에서 객체를 생성하는 인터페이스 정의, 하위 클래스에서 인스턴스를 생성하도록 구현
            - 객체를 생성해야 하지만 정확히 어떤객체를 생성해야 할지 모를때 하위 클래스에 위임하여 해결
        
        - 싱글톤(Singleton)
            - 정확히 하나의 요소만 갖는 집합로 클래스의 객체가 오직 한개만 존재하도록 보장
            - 동일한 자원이나 데이터를 처리하는 객체가 불필요하게 여러개 만들어질 필요가 없는 경우
        
        - 프로토타입(Prototype)     
            - 인스턴스를 복제해서 사용하는 구조
                - new Object()보다 clone()을 이용해 기존의 것을 복사 해서 일부만 변경한 인스턴스 생성
                - 일반적인 프로토타입을 만들어 놓고 그것을 사용해서 확장된 인스턴스를 생성

            - 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용

        - 빌더(Builder)
            - 복잡한 인스턴스를 조립하여 만드는 구조
                - 객체 생성 방법과 객체 구현 방법을 분리한다
            
           - 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있다 

        - 추상 팩토리 패턴(abstract factory)
            - 여러개의 구현 클래스를 추상화 시킨것, 사용자에게 API를 제공하고 인터페이스만 사용해서 조립하여 생성한다
                - 추상적인 부품을 조합해서 추상적인 제품을 만드는 것
            
- 구조적 패턴
    - 정의
        - 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴
            - 별도로 구성된 클래스 라이브러리를 통합하는데 유용
        - 객체를 구성하는 방식 자체에 초점
            - 시스템 내의 개체들 사이의 관계를 정립하는 데 도움이 된다
        - 런타임에 객체 컴포지션 구조를 변경할 수 있어서 객체 구성의 유동성있게 확장할 수 있다
    
    - 유형
        - 어댑터 패턴(Adapter)
            - 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할
                - 특정 기능을 감싸서 원하는 형태로 변환
            
            - 호환성이 없는 클래스를 재사용 할 수 있게 해준다

            - 클래스 어댑터 패턴 : 상속을 통한 패턴적용
            - 인스턴스 어댑터 패턴 : 위임을 통한 패턴적용

        - 퍼싸드 패턴(facade, 정면)
            - 여러 클라이언트 클래스와 서브시스템의 클라이언트 사이에 facade라는 객체를 정의해서 복잡한 관계를 정리(구조화)한 것
                - 모든 관계가 전면에 facade객체를 통해서만 이뤄지도록 단순한 인터페이스(창구역할)을 하는 것
            
        - 브릿지 패턴(bridge)
            - 두 장소를 연결하는 역할
                - 구현(동물)과 기능(사냥방식)에 대해 별도의 추상 클래스, 인터페이스로 정의한다

            - 구현과 인터페이스를 분리해서 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다
            
        - 컴포지트 패턴(composite)
            - 사용자가 단일 객체(내용물)와 복합 객체(그릇) 모두 동일하게 다루도록 한 것
                - 객체를 트리 구조로 구성, 객체들의 공통 인터페이스를 정의한다
                    - Entry(공통인터페이스) -> File, Directory
                - 그릇 객체는 다른 그릇이나 내용물 객체를 참조할 수 있다(재귀적 구조)
                    - Directory에 ```ArrayList<Entry>```를 정의

        - 데코레이터 패턴(decorator)
            - 기존의 구현되혀 있는 클래스에 그때그때 필요한 기능을추가 하는 패턴
            - 기능 확장이 필요할 때 상속의 대안으로 사용
        
        - 플라이웨이트 패턴(Flyweight)
            - 인스턴스를 필요한대로 다 만들지 말고 동일한 것은 가능하면 공유해서 객체 생성을 줄이는 것
            - 메모리 사용량을 줄여준다
                
        - 프록시 패턴(Proxy)
            - 특정 로직을 처리하는 프로세스를 별도로 두고 운영하는 설계
    
    - 행위적 패턴
        - 정의
            - 반복적으로 사용되는 객체들의 상호작용을 패턴화 한것
                - 객체의 행위를 조직화, 관리, 연합하는 패턴
            
            - 객체간의 기능을 배분하는 일등 알고리즘 수행에 주로 이용된다
        
        - 유형
            - 인터프리터 패턴(interpreter)
                - 간단한 언어의 문법을 정의하고 해석하는데 사용
                - 문법 규칙을 클래스화한 SQL이나 통신 프로토콜을 개발할 때 사용한다
            
            - 템플릿 패턴(Template)
                - 상위클래스를 추상적으로 표현하고 하위클래스에서 구현하는 패턴

            - 커맨드 패턴(Commend)
                - 명령어를 각각 구현하는 것보다 다형성을 이용해서 추상클래스에 명령어를 호출하면 그에 맞는 서브 클래스를 선택해 실행하도록 하는 패턴 
                    - 명령어에 따른 취소(undo)기능까지 포함
            
            - 이터레이터 패턴(Itorator)
                - 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근하도록 작성(리스트)
                    - iterator 객체에 넣고 객체의 메서드로 자료를 활용한다

            - 메디에이터 패턴(Mediator)
                - 관제탑처럼 중간에서 연결하고 통제하는 역할
                    - 객체 간의 상호작용을 객체로 캡슐화함
            
            - 메멘토 패턴(Memento)
                - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용
                    - 데이터를 저장할 객체를 포함
                - undo 기능을 개발할 때 유용

            - 옵저버 패턴(Observer)
                - 일대다의 객체 의존 관계를 정의한 것
                - 특정 클래스에 변화가 생기면 의존관계인 다른 클래스에 변화를 알리는 역할
            
            - 스태이트 패턴(State)
                - 객체의 상태를 캡슐화, 클래스화 해서 참조하는 방식
                    - on, off
                - 동일한 동작을 객체 상태에 따라 다르게 처리해야 할 때 사용
                - 변경 시(신규 상태 추가) 수정을 최소화
            
            - 스트레이트지 패턴(Strategy)
                - 동일 목적의 여러 알고리즘 중 선택해서 적용 가능하게 하는 패턴
                    - Sort -> quickSort, selectSort...

            - 비지터 패턴(visitor)
                - 각 클래스의 데이터 구조에서 처리기능을 분리해서 별도의 클래스로 정의
                    - 각 클래스에 특정 작업을 수행한다(유틸리티 클래스)
                - 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용(Arrays, Collections..)
            
            - 책임 사슬 패턴(chain of responsibility)
                - 책임을 연결해서 책임 지지 못하는 처리는 다음 책임자에게 자동으로 넘기는 구조
                    - 학생(사용자) -> 학생 지원과 -> 병역 담당, 휴/복학 담당, 취업 담당

# UI설계 원리
> 학습내용
- UI 기본 개념, 설계 원리, 설계 과정, 설계 도구

## UI 기본개념
- User Interface 개요
    - 사용자와 시스템 간의 상호작용을 쉽고 원활하도록 돕는 장치/소프트웨어

- 분야
    - 정보 제공/전달을 위한 물리적 제어
    - 콘텐츠의 상세적 표현과 전체 구성
    - 모든 사용자가 간편하게 사용하도록 하는 기능

- 특징
    - 사용자의 만족도에 가장 큰 영향, 변경이 가장 많다
    - 막연한 작업 기능에 대해 구체적인 방법 제시

- UI의 구분
    - CLI(Command Line Interface) : 텍스트 형태로 명려과 출력을 하는 인터페이스
    - GUI(Graphic User Interface) : 아이콘이나 메뉴를 마우스로 선택해 작업하는 인터페이스
    - NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스

 - 기본 개념
    - 사용성 : 얼마나 사용하기 편한지
    - 멘탈모델 : 현실 세계의 사물이나 과정이 어떻게 작동하는지에 대한 개인의 이해
    - 피드백 : 시스템 상태와 사용자의 지시에 대한 효과
        - 일반적으로 1초이상 지속되는 작업에 대해서 피드백 제공
    - 제약 : 학습없이도 직관적으로 파악할 수 있도록 설계

## UI 설계 원리
- 사용자 중심 : 사용자가 쉽고 편리하도록 환경 제공
- 일관성 : 일관성 있는 조작 방법
- 단순성 : 단순한 조작 방법으로 인지적 부담 최소화
- 결과 예측 가능 
- 가시성 : 메인 화면에 주요기능을 노출해서 조작이 쉽도록 설계
- 표준화 : 기능구조와 디자인을 표준화하여 한번 학습한 후에 쉽게 사용할 수 있도록 설계
- 접근성 : 다양한 계층의 사람이 사용할 수 있도록 설계
- 명확성 : 사용자가 개념적으로 쉽게 인지하도록 설계
- 오류발생해결 : 오류를 사용자가 쉽게 인지하도록 설계

## UI 설계 과정
1. 사용자 분석
    - 사용자 유형에 따라 UI복잡도 결정(숙련된 사용자 -> CLI)
    - 사용자의 목표와 사용자의 스킬과 경험 분석

2. UI 태스크 분석
    - 소프트웨어가 수행할 작업을 분석
    - 유스케이스 별로 UI 흐름을 파악하는 것이 중요
    - 하위 작업 간의 정보 흐름에 따라 GUI 내용 흐름을 결정

3. UI 설계와 구현
    - GUI를 디자인하고 코드에 구현
    - UI설계와 구현에 사용되는 개념

4. 사용성 테스트

## UI 설계 도구
- 와이어 프레임
    - 페이지에 대한 개략적인 레이아웃, UI를 화면단위로 스케치해서 설계
    - 기획 단계의 초기에 제작

- 목 업(Mock up)
    - 와이어프레임보다 좀더 실제 화면과 유사하게 만든 정적인 형태의 모형
    - 시각적 구성요소로 실제로 구현되지는 않는다

- 스토리 보드
    - 와이어프레임에 콘텐츠에 대한 설명, 페이지간 이동 흐름 등을 추가한 문서
    
- 프로토 타입
    - 와이어 프레임이나 스토리보드등에 인터랙션을 적용, 실제 구현된 것처럼 테스트 가능한 동적인 형태의 모형
    - 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플
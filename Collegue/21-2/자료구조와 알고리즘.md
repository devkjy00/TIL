자료 구조 알고리즘

# 1주차
1. 수치자료
> 10진수 		
- [존 영역 1111, 끝 자리 부호, 팩 형식]
> 2진수		
- [최상위 1비트 : 부호표시, 1의 보수(부효비트를 뺀 절댓값의 모든 자리1뺴기) 
- 2의 보수(부호비트 대신에 사용)(제일 아래에 1 더하기)-> 실제로 사용됨, 음수를 2의 보수로 표현하면 값두개를 더하기만하면 연산이 완료]
> 2진수 실수	
- [고정 소수점, 부동 소수점]
2. 문자자료
>BCD			
- [6비트(상위2비트 존영역)]
>EBCDIC		
- [8비트(상위4비트 존영역)]
>ASCII		
- [(7비트(7비트(상위3비트 존영역)]
3. 논리자료
>참			
- [하나 이상의 비트를 1로 표시]
>거짓			
- [전체 비트를 0으로 표시 ]
4. 문자열자료
>구분자		
- [문자열 사이에 세미콜론을 구분자로 사용]
>고정 길이		
- [일정 길이의 메모리를 고정으로 문자열 저장(미사용 공간낭비)]
>포인터		
- [포인터로 문자열의 시작위치 저장(head, end)]

# 2주차
>요구 분석 - 시스템 명세 - 설계 - 구현 - 테스트 - 유지보수
>하향식 설계		
- [작은 단위 문제들을 각각 처리, 분할정복]
>상향식 설계		
- [작은 단위문제를 해결하고 이를 이용해서 
				상위의 큰 단위의 문제를 해결]
>객체지향 설계 방법	
- [자료,처리방법을 객체로 만들고, 객체를
				연결해서 재사용]
>구현				
- [구조화 프로그래밍, 모듈러 프로그래밍]
>테스트			
- [단위테스트(모듈개별실행), 통합테스트,
				 인수테스트(베타 테스트)]
>유지보수			
- [수정형(오류수정), 적응형(환경변화에 따라
				재조정), 완정형(성능향상위한 개선작업),
				예방형(변경사항수용을위한 대비작업)]
>추상자료형		
- [기억할 대상의 특징만을 단순화하여 기억하는 기능
				추상화:무엇인가, 구체화: 어떻게 할건가]
>알고리즘			
- [문제해결방법을 추상화, 단계적 절차를 기술한것]
>공간복잡도		
- [고정공간(프로그램저장공간) + 가변공간(실행에 관련된정보 저장)]
>시간복잡도		
- [컴파일 시간 + 실행시간(실행빈도수(명령문갯수) 계산)]
>빅오 표기법		
- [O(n)]

# 3주차
>다차원배열		
- [c언어의 경우 문자열을 하나의 인덱스에 저장못하기때문에
				\0 이 들어갈 마지막 인덱스를 항상 남겨놓아야한다,
				 파이썬보다 1차원을 더 만들어야함]
>포인터		
- [&주소값에 접근, *참조연산자(참조하는 값에 접근)
			*ptr = 5 x 임의의 주소를 지정할수 없다]
>포인터초기화	
- [char *ptr = (char *)malloc(100) 동적메모리할당후(배열생성) 주소를 포인터지정
- char *ptr = “korea” 문자열이 저장된곳 시작주소가 지정됨
- char *ptr = 배열  배열의 시작주소를 지정
- char *prt = a[2] 배열특정위치의 주소를 지정]

# 4주차
>포인터문자열	
- [ptr + 1 은 str[1]을 의미한다]
>포인터 배열	
- [자료형 *포인터배열이름[크기] , 포인터,주소값을 키값으로 가지게된다
			2차원 문자배열을 1차원 포인터배열로 표현할수있다(각 행을 포인터에대입)
			&ptr[0]=배열주소, ptr[0]=키값주소, *ptr[0]=키값
			포인터배열은 각 인덱스에 주소값을 가져서 문자열 길이에 따라서
			 메모리가할당됨 따라서 메모리 낭비가 없다]
>포인터의포인터	
- [자료형 **포인터변수이름, 포인터를 가리키는 포인터
			**포인터 는 대입한포인터가가리키는자료의 값을 반환한다]

>구조체 		
- [struct 구조체이름{항목}구조체변수이름;
			초기화시 ->  구조체변수이름 = {순서대로} ]
>구조체연산자	
- [. (점 연산자) 점표기법으로 구조체변수의 항목에 접근
- -> (화살표 연산자) 구조체형포인터에서 포인터가가리키는 구조체변수의 항목을지정
- *x(구조체포인터) = &y(구조체변수이름);  x->1 = y.1 과 같다, (*x).1으로도 가능]
>구조체변수배열	
- [struct 구조체이름{항목} a[4]; 같은구조를 가진 배열 생성 2차원배열같이 a[0].1 과 같이 접근]
>구조체복사연산	
- [구조체변수 a,b[4] 일 때 a = b[2]와 같이 구조체변수의 값을 복사]

>재귀호출		
- [순환호출,함수가 스스로를 다시 호출해서 반복사용하는것, 원하는 값이 달성되면 return]
>팩토리얼		
- [3! = 3*2*1 과같은 식, 재귀호출사용의 예]


# 5주차
>선형리스트	
- [순서리스트, 원소들간의 순서를 가지고 있음, 메모리낭비나 연산시간문제등이 있음]
			
>2차원배열물리적구조	
- [행 우선순서방법:행 기준순차저장, 위치 계산(a+(i*nj+j)*len원소),
- 열 우선순서방법: 열 기준순차저장]
>3차원배열물리적구조	
- [면 우선순서방법: 면 기준순차저장]

>다항식		
- [a(계수)x(변수)e(지수) 형식의 항들의 합으로 구성된 식
-  y = 3x제곱+8x… 지수에따라 내림차순으로 항 나열
- 다항식의 차수:가장큰 지수
- 다항식항의 최대갯수:차수+1]
>다항식연산	
- [p.232]
>다항식1차원표현	
- [인덱스:지수(n-i)를 의미
- 원소:지수(n-i) 항의 계수/ >지수값을 갖는 n변수가 필요]
>다항식2차원표현	
- [행의 갯수:다항식의 항의개수
- 열의 개수: 2/ dict 같은 형식]
>희소행렬2차원표현	
- [대부분의값이 0인 행렬
- 데이터개수:행 길이
- (행,열,값)을 하나의 열으로 저장]
>행렬연산		
- [p.243]

# 6주차
>연결자료구조	
- [연결리스트, 포인터배열과 같이 다음 원소의 주소가 저장되어서 메모리 낭비없이 바로 연결됨]
>노드			
- [원소/주소,  하나의 원소를 표현하는 단위 구조
			데이터필드: 원소값 저장, 형태에 따라 하나이상의 필드구성
			링크필드: 다음노드의 주소를 저장, 포인터 변수를 사용, 마지막에는 null저장
			연결리스트구조:  변수명/링크 -> [0]원소값/링크 -> [1]원소값/링크 ~~~]
				
>단순연결리스트	
- [노드가 하나의 링크필드에 의해서 연결되는 구조를 가진 연결 리스트]
>단순연결리스트삽입	
- [공백노드를 가져와서 삽입할 위치앞노드의 링크필드(주소)값을 바꿔서 연결되도록함 조립 하듯이]
>단순연결리스트 삭제	
- [삭제할 원소의 앞 노드의 링크필드값을 바꿔서 삭제후 뒤로 연결되도록 함]
>자유공간리스트	
- [사용전 메모리나 사용이 끝난 메모리를 관리하기위해 노드로 구성하여 연결한 리스트
- 공백노드를 가져오는 메모리 할당, 삭제연산시에 메모리 반환을 할 수있게 한다 (사용가능한 빈 공간)
- 메모리 할당/반환 시에는 항상 자유공간리스트의 제일 앞단에서부터 할당/반환이 이루어진다]

>첫번째 노드로삽입	
- [new<-getNode( ); new.data<-값; new.link<-리스트첫노드주소; 리스트<-new; ]
>중간노드로 삽입		
- pre.link(삽입위치 앞 노드)를 찾아서 위 와 같이 연결
				리스트가 값이 없을때 첫번째로 삽입후 링크에 null 삽입]
>마지막노드로 삽입	
- [last.link(마지막 노드)를 찾아서 연결후 링크에 null 삽입]
>노드 삭제 			
- [삭제할 노드의 앞노드의 링크필드값을 바꿔주고 삭제한 노드는 Null 값]

- 7주차 / 연결자료구조-2
>원형연결리스트		
- [마지막 노드의 링크필드가 첫번째 노드를 가리켜서 원형구조를 만든 연결 리스트, 게속 순회할 수 있다]
>원형리스트삽입		
- [원형리스트가 공백일때 -> 새로운 노드를 삽입해서 자기자신과 연결
- 원형리스트가 공백이 아닐 때 -> 마지막 노드와 리스트명을 새로운 노드에 연결, 새로운노드를 첫노드에연결
- 중간 노드로 삽입할때 -> 삽입할 노드를 중간 위치의 앞과 뒷 노드에 연결
>원형리스트삭제		
- [첫번째 노드 삭제할 때 -> 리스트명,마지막노드를 앞 노드에 연결]

>이중연결 리스트		
- [양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트/ 두개의 링크필드와 한개의 데이터필드로 구성
- llink 필드 : 왼쪽노드와 연결하는 포인터
- rlink 필드 : 오른쪽 노드와 연결하는 포인터
- 원형 이중 연결리스트 : 이중연결리스트를 원형으로 구성 null 값을 맨앞과 뒷 노드에 연결]
>이중연결리스트 삽입	
- [삽입할 노드에 2링크필드에 앞과 뒷 노드의 주소입력, 앞과 뒷노드의 링크필드에 삽입할 노드의 주소입력]
>이중연결리스트 삭제	
- [삭제할 노드의 뒷노드와 앞노드를 연결, 삭제할 노드 자유공간리스트에 반환]

>다항식 연결자료구조	
- [노드구조 : 각 항에 (a)계수, coef   (x)지수, expo 를 저장하는 두개의 데이터필드 와 링크필드로 구성]
>다항식자료구조삽입,삭제	
- [다른 자료구조와 같은 개념으로 서로를 연결하거나 연결을해제 하면 된다]
>다항식자료구조연산	
- [A(x) + B(x) = C(x), A(x)를 가리키는p, B(x)를 가리키는 q를 앞노드 부터 순차적으로 비교 
- 높은 지수를 C(x)의 포인터r 에 저장하고 포인터 이동, 작은 지수를 가리키는 포인터는 대기
- 같은 지수일 경우 계수를 더해서 저장]

# 8주차 / 스택
>스택				
- [자료를 차곡차곡 쌓아 올린 형태의 자료구조, 후입선출 구조(LIFO), (A.insert(0,x) del A[0])]
>스택의 연산		
- [push : 쌓기(삽입), pop : 꺼내기(삭제)]
>스택의 장단점		
- [1차원 배열로 쉽게 구현
- 크기가 고정된 배열을 사용해서 크기변경 어려움, 메모리낭비(순차자료의단점)]

>스택의 응용		
- [역순 문자열 만들기 : 문자열을 차례로 스택에 넣었다가 다시 꺼내면 마지막 문자열부터 반환
- 시스템 스택 : 프로그램에서의 호출과 복귀에 따른 수행 순서를 관리
	- 함수A내 함수B를 호출했을때 A는 멈추고 실행정보를 스택프레임에 저장 B가 끝나면 A를 불러와서 실행]

>수식의 표기법		
- [전위 표기법: +ab , 중위 표기법: a+b , 후위 표기법: ab+]
>스택을 이용한 수식변환	
- [문자열을 하나씩 검사해서 연산자를 스택에 저장 원하느 위치에  pop해서 저장한다]
				


# 큐(Queue)
- 선입선출(FIFO,first-in-first-out)
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한되어있는 유한순서리스트

- Queue 연산과정
```py
createQue() # 공백 큐를 생성
# 공백임을 명시하기 위해 -1을 대입
enQueue(Q,item) # 큐의 rear에 원소 삽입
isEmpty(Q)  # 큐가 공백인지 아닌지확인
deQueue(Q)  # 큐의 front의 원소를 삭제,반환
# front의 위치(인덱스)를 +1해서 변경한다 
# [0]  [1]  [2]
# 삭제->front rear
```
## 선형 큐
- 1차원 배열을 이용한 큐
    - 큐의크기 : 배열의 크기
    - front : 저장된 첫 원소의 인덱스
    - rear : 저장된 마지막 원소의 인덱스
- 상태 표현
    - 초기: front = rear = -1
    - 공백: front =  rear
    - 포화: rear = n-1 (n:배열의 길이) 

## 원형 큐
- 원형 큐의 필요성
    - 선형 큐에서는 삭제를 통해서 front를 뒤로 이동하기 때문에 공간이 있음에도 포화상태가 된다
    - 삭제 할때 마다 이동이 아닌 원소를 앞으로 옮기면 오버헤드가 커서 큐의 효율성이 떨어진다
- 원형큐의 구조
    - 1차원 배열의 처음과 끝이 ***논리적으로 연결되어 있다고 가정***하고 사용 -> 원형 큐
    - 리스트의 마지막 노드에서 ***논리적*** 다음 노드(0변인덱스) 이동을 위해 *리스트의 길이값으로 나머지연산*을 사용, 링크필드를 통해 다음 노드와 연결한 구조의 연결 리스트
        - 2 mod 3 = 2, 5 mod 3 = 2 / 다른 인덱스지만 나머지연산하면 원형 큐를 순환한 것 처럼 같은 인덱스를 가르킨다
    - ***실제로 순환 구조인 것이 아니라 나머지 연산을 통해서 다시 처음 노드의 인덱스로 돌아가는 구조***
- 상태 표현
    - 초기 공백 : front = rear = 0
    - 포화 상태 : front = rear+1
    - 삽입 위치 : (rear+1)mod n
    - 삭제 위치 : (front+1)mod n
    - 공백구분(front=rear)을 위해 front가 있는 자리는 항상 빈자리로 둔다

## 연결 큐
- 단순 연결리스트를 이용한 큐의 구조
    - 큐의 원소 : 연결리스트의 노드
    - 원소의 순서 : 노드의 링크포인터로 연결
    - front : 첫번째 노드를 가리키는 포인터 변수
    - rear : 마지막 노드를 가리키는 포인터 변수
    - 초기, 공백상태 : front = rear = null

# 트리(Tree)
## 10-1 학습내용
- 트리의 개념 
- 이진트리의 개념
### ***계층적 구조, 비선형적 구조***
- 하나의 원소가 복수의 원소로 연결되는 비선형 자료구조
- 원소들 간의 계층관계를 가지는 계층형자료구조 
- 부모-자식관계의 원소를 연결한다
- 같은 계층레벨(형제)끼리는 연결하지않는다

### 트리 구조와 구성요소
- 노드(Node) : 트리의 원소
- 루트 노드(Root Node) : 트리의 시작 노드
- 간선(Edge) : 노드를 연결하는 선
- 형제노드(Sibling Node) : 같은 부모노드에 연결된 자식노드
- 조상노드 : 간선을 따라 루트노드까지 이르느 경로에 있는 모든 노드
- 차수(Degree) : 한 노드가 가지는 서브 트리의 수(자식노드의 수)
    - 트리의 차수 : 트리의 있는 노드의 차수 중에서 가장 큰 값
    - 단말 노드(Leaf Node) : 차수가 0인 노드
- 높이(Height) 
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수
    - 트리의 높이 : 트리의 있는 노드의 높이 중 가장 큰 값
- 포리스트(Forest) : 서브 트리의 집합

### **이진 트리**
- 트리의 모든 노드의 차수를 2 이하가 되도록 정의 한 트리
- 값이 없는 공백 노드도 자식 노드로 취급
- 0 <= 노드의 차수 <= 2
- 특성
    - n개의 노드와 n-1개의 간선을 가진다
    - 높이(계층레벨)가 h일때 노드의 최소개수는 h+1, 최대개수는 2**(h+1)-1이다

## 10-2 학습내용
- 이진 트리의 종류
- 순차자료구조를 이용한 이진 트리 구현
- 연결자료구조를 이용한 이진 트리 구현

### 이진트리의 분류
- 레벨,노드 수와의 관계에 따라 분류된다
- 포화 이진 트리
- 완전 이진 트리
- 편향 이진 트리

> ### *포화 이진 트리(Full Binary Tree)*
- 모든 레벨에 노드가 포화 상태로 가득 차 최대노드개수를 가진 이진 트리

> ### *완전 이진 트리(Complete Binary Tree)*
- 루트 노드(1)부터 n노드까지 빈자리가 없는 이진 트리
- 왼쪽 부터 하나씩 순차로 세었을 때 빈자리가 없어야 한다(끝에는 없어도 된다는 뜻)

> ### *편향 이진트리(Skewed Binary Tree)*
- 최소 노드개수를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
- 왼쪽 편향 이진트리, 오른쪽 편향 이진 트리

### 순차자료구조를 이용한 이진트리 구현
- 완전 이진트리
    - 노드의 번호를 배열의 인덱스로 사용
    - [0]는 비워둔다 [1]에 루트노드 저장
- 편향 이진트리
    - 실제로 있는 노드외에 공백 노드들의 인덱스는 전부 비워둔다
- 공식
    - 노드 i의 부모노드 
        - i/2(나머지를 뺸 값)
        - 성립조건 : i > 1
    - 노드 i왼쪽 자식 노드
        -  2 * i
        - 성립조건 : (2 * i) <= n(노드개수)
    - 노드 i의 오른쪽 자식노드
        - 2 * i + 1
        - 성립조건 : (2 * i + 1) <= n(노드개수)

- 단점
    - 편향 이진 트리의 경우 사용하지 않는 배열 원소에 대한 메모리 공간 낭비
    - 트리의 원소 삽입/삭제에 대한 배열의 크기 변경 어려움

### 연결자료구조를 이용한 이진 트리 구현
- 단순연결자료구조를 사용하여 구현
    - 하나의 데이터 필드에 값을 저장 
    - 두개의 링크필드에 자식노드의 주소값을 저장
    - 공백노드는 링크필드에 null값을 대입

## 10-3 학습내용
- 이진 트리의 순회
- 전위 순회
- 중위 순회
- 후위 순회

> ### 이진트리의 순회
- 계층적 구조로 저장되어있는 트리의 모든 노드를 방문하여 데이터를 처리하는 연산
- 순회를 위해 수행할 수 있는 작업
    - 현재 노드를 방문해서 값 읽기 : D
    - 현재 노드의 왼쪽 서브트리로 이동 : L
    - 현재 노드의 오른쪽 서브트리로 이동 : R
- 왼쪽 서브트리에 대한 순회를 먼저 수행한다
- 순회의 종류
    - 전위 순회 
    - 중위 순회 
    - 후위 순회 

> 전위 순회(Preorder traversal)
- D - L - R 순서로 재귀함수 처럼 새로운 노드로 이동하면 해당노드에서 재실행된다
- 왼쪽서브트리에서 다시 실행, 왼쪽이 끝나면 오른쪽 이동
- 수식을 이진트리로 구성한 수식 이진트리로 전위 순회하면, ***수식에 대한 전위 표기식을 구할 수 있다***
    - ((A*B) - (C/D)) -> -*AB/CD

> 중위 순회(Inorder traversal)
- L - D - R 순서로 서브트리에서 재귀실행된다
- 왼쪽 단말노드 나올때까지 L명령이 실행되고 단말노드에서 D가 첫 실행됨

> 후위 순회(Postorder traversal)
- L - R - D 순서로 재실행된다
- 루트노드의 값을 마지막에 읽는다
- - 수식을 이진트리로 구성한 수식 이진트리로 후위 순회하면, ***수식에 대한 후위 표기식을 구할 수 있다***
    - ((A*B) - (C/D)) -> AB*CD/-

## 11-1 학습내용
- 이진 탐색 트리의 개념
- 이진 탐색 트리의 탐색 연산
- 이진 탐색 트리의 삽입 연산

> 이진 탐색 트리 (Binary search tree)
- 이진 트리에 탐색을 위한 조건을 추가하여 정의한 자료 구조

**이진 탐색 트리**
- 정의
    - 모든 원소는 서로 다른 유일한 키를 갖는다
    - 왼쪽 서브트리에 있는 원소의 키들은 그 루트의 키보다 작다
    - 오른쪽 서브트리에 있는 원소의 키들은 그 루트의 보다 크다
    - 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다
- 탐색 순서
    - 루트에서 시작
    - 탐색할 키값과 노드값 비교
    - 같은경우 연산성공, 노드값이 보다 크면 왼쪽 보다 작으면 오른쪽으로 이동
    - 서브트리에 대해서 순환적으로 탐색연산 반복
- 삽입 연산 순서
    - 탐색 연산 수행
        - 같은 원소가 있으면 끝
        - 없어서 탐색에 실패한 위치가 삽입위치
    - 탐색을 실패한 위치에 원소를 삽입

## 11-2 학습내용
- 이진 탐색 트리의 삭제 연산
- 이진 탐색 트리 프로그램

## 이진 탐색 트리 삭제 연산
- 삭제 연산 순서
    - 트리를 탐색
    - 찾은 노드를 삭제
        - 삭제후에도 탐색 트리를 유지해야 하므로 삭제 노드에 대한 후속 처리필요(이진 탐색트리의 재구성 작업)
    - 재구성 작업
        - 차수가 0인 경우 : 삭제할 노드가 단말노드
            -  노드를  삭제만 하면 된다
        - 차수가 1인 경우 : 삭제한 노드가 하나의 자식노드를 가짐
            - 연결이 끊어져 고아가 됨
            - 삭제한 부모노드의 자리를 자식노드가 갖는다
        - 차수가 2인 경우 : 삭제할 노드가 두 개의 자식노드를 가짐
            - 연결이 끊어져 고아가 됨
            - 부모 노드 자리를 *전체 자식 노드* 중 선택한 후계자에게 물려줌
            - 후계자로 선택된 자식 노드의 키값은 왼쪽 서브트리의 값보다 크고 오른쪽서브트리의 값보다 작아야한다 
            - 따라서 왼쪽 서브트리에서 가장 큰값(단말노드)이나 오른쪽 서브트리에서 가장 작은 값(단말노드)중 하나가 부모 노드의 자리를 갖는다

## 11-3 학습내용
- 힙(heap)의 개념
- 힙의 삽입, 삭제 연산

> 힙(heap) 이란
- 완전 이진트리이다
- 노드 중에서 키 값이 가장 큰 노드, 기값이 가장 작은 노드를 찾기 위해 만든 자료구조

## 힙(heap)

- 최대 힙(일반적인 힙)
    - 키값이 가장큰 노드를 찾기위한 완전 이진 트리
    - {부모노드의 키값 >= 자식노드의 카값}        
    - 루트노드 : 키값이 가장 큰 노드
- 최소 힙
    - 키값이 가장 작은 노드를 찾기위한 완전이진 트리
    - {부모노드의 키값 <= 자식노드의 키값}
    - 루트노드: 키값이 가장 작은 노드
 
- 삽입연산
    - 트리를 유지하면서 노드를 추가(n+1)해서 삽입할 원소를 임시저장
    - 만들어진 완전 이진 트리내에서 삽입원소의 제자리를 찾음
        - 부모노드와 크기 비교
        - 부모노드 키값이 작거나 같으면 원소의 자리를 서로 바꿈

- 삭제연산
    - 루트노드의 원소를 삭제
    - 노드의 수를 n-1인 완전이진트리로 조정
        - 마지막 노드(n번)를 삭제하고 원소를 루트노드에 임시저장
    - 루트에 저장된 원소의 제자리 찾기
        - 키 값이 더 큰 자식 노드와 크기 비교
        - 자식 노드의 원소가 크면 자리를 바꿈

# 12-1 학습내용
- 그래프의 개요, 종류, 관련용어
- 추상자료형

## 그래프
- 선형자료구조나 트리로 표현하기 어려운 다수 대 다수 의관계를 표현하는 자료구조
- 그래프G = (정점V, 간선E)

- 그래프의 종류
    1. 무방향 그래프
        - 간선의 방향이 없는 그래프
        - 간선(a, b) = (b, a) 이다

    2. 방향 그래프
        - 간선이 방향을 가지는 그래프 (a->b)
        - 간선(a, b) != (b, a) 이다
    
    3. 완전 그래프
        - 각 정점에서 다른 모든 정점을 연결하여 최대 간선 수를 가진 그래프
        - 정점이 n개이면
            - 무방향 완전그래프의 간선 : n(n-1)/2
            - 방향 완전그래프의 간선 : n(n-1)
    
    4. 부분 그래프
        - 원래 그래프에서 일부 정점이나 간선을 제외하여 만든 그래프
        - 부분집합의 개념
    
    5. 가중 그래프 또는 네트워크
        - 정점을 연결한 간선이 가중치를 가지는 그래프

- 그래프 관련 용어
    - 인접 : 간선으로 연결된 정점은 인접
    - 부속 : 정점을 연결한 간선은 부속
    - 차수 : 정점에 부속된 간선의 수
        - 방향그래프는 진입+진출 
    - 경로 : 간선을 연결해서 나열한 것
        - 경로길이 : 간선의 수
        - 단순경로 : 모두 다른정점으로 구성된 경로
    - 사이클 : 단순경로 중 시작과 끝의 정점이 같은 경로
        - DAG(Directed Acycle Graph) : 방향그래프 이면서 사이클이 없는 그래프(순환이 없음)
    - 연결그래프 : 모든 쌍의 정점들 사이에 경로가 있는 그래프, 모든 정점이 연결된 그래프
        - 트리는 순환이 없는 연결 그래프
        - 단절 그래프 : 연결되지 않은 정점이 있는 그래프

# 12-2 학습내용
- 인접 행렬
- 인접 리스트
- 그래프 순회(깊이 우선 탐색)

### 인접 행렬(Adjacent Matrix)
- 그래프를 2차원 배열을 사용해 표현한 것
- 표현 방법
    - 두 정점을 연결한 간선의 유무(0,1)을 행렬로 저장
    - 행과 열은 정점
    - 정점끼리 인접되어있으면 1, else 0
    - 무방향 그래프
        - 행(열) 인접값의 합 = 정점의 차수
        - 반사 행렬
    - 방향 그래프
        - 행 인접값의 합 = 정점 진출차수
        - 열 인접값의 합 = 정점 진입차수

- 단점
    - n개의 정점을 가지는 그래프는 n * n 개의 메모리 사용
    - 정점의 개수에 비해 간선의 개수가 적은 희소 그래프에 대한 인접행렬은 메모리의 낭비가 발생한다

### 인접 리스트(Adjacent Lise)
- 각 정점에 대한 인접 정점들을 연결한 단순 연결 리스트
- 각 정점의 차수 만큼 노드를 연결
    - 인접 정점을 오름차순으로 연결

- 정점의 헤드 노드
    - 정점에 대한 리스트의 시작

-  (정점헤드노드)A - (인접노드)B - C -..

- 무방향 그래프
    - n개의 정점, e개의 간선일때
    - 헤드노드 배열의 크기: n
    - 연결한 노드 수 : 2e
    - 각 정점 헤드에 연결된 노드 : 정점의 차수

- 방향 그래프
    - 헤드노드 배열 크기 : n
    - 연결한 노드 수 : e
    - 각 정점 헤드에 연결되 노드수 : 정점의 진출 차수

### 그래프 순회
- 하나의 정점에서 모든 정점을 한번씩 방문하여 처리
- 깊이 우선 탐색
    - 시작 정점에서 경로의 끝까지 간다
    - 지나친 정점중 다른간선이 있는 정점으로 돌아온다
    - 방문하지 않은 정점으로 반복해서 실행

    - 스택을 이용한 구현
        - 정점개수길이의 배열에 방문 유무를 저장, boolean 배열
        - 방문한 정점을 스택에 차례대로 저장, boolean배열 정점 위치에 True값 저장
        - 인접한 정점의 배열값이 다 True면 스택에 pop연산후 인접 정점의 배열값 확인(False가 나올때까지)
        - 방문하지 않은 정점(False)이 있으면 다시 처음부터반복
        - 반복해서 스택에 값이 다 pop 되서 스택이 공백이 되면 탐색 종료

# 12-3 학습내용
- 그래프의 순회, 너비우선 탐색

### 그래프 순회
- 너비 우선 탐색
    - 인접한 정점을 모두 차례로 방문하고 나서 방문한 정점들에 차례로 이동후 반복

    - 큐을 이용한 구현
    - 정점개수길이의 배열에 방문 유무를 저장, boolean 배열
    - 방문한 정점을 큐에 차례대로 저장, boolean배열 정점 위치에 True 값 저장
    - 인접한 정점을 다 방문했으면 큐에 저장된 정점을 순차적으로 방문해서 반복
    - 공백 큐가 되면 탐색 종료

# 13-1 학습내용
- 정렬의 개념
- 선택 정렬

### 정렬
- 2개 이상의 자료를 오름차순이나 내림차순으로 재배열하는 것
- 키(key): 정렬할 때 기준이 되는 특정 값 (이름, 수정한 날짜, 크기)

- 방법
    - 비교식 정렬(Comparative sort)
        - 한번에 두개 씩 비교, 교환하는 방식의 방법
    
    - 분산식 정렬(Distrivutive sort)
        - 키 값을 기준으로 여러개의 부분집합으로 분해, 각 부분집합을 정렬해서 전체를 정렬하는 방식

- 정렬 장소
    - 내부 정렬(Internal sort)
        - 정렬할 자료를 메인 메모리(hdd,ssd)에 올려서 정렬하는 방식
        - 속도가 빠르지만 자료의 양이 메인메모리의 용량에 따라 제한된다

        - 정렬 방식
            - 교환 방식: 키를 비교, 교환 (선택, 버블, 퀵 정렬)
            - 삽입 방식: 키를 비교, 삽입 (삽입, 쉘 정렬)
            - 병합 방식: 키를 비교, 병합 (2-way, n-way 병합)
            - 분배 방식: 키를 구성하는 값을 부분집합에 분배(기수 정렬)
            - 선택 방식: 이진 트리로 정렬 (히프, 트리 정렬)
    
    - 외부 정렬(External sort)
        - 정렬할 자료를 보조 기억장치(hdd, ssd)에서 정렬하는 방식
        - 속도는 떨어지지만 대용량의 자료를 정렬 가능

        - 정렬 방식
            - 병합 방식: 파일을 부분 파일로 분리, 각각 내부 정렬방법으로 정렬해서 병합(2-way, n-way 병합)

### 선택 정렬(Selection sort)란
- 전체 원소들 중에서 기준 위치에 맞는 원소를 선택, 교환하는 방식
- 단계
    - 가장 작은 원소 찾아서 첫번 째 자리와 교환
    - 두번째, 세번째 계속 반복

- 알고리즘 분석
    - 메모리 사용 공간 : n개의 원소, n개의 메모리 사용
    - 비교횟수 : i번째 원소를 기준 n-i개의 원소 비교 (n(n-1)/2)
    - 시간 복잡도 : O(n**2)

    - 정렬이 전혀 안된 자료를 정렬할 때 유리하다


# 13-2 학습내용 
- 버블 정렬


### 버블정렬
- 인접한 두개의 원소를 비교하여 자리를 교환하는 방식
- 오름차순으로 정렬하면 가장큰 원소가 마지막 자리로 정렬되면 비교연산의 한 턴이 끝난다
    - 전체 비교를 리스트의 길이-1만큼 반복 실행해야 한다

- 알고리즘 분석
    - 메모리 사용공간
        - n개의 원소에 대하여 n개의 메모리 사용
    
    - 연산 시간
        - 최선의 경우: 정렬이 되있는 경우
            - 비교횟수 : n(n-1)/2 번
            - 자리교환 : 없음
        
        - 최악의 경우: 자료가 역순으로 정렬되있는 경우
            - 비교횟수: n(n-1)/2 번
            - 자리교환: n(n-1)/2 번
        
        - 시간 복잡도 O(n**2)
    
    - 어느정도 정렬이 되있는 경우 선택 정렬보다 유리하다

# 13-3 학습내용
- 퀵 정렬 개념, 수행방법, 알고리즘


### 퀵 정렬
- 기준 값과 비교해서 왼쪽 부분집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법
    - 기준 값(pivot) : 일반적으로 가운데 위치한 원소를 선택

- 분할 : 기준값을 중심으로 2개의 부분집합으로 분할
- 정복 
    - 비교해서 작은 값은 왼쪽 큰값을 오른쪽으로 정렬
    - 부분 집합의 크기가 1이하가 될때 까지 순환호출해서 분할

- 수행방법
    - 배열의 시작과 끝을 가리키는 L, R
    - L,R이 한 노드씩 움직이면서 피봇과 비교, L은 크거나 같은 원소 R은 작은 원소를 찾으면 멈추고 둘다 찾으면 서로 교환한다 
    - L,R둘다 같은 원소를 가리키면 피봇값과 위치를 교환 하고 피봇값을 빼고 좌우로 부분 집합을 나눈다
    - 반복 수행

- 메모리 사용공간 : n개의 원소에 대해 n개의 메모리 사용
- 연산시간 
    - 최선 : 이미 정렬된 자료 
    - 최악 : 역순으로 정렬된 자료

- 시간 복잡도 : O(nlog2n)
    - 같은 시간 복잡도를 가지는 다른 정렬 방법에 비해 교환 횟수를 줄여서 더 빠르다


# 14-1 학습내용
- 검색의 개념
- 정렬된 순차자료, 비정렬 순차자료에서의 순차 검색
- 색인 순차 검색

### 검색(Search)
- 저장된 자료를 찾는 작업
    - 탐색 키(Search Key)를 가진 항목을 찾는 것
    - 삽입/삭제 작업에서의 검색

- 검색 방법
    - 수행 위치
        - 내부 검색: 메모리 내의 자료에 대해서 검색
        - 외부 검색: 보조 기억 장치에 있는 자료에 대해 검색
    
    - 검색 방식
        - 비교 검색방식(Comparison search method)
            - 대상의 키를 비교하여 검색(순차, 이진, 트리)
        
        - 계산 검색방식(non-comparison search method)
            - 계수적인 성질을 이용해서 검색(해싱)
        
        - 자료구조 형태와 배열 상태에 따라서 최적의 검색 방법 선택

### 순차 검색(Sequential search)
- 정렬되지않은 자료 순차 검색
    - 선형 검색이라고도 한다
    - 일렬로 된 자료를 처음부터 끝까지 순서대로 검색
    - 자료 양이 많으면 비효율적이다
    - 평균 시간 복잡도 : O(n)

- 정렬된 자료 순차 검색
    -  키 값의 크기를 원소와 순차비교, 찾는 값보다 큰 값이 나오면 검색 종료
    - 평균 시간 복잡도 : O(n)

### 색인 순차 검색(Index sequential search)
- 정렬된 자료에 대한 인덱스 테이블(index table)을 추가로 사용해서 탐색 효율을 높인 검색
    - 인덱스 테이블 
        - 일정한 간격으로 분리(예:50/2)해서 분리된 첫 인덱스를 테이블에 저장
        - 2차원 배열에 [0]인덱스와 [1]키값을 저장
- 검색 방법
    - 각 인덱스 테이블의 값을 키 값과 비교, 어느 테이블에 있는지 찾는다
    - 시간 복잡도 : O(m + n/m)
        - 테이블의 크기가 커지면 검색범위는 작아지지만 테이블을 검색하는 시간이 늘어난다



# 14-2 학습내용
- 이진검색
- 이진트리검색

### 이진 검색(Binary search)
- 이분 검색, 보간 검색(Interpolation search)라고도 한다
- 자료의 가운데이 있는 항목을 키값과 비교 다음 검색 위치를 결정하여 검색을 반복
    - 키값보다 작으면 오른쪽검색, 크면 왼쪽 검색

- 정복기법을 이용한 검색 방법
    - 검색 범위를 바능로 분할하는 작업과 검색 작업을 반복 수행

- 시간 복잡도 : O(log2n)

### 이진 트리 검색(Binary tree search)
- 이진 탐색 트리를 사용한 검색 방법 (전위, 중위, 후위)
- 삽입,삭제 연산중 재구성이 필요
- 시간 복잡도 : O(log2n)


# 14-3 학습내용
- 해싱, 해싱함수
- 오버플로우 처리


### 해싱(Hashing)
- 산술적 연산을 이용, 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식
- 방법
    - 키 값의 해싱함수를 계산, 주소를 구한다
    - 주소의 해시 테이블로 이동
    - 찾는 값이 있으면 성공, 없으면 실패

- 해싱 함수(Hashing Function)
    - 키 값을 원소의 위치로 변환하는 함수

- 해싱 테이블(Hashing Table)
    - 해싱 함수에 의해서 계산된 주소의 위치에 항목을 저장한 표

- 해싱 용어
    - 충돌(Collision)
        - 서로 다른 키 값을 해싱함수에 넣었을 때 같은 버킷주소를 반환하는경우
        - 충돌이 발생한 경우 비어있는 슬롯에 동거자 관계로 키 값 저장

    - 동거자(Synonym)
        - 서로 다른 키 값을 가지지만 같은 버킷에 저장된 키 값들
    
    - 오버 플로우(Overflow)
        - 버킷에 비어있는 슬롯이 없는 포화 버킷 상태에서 충돌이 발생, 저장할 수 없는 상태
    
    - 키 값 밀도
        - 현재 해시 테이블에 저장되어서 실제 사용되고있는 키 값의 밀도
        - 키값 밀도 = 실제 사용중인 키값/사용가능한 키값
        
    - 적재 밀도
        - 해시테이블에 저장 가능한 키 값의 개수 중 현재 해시 테이블에 저장되어 실제 사용되고 있는 키 값의 밀도
        - 적재 밀도 = 실제 사용중인 키값/해시테이블전체 키값의 개수
        - = 실제사용중 키값/(버킷 개수*슬롯 개수)

### 해싱 함수
- 조건
    - 계산이 쉬워야 한다
        - 비교 연산보다 해싱 함수의 연산시간이 빨라야 해싱 검색을 사용하는 의미가 있음
    
    - 해싱 함수는 충돌이 적어야한다
        - 충돌이 많으면 같은 버킷을 할당 받는 키값이 많다는 뜻, 좋은해싱함수가 아니다

- 해싱 함수의 종류
    - 중간 제곱 함수
        - 키 값을 제곱한 결과 값에서 중간에 있는 적당한비트를 주소로 사용
        - 00011011**00111010**11001101 중간 값을 해시주소로 활용
    
    - 제산 함수
        - 나머지 연산자를 사용하는 방법
        - 키값을 해시테이블의 크기로 나눈 나머지를 주소로 사용
        - 해시 테이블의 크기는 적당한 크기의 소수(prime number)사용

    - 승산 함수 
        - 곱하기 연산을 사용하는 방법
        - 키 값에 정해진 실수를 곱한 결과에서 소수점이하 부분에 테이블 크기를 곱하여 정수값을 주소로 사용
    
    - 접지 함수
        - 끝자리가 같도록 키 값을 잘라서 더하는 방법
        - 12312312312 -> 123 123 123 12 -> 381

    - 경계 접지 함수
        - 끝자리가 같도록 키 값을 자르고 서로 마주보도록 배치한후 더하는 방법
        - 12312312312 -> 123 321 123 21 -> 588
    
    - 숫자 분석 함수
        - 키값을 이루고 있는 각 자릿수의 분포를 분속하여 해시 주소로 사용하는 방법
            - 각 키값을 적절한 진수로 변환한 후 각 자릿수의 분포를 분석
            - 가장 고르게 분포된 자릿수를 해시 테이블 자릿수 만큼 뽑는다
            - 뽑힌 수를 역순으로 바꿔서 주소로 사용
    
### 오버 플로우 처리 방법
- 선형 개방 주소법
    - 선형 조사법(Linear probing)이라고도 함
        - 해싱 함수로 구한 버킷에 빈 슬롯이 없어서 오버플로우가 발생
        - 그 다음 버킷이 빈슬롯인지 조사
        - 빈 슬롯이 있으면 키 값을 저장, 없으면 다시 다음버킷 조사
        - 이런 과정 되풀이 비어있는 슬롯을 순차적으로 찾아서 사용해서 오버플로우 해결

- 체이닝(Chaining),(보편적으로쓰임)
    - 해시 테이블의 구조를 변경하여 각 버킷에 하나 이상의 키 값을 저장할 수 있도록 하는 방법
    - 버킷에 슬롯을 동적으로 삽입하고 삭제하기 위해서 연결 리스트 사용
        - 각 버킷에 대한 헤드노드를 1차원 배열로 만들어서 값을 append하거나 del한다
        - 버킷 내에서 원하는 슬롯 검색을 위해 연결 리스트 선형검색을 한다

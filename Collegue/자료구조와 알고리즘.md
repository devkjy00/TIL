# 큐(Queue)
- 선입선출(FIFO,first-in-first-out)
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한되어있는 유한순서리스트

- Queue 연산과정
```py
createQue() # 공백 큐를 생성
# 공백임을 명시하기 위해 -1을 대입
enQueue(Q,item) # 큐의 rear에 원소 삽입
isEmpty(Q)  # 큐가 공백인지 아닌지확인
deQueue(Q)  # 큐의 front의 원소를 삭제,반환
# front의 위치(인덱스)를 +1해서 변경한다 
# [0]  [1]  [2]
# 삭제->front rear
```
## 선형 큐
- 1차원 배열을 이용한 큐
    - 큐의크기 : 배열의 크기
    - front : 저장된 첫 원소의 인덱스
    - rear : 저장된 마지막 원소의 인덱스
- 상태 표현
    - 초기: front = rear = -1
    - 공백: front = rear
    - 포화: rear = n-1 (n:배열의 길이) 

## 원형 큐
- 원형 큐의 필요성
    - 선형 큐에서는 삭제를 통해서 front를 뒤로 이동하기 때문에 공간이 있음에도 포화상태가 된다
    - 삭제 할때 마다 이동이 아닌 원소를 앞으로 옮기면 오버헤드가 커서 큐의 효율성이 떨어진다
- 원형큐의 구조
    - 1차원 배열의 처음과 끝이 ***논리적으로 연결되어 있다고 가정***하고 사용 -> 원형 큐
    - 리스트의 마지막 노드에서 ***논리적*** 다음 노드(0변인덱스) 이동을 위해 *리스트의 길이값으로 나머지연산*을 사용, 링크필드를 통해 다음 노드와 연결한 구조의 연결 리스트
        - 2 mod 3 = 2, 5 mod 3 = 2 / 다른 인덱스지만 나머지연산하면 원형 큐를 순환한 것 처럼 같은 인덱스를 가르킨다
    - ***실제로 순환 구조인 것이 아니라 나머지 연산을 통해서 다시 처음 노드의 인덱스로 돌아가는 구조***
- 상태 표현
    - 초기 공백 : front = rear = 0
    - 포화 상태 : front = rear+1
    - 삽입 위치 : (rear+1)mod n
    - 삭제 위치 : (front+1)mod n
    - 공백구분(front=rear)을 위해 front가 있는 자리는 항상 빈자리로 둔다

## 연결 큐
- 단순 연결리스트를 이용한 큐의 구조
    - 큐의 원소 : 연결리스트의 노드
    - 원소의 순서 : 노드의 링크포인터로 연결
    - front : 첫번째 노드를 가리키는 포인터 변수
    - rear : 마지막 노드를 가리키는 포인터 변수
    - 초기, 공백상태 : front = rear = null

# 트리(Tree)
## 10-1 학습내용
- 트리의 개념 
- 이진트리의 개념
### ***계층적 구조, 비선형적 구조***
- 하나의 원소가 복수의 원소로 연결되는 비선형 자료구조
- 원소들 간의 계층관계를 가지는 계층형자료구조 
- 부모-자식관계의 원소를 연결한다
- 같은 계층레벨(형제)끼리는 연결하지않는다

### 트리 구조와 구성요소
- 노드(Node) : 트리의 원소
- 루트 노드(Root Node) : 트리의 시작 노드
- 간선(Edge) : 노드를 연결하는 선
- 형제노드(Sibling Node) : 같은 부모노드에 연결된 자식노드
- 조상노드 : 간선을 따라 루트노드까지 이르느 경로에 있는 모든 노드
- 차수(Degree) : 한 노드가 가지는 서브 트리의 수(자식노드의 수)
    - 트리의 차수 : 트리의 있는 노드의 차수 중에서 가장 큰 값
    - 단말 노드(Leaf Node) : 차수가 0인 노드
- 높이(Height) 
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수
    - 트리의 높이 : 트리의 있는 노드의 높이 중 가장 큰 값
- 포리스트(Forest) : 서브 트리의 집합

### **이진 트리**
- 트리의 모든 노드의 차수를 2 이하가 되도록 정의 한 트리
- 값이 없는 공백 노드도 자식 노드로 취급
- 0 <= 노드의 차수 >= 2
- 특성
    - n개의 노드와 n-1개의 간선을 가진다
    - 높이(계층레벨)가 h일때 노드의 최소개수는 h+1, 최대개수는 2**(h+1)-1이다

## 10-2 학습내용
- 이진 트리의 종류
- 순차자료구조를 이용한 이진 트리 구현
- 연결자료구조를 이용한 이진 트리 구현

### 이진트리의 분류
- 레벨,노드 수와의 관계에 따라 분류된다
- 포화 이진 트리
- 완전 이진 트리
- 편향 이진 트리

> ### *포화 이진 트리(Full Binary Tree)*
- 모든 레벨에 노드가 포화 상태로 가득 차 최대노드개수를 가진 이진 트리

> ### *완전 이진 트리(Complete Binary Tree)*
- 루트 노드(1)부터 n노드까지 빈자리가 없는 이진 트리
- 왼쪽 부터 하나씩 순차로 세었을 때 빈자리가 없어야 한다(끝에는 없어도 된다는 뜻)

> ### *편향 이진트리(Skewed Binary Tree)*
- 최소 노드개수를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
- 왼쪽 편향 이진트리, 오른쪽 편향 이진 트리

### 순차자료구조를 이용한 이진트리 구현
- 완전 이진트리
    - 노드의 번호를 배열의 인덱스로 사용
    - [0]는 비워둔다 [1]에 루트노드 저장
- 편향 이진트리
    - 실제로 있는 노드외에 공백 노드들의 인덱스는 전부 비워둔다
- 공식
    - 노드 i의 부모노드 
        - i/2(나머지를 뺸 값)
        - 성립조건 : i > 1
    - 노드 i왼쪽 자식 노드
        -  2 * i
        - 성립조건 : (2 * i) <= n(노드개수)
    - 노드 i의 오른쪽 자식노드
        - 2 * i + 1
        - 성립조건 : (2 * i + 1) <= n(노드개수)

- 단점
    - 편향 이진 트리의 경우 사용하지 않는 배열 원소에 대한 메모리 공간 낭비
    - 트리의 원소 삽입/삭제에 대한 배열의 크기 변경 어려움

### 연결자료구조를 이용한 이진 트리 구현
- 단순연결자료구조를 사용하여 구현
    - 하나의 데이터 필드에 값을 저장 
    - 두개의 링크필드에 자식노드의 주소값을 저장
    - 공백노드는 링크필드에 null값을 대입

## 10-3 학습내용
- 이진 트리의 순회
- 전위 순회
- 중위 순회
- 후위 순회

> ### 이진트리의 순회
- 계층적 구조로 저장되어있는 트리의 모든 노드를 방문하여 데이터를 처리하는 연산
- 순회를 위해 수행할 수 있는 작업
    - 현재 노드를 방문해서 값 읽기 : D
    - 현재 노드의 왼쪽 서브트리로 이동 : L
    - 현재 노드의 오른쪽 서브트리로 이동 : R
- 왼쪽 서브트리에 대한 순회를 먼저 수행한다
- 순회의 종류
    - 전위 순회 
    - 중위 순회 
    - 후위 순회 

> 전위 순회(Preorder traversal)
- D - L - R 순서로 재귀함수 처럼 새로운 노드로 이동하면 해당노드에서 재실행된다
- 왼쪽서브트리에서 다시 실행, 왼쪽이 끝나면 오른쪽 이동
- 수식을 이진트리로 구성한 수식 이진트리로 전위 순회하면, ***수식에 대한 전위 표기식을 구할 수 있다***
    - ((A*B) - (C/D)) -> -*AB/CD

> 중위 순회(Inorder traversal)
- L - D - R 순서로 서브트리에서 재귀실행된다
- 왼쪽 단말노드 나올때까지 L명령이 실행되고 단말노드에서 D가 첫 실행됨

> 후위 순회(Postorder traversal)
- L - R - D 순서로 재실행된다
- 루트노드의 값을 마지막에 읽는다
- - 수식을 이진트리로 구성한 수식 이진트리로 후위 순회하면, ***수식에 대한 후위 표기식을 구할 수 있다***
    - ((A*B) - (C/D)) -> AB*CD/-

## 11-1 학습내용
- 이진 탐색 트리의 개념
- 이진 탐색 트리의 탐색 연산
- 이진 탐색 트리의 삽입 연산

> 이진 탐색 트리 (Binary search tree)
- 이진 트리에 탐색을 위한 조건을 추가하여 정의한 자료 구조

**이진 탐색 트리**
- 정의
    - 모든 원소는 서로 다른 유일한 키를 갖는다
    - 왼쪽 서브트리에 있는 원소의 키들은 그 루트의 키보다 작다
    - 오른쪽 서브트리에 있는 원소의 키들은 그 루트의 보다 크다
    - 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다
- 탐색 순서
    - 루트에서 시작
    - 탐색할 키값과 노드값 비교
    - 같은경우 연산성공, 노드값이 보다 크면 왼쪽 보다 작으면 오른쪽으로 이동
    - 서브트리에 대해서 순환적으로 탐색연산 반복
- 삽입 연산 순서
    - 탐색 연산 수행
        - 같은 원소가 있으면 끝
        - 없어서 탐색에 실패한 위치가 삽입위치
    - 탐색을 실패한 위치에 원소를 삽입

## 11-2 학습내용
- 이진 탐색 트리의 삭제 연산
- 이진 탐색 트리 프로그램

## 이진 탐색 트리 삭제 연산
- 삭제 연산 순서
    - 트리를 탐색
    - 찾은 노드를 삭제
        - 삭제후에도 탐색 트리를 유지해야 하므로 삭제 노드에 대한 후속 처리필요(이진 탐색트리의 재구성 작업)
    - 재구성 작업
        - 차수가 0인 경우 : 삭제할 노드가 단말노드
            -  노드를  삭제만 하면 된다
        - 차수가 1인 경우 : 삭제한 노드가 하나의 자식노드를 가짐
            - 연결이 끊어져 고아가 됨
            - 삭제한 부모노드의 자리를 자식노드가 갖는다
        - 차수가 2인 경우 : 삭제할 노드가 두 개의 자식노드를 가짐
            - 연결이 끊어져 고아가 됨
            - 부모 노드 자리를 *전체 자식 노드* 중 선택한 후계자에게 물려줌
            - 후계자로 선택된 자식 노드의 키값은 왼쪽 서브트리의 값보다 크고 오른쪽서브트리의 값보다 작아야한다 
            - 따라서 왼쪽 서브트리에서 가장 큰값(단말노드)이나 오른쪽 서브트리에서 가장 작은 값(단말노드)중 하나가 부모 노드의 자리를 갖는다

## 11-3 학습내용
- 힙(heap)의 개념
- 힙의 삽입, 삭제 연산

> 힙(heap) 이란
- 완전 이진트리이다
- 노드 중에서 키 값이 가장 큰 노드, 기값이 가장 작은 노드를 찾기 위해 만든 자료구조

## 힙(heap)

- 최대 힙(일반적인 힙)
    - 키값이 가장큰 노드를 찾기위한 완전 이진 트리
    - {부모노드의 키값 >= 자식노드의 카값}        
    - 루트노드 : 키값이 가장 큰 노드
- 최소 힙
    - 키값이 가장 작은 노드를 찾기위한 완전이진 트리
    - {부모노드의 키값 <= 자식노드의 키값}
    - 루트노드: 키값이 가장 작은 노드
 
- 삽입연산
    - 트리를 유지하면서 노드를 추가(n+1)해서 삽입할 원소를 임시저장
    - 만들어진 완전 이진 트리내에서 삽입원소의 제자리를 찾음
        - 부모노드와 크기 비교
        - 부모노드 키값이 작거나 같으면 원소의 자리를 서로 바꿈

- 삭제연산
    - 루트노드의 원소를 삭제
    - 노드의 수를 n-1인 완전이진트리로 조정
        - 마지막 노드(n번)를 삭제하고 원소를 루트노드에 임시저장
    - 루트에 저장된 원소의 제자리 찾기
        - 키 값이 더 큰 자식 노드와 크기 비교
        - 자식 노드의 원소가 크면 자리를 바꿈

# 12-1 학습내용
- 그래프의 개요, 종류, 관련용어
- 추상자료형

## 그래프
- 선형자료구조나 트리로 표현하기 어려운 다수 대 다수 의관계를 표현하는 자료구조
- 그래프G = (정점V, 간선E)

- 그래프의 종류
    1. 무방향 그래프
        - 간선의 방향이 없는 그래프
        - 간선(a, b) = (b, a) 이다

    2. 방향 그래프
        - 간선이 방향을 가지는 그래프 (a->b)
        - 간선(a, b) != (b, a) 이다
    
    3. 완전 그래프
        - 각 정점에서 다른 모든 정점을 연결하여 최대 간선 수를 가진 그래프
        - 정점이 n개이면
            - 무방향 완전그래프의 간선 : n(n-1)/2
            - 방향 완전그래프의 간선 : n(n-1)
    
    4. 부분 그래프
        - 원래 그래프에서 일부 정점이나 간선을 제외하여 만든 그래프
        - 부분집합의 개념
    
    5. 가중 그래프 또는 네트워크
        - 정점을 연결한 간선이 가중치를 가지는 그래프

- 그래프 관련 용어
    - 인접 : 간선으로 연결된 정점은 인접
    - 부속 : 정점을 연결한 간선은 부속
    - 차수 : 정점에 부속된 간선의 수
        - 방향그래프는 진입+진출 
    - 경로 : 간선을 연결해서 나열한 것
        - 경로길이 : 간선의 수
        - 단순경로 : 모두 다른정점으로 구성된 경로
    - 사이클 : 단순경로 중 시작과 끝의 정점이 같은 경로
        - DAG(Directed Acycle Graph) : 방향그래프 이면서 사이클이 없는 그래프(순환이 없음)
    - 연결그래프 : 모든 쌍의 정점들 사이에 경로가 있는 그래프, 모든 정점이 연결된 그래프
        - 트리는 순환이 없는 연결 그래프
        - 단절 그래프 : 연결되지 않은 정점이 있는 그래프

# 12-2 학습내용
- 인접 행렬
- 인접 리스트
- 그래프 순회(깊이 우선 탐색)

### 인접 행렬(Adjacent Matrix)
- 그래프를 2차원 배열을 사용해 표현한 것
- 표현 방법
    - 두 정점을 연결한 간선의 유무(0,1)을 행렬로 저장
    - 행과 열은 정점
    - 정점끼리 인접되어있으면 1, else 0
    - 무방향 그래프
        - 행(열) 인접값의 합 = 정점의 차수
        - 반사 행렬
    - 방향 그래프
        - 행 인접값의 합 = 정점 진출차수
        - 열 인접값의 합 = 정점 진입차수

- 단점
    - n개의 정점을 가지는 그래프는 n * n 개의 메모리 사용
    - 정점의 개수에 비해 간선의 개수가 적은 희소 그래프에 대한 인접행렬은 메모리의 낭비가 발생한다

### 인접 리스트(Adjacent Lise)
- 각 정점에 대한 인접 정점들을 연결한 단순 연결 리스트
- 각 정점의 차수 만큼 노드를 연결
    - 인접 정점을 오름차순으로 연결

- 정점의 헤드 노드
    - 정점에 대한 리스트의 시작

-  (정점헤드노드)A - (인접노드)B - C -..

- 무방향 그래프
    - n개의 정점, e개의 간선일때
    - 헤드노드 배열의 크기: n
    - 연결한 노드 수 : 2e
    - 각 정점 헤드에 연결된 노드 : 정점의 차수

- 방향 그래프
    - 헤드노드 배열 크기 : n
    - 연결한 노드 수 : e
    - 각 정점 헤드에 연결되 노드수 : 정점의 진출 차수

### 그래프 순회
- 하나의 정점에서 모든 정점을 한번씩 방문하여 처리
- 깊이 우선 탐색
    - 시작 정점에서 경로의 끝까지 간다
    - 지나친 정점중 다른간선이 있는 정점으로 돌아온다
    - 방문하지 않은 정점으로 반복해서 실행

    - 스택을 이용한 구현
        - 정점개수길이의 배열에 방문 유무를 저장, boolean 배열
        - 방문한 정점을 스택에 차례대로 저장, boolean배열 정점 위치에 True값 저장
        - 인접한 정점의 배열값이 다 True면 스택에 pop연산후 인접 정점의 배열값 확인(False가 나올때까지)
        - 방문하지 않은 정점(False)이 있으면 다시 처음부터반복
        - 반복해서 스택에 값이 다 pop 되서 스택이 공백이 되면 탐색 종료

# 12-3 학습내용
- 그래프의 순회, 너비우선 탐색

### 그래프 순회
- 너비 우선 탐색
    - 인접한 정점을 모두 차례로 방문하고 나서 방문한 정점들에 차례로 이동후 반복

    - 큐을 이용한 구현
    - 정점개수길이의 배열에 방문 유무를 저장, boolean 배열
    - 방문한 정점을 큐에 차례대로 저장, boolean배열 정점 위치에 True 값 저장
    - 인접한 정점을 다 방문했으면 큐에 저장된 정점을 순차적으로 방문해서 반복
    - 공백 큐가 되면 탐색 종료

# 13-1 학습내용
- 정렬의 개념
- 선택 정렬

### 정렬
- 2개 이상의 자료를 오름차순이나 내림차순으로 재배열하는 것
- 키(key): 정렬할 때 기준이 되는 특정 값 (이름, 수정한 날짜, 크기)

- 방법
    - 비교식 정렬(Comparative sort)
        - 한번에 두개 씩 비교, 교환하는 방식의 방법
    
    - 분산식 정렬(Distrivutive sort)
        - 키 값을 기준으로 여러개의 부분집합으로 분해, 각 부분집합을 정렬해서 전체를 정렬하는 방식

- 정렬 장소
    - 내부 정렬(Internal sort)
        - 정렬할 자료를 메인 메모리(hdd,ssd)에 올려서 정렬하는 방식
        - 속도가 빠르지만 자료의 양이 메인메모리의 용량에 따라 제한된다

        - 정렬 방식
            - 교환 방식: 키를 비교, 교환 (선택, 버블, 퀵 정렬)
            - 삽입 방식: 키를 비교, 삽입 (삽입, 쉘 정렬)
            - 병합 방식: 키를 비교, 병합 (2-way, n-way 병합)
            - 분배 방식: 키를 구성하는 값을 부분집합에 분배(기수 정렬)
            - 선택 방식: 이진 트리로 정렬 (히프, 트리 정렬)
    
    - 외부 정렬(External sort)
        - 정렬할 자료를 보조 기억장치(hdd, ssd)에서 정렬하는 방식
        - 속도는 떨어지지만 대용량의 자료를 정렬 가능

        - 정렬 방식
            - 병합 방식: 파일을 부분 파일로 분리, 각각 내부 정렬방법으로 정렬해서 병합(2-way, n-way 병합)

### 선택 정렬(Selection sort)란
- 전체 원소들 중에서 기준 위치에 맞는 원소를 선택, 교환하는 방식
- 단계
    - 가장 작은 원소 찾아서 첫번 째 자리와 교환
    - 두번째, 세번째 계속 반복

- 알고리즘 분석
    - 메모리 사용 공간 : n개의 원소, n개의 메모리 사용
    - 비교횟수 : i번째 원소를 기준 n-i개의 원소 비교 (n(n-1)/2)
    - 시간 복잡도 : O(n**2)

    - 정렬이 전혀 안된 자료를 정렬할 때 유리하다


# 13-2 학습내용 
- 버블 정렬


### 버블정렬
- 인접한 두개의 원소를 비교하여 자리를 교환하는 방식
- 오름차순으로 정렬하면 가장큰 원소가 마지막 자리로 정렬되면 비교연산의 한 턴이 끝난다
    - 전체 비교를 리스트의 길이-1만큼 반복 실행해야 한다

- 알고리즘 분석
    - 메모리 사용공간
        - n개의 원소에 대하여 n개의 메모리 사용
    
    - 연산 시간
        - 최선의 경우: 정렬이 되있는 경우
            - 비교횟수 : n(n-1)/2 번
            - 자리교환 : 없음
        
        - 최악의 경우: 자료가 역순으로 정렬되있는 경우
            - 비교횟수: n(n-1)/2 번
            - 자리교환: n(n-1)/2 번
        
        - 시간 복잡도 O(n**2)
    
    - 어느정도 정렬이 되있는 경우 선택 정렬보다 유리하다

# 13-3 학습내용
- 퀵 정렬 개념, 수행방법, 알고리즘


### 퀵 정렬
- 기준 값과 비교해서 왼쪽 부분집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법
    - 기준 값(pivot) : 일반적으로 가운데 위치한 원소를 선택

- 분할 : 기준값을 중심으로 2개의 부분집합으로 분할
- 정복 
    - 비교해서 작은 값은 왼쪽 큰값을 오른쪽으로 정렬
    - 부분 집합의 크기가 1이하가 될때 까지 순환호출해서 분할

- 수행방법
    - 배열의 시작과 끝을 가리키는 L, R
    - L,R이 한 노드씩 움직이면서 피봇과 비교, L은 크거나 같은 원소 R은 작은 원소를 찾으면 멈추고 둘다 찾으면 서로 교환한다 
    - L,R둘다 같은 원소를 가리키면 피봇값과 위치를 교환 하고 피봇값을 빼고 좌우로 부분 집합을 나눈다
    - 반복 수행

- 메모리 사용공간 : n개의 원소에 대해 n개의 메모리 사용
- 연산시간 
    - 최선 : 이미 정렬된 자료 
    - 최악 : 역순으로 정렬된 자료

- 시간 복잡도 : O(nlog2n)
    - 같은 시간 복잡도를 가지는 다른 정렬 방법에 비해 교환 횟수를 줄여서 더 빠르다


# 14-1 학습내용
- 검색의 개념
- 정렬된 순차자료, 비정렬 순차자료에서의 순차 검색
- 색인 순차 검색

### 검색(Search)
- 저장된 자료를 찾는 작업
    - 탐색 키(Search Key)를 가진 항목을 찾는 것
    - 삽입/삭제 작업에서의 검색

- 검색 방법
    - 수행 위치
        - 내부 검색: 메모리 내의 자료에 대해서 검색
        - 외부 검색: 보조 기억 장치에 있는 자료에 대해 검색
    
    - 검색 방식
        - 비교 검색방식(Comparison search method)
            - 대상의 키를 비교하여 검색(순차, 이진, 트리)
        
        - 계산 검색방식(non-comparison search method)
            - 계수적인 성질을 이용해서 검색(해싱)
        
        - 자료구조 형태와 배열 상태에 따라서 최적의 검색 방법 선택

### 순차 검색(Sequential search)
- 정렬되지않은 자료 순차 검색
    - 선형 검색이라고도 한다
    - 일렬로 된 자료를 처음부터 끝까지 순서대로 검색
    - 자료 양이 많으면 비효율적이다
    - 평균 시간 복잡도 : O(n)

- 정렬된 자료 순차 검색
    -  키 값의 크기를 원소와 순차비교, 찾는 값보다 큰 값이 나오면 검색 종료
    - 평균 시간 복잡도 : O(n)

### 색인 순차 검색(Index sequential search)
- 정렬된 자료에 대한 인덱스 테이블(index table)을 추가로 사용해서 탐색 효율을 높인 검색
    - 인덱스 테이블 
        - 일정한 간격으로 분리(예:50/2)해서 분리된 첫 인덱스를 테이블에 저장
        - 2차원 배열에 [0]인덱스와 [1]키값을 저장
- 검색 방법
    - 각 인덱스 테이블의 값을 키 값과 비교, 어느 테이블에 있는지 찾는다
    - 시간 복잡도 : O(m + n/m)
        - 테이블의 크기가 커지면 검색범위는 작아지지만 테이블을 검색하는 시간이 늘어난다
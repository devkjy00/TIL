# 큐(Queue)
- 선입선출(FIFO,first-in-first-out)
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한되어있는 유한순서리스트

- Queue 연산과정
```py
createQue() # 공백 큐를 생성
# 공백임을 명시하기 위해 -1을 대입
enQueue(Q,item) # 큐의 rear에 원소 삽입
isEmpty(Q)  # 큐가 공백인지 아닌지확인
deQueue(Q)  # 큐의 front의 원소를 삭제,반환
# front의 위치(인덱스)를 +1해서 변경한다 
# [0]  [1]  [2]
# 삭제->front rear
```
## 선형 큐
- 1차원 배열을 이용한 큐
    - 큐의크기 : 배열의 크기
    - front : 저장된 첫 원소의 인덱스
    - rear : 저장된 마지막 원소의 인덱스
- 상태 표현
    - 초기: front = rear = -1
    - 공백: front = rear
    - 포화: rear = n-1 (n:배열의 길이) 

## 원형 큐
- 원형 큐의 필요성
    - 선형 큐에서는 삭제를 통해서 front를 뒤로 이동하기 때문에 공간이 있음에도 포화상태가 된다
    - 삭제 할때 마다 이동이 아닌 원소를 앞으로 옮기면 오버헤드가 커서 큐의 효율성이 떨어진다
- 원형큐의 구조
    - 1차원 배열의 처음과 끝이 ***논리적으로 연결되어 있다고 가정***하고 사용 -> 원형 큐
    - 리스트의 마지막 노드에서 ***논리적*** 다음 노드(0변인덱스) 이동을 위해 *리스트의 길이값으로 나머지연산*을 사용, 링크필드를 통해 다음 노드와 연결한 구조의 연결 리스트
        - 2 mod 3 = 2, 5 mod 3 = 2 / 다른 인덱스지만 나머지연산하면 원형 큐를 순환한 것 처럼 같은 인덱스를 가르킨다
    - ***실제로 순환 구조인 것이 아니라 나머지 연산을 통해서 다시 처음 노드의 인덱스로 돌아가는 구조***
- 상태 표현
    - 초기 공백 : front = rear = 0
    - 포화 상태 : front = rear+1
    - 삽입 위치 : (rear+1)mod n
    - 삭제 위치 : (front+1)mod n
    - 공백구분(front=rear)을 위해 front가 있는 자리는 항상 빈자리로 둔다

## 연결 큐
- 단순 연결리스트를 이용한 큐의 구조
    - 큐의 원소 : 연결리스트의 노드
    - 원소의 순서 : 노드의 링크포인터로 연결
    - front : 첫번째 노드를 가리키는 포인터 변수
    - rear : 마지막 노드를 가리키는 포인터 변수
    - 초기, 공백상태 : front = rear = null
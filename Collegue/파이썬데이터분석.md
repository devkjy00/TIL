# 8-3 상관관계와 공분산/ 유일 값, 값 세기, 멤버심

- ## 상관관계(Correlation)
    - 결과 값이 1가까울 수록 A값과 B값이 비례한다
    - 결과 값이 -1에 가까울 수록 A값과 B값이 반 비례한다
    
- ## 공분산(Coavariance)
    - 확률변수가 절대적인 크기에 영향을 받지않도록 일정하게 만드는 것

```py
import pandas_datareader.data as web
# 주가정보를 다운로드 받을 수 있게해주는 라이브러리
all_data = {ticker: web.get_data_yahoo(ticker)
        for ticker in ['AAPL', 'IBM', 'MSFT', 'GOOG', 'TSLA', 'AMZN']}
price = pd.DataFrame({ticker: data['Adj Close'] 
    # Adj Close : 수정 종가
        for ticker, data in all_data.items()})

volume = pd.DataFrame({ticker: data['Volume']
        for ticker, data in all_data.items()}) 
    # 'Volume : all_data에 저장된 종목들의 거래량

returns = price.pct_change()# 퍼센트_체인지
# price에 저장되어있는 주가의 퍼센트 변화율을 반환한다
returns.tail()
# 마지막 5일간의 정보를 반환한다

returns['MSFT'].corr(returns['IBM'])
# .corr() 두객체의 상관관계를 계산하는 메서드
# 상관관계가 1에 가까울 수록 두 주가가 같이 올라가고 같이내려가고, -1에 가까울수록 반비례해서 움직인다는 뜻

returns['MSFT'].cov(returns['IBM'])
# .cov() 두객체의 공분산을 구하는 메서드

returns.corr()
returns.cov()
# 저장된 정보들 의 상관관계, 공분산을 반환

returns.corrwith(returns.IBM)
# .corrwith(): Series,DataFrame과의 상관관계를 계산

returns.corrwith(volume)
# 거래량의 퍼센트 변화율에 대한 상관관계를 계산한다

```
- ### 유일 값, 값 세기, 멤버십
```py
obj = pd.Sries(['c','a','d','a','a','b'])

uniques = obj.unique()
# .unique() : 유일 값을 정렬하지 않고 반환

obj.value_counts()
# .value_counts() : Series에서 중복된 값이 몇개인지 계산

pd.value_counts(obj.values, sort=False)
# 정렬되지 않은 순서로 반환

mask = obj.isin(['b','c'])
# .isin() : 어떤 값이 Series에 존재하는지 각 인덱스를 불리언 벡터로 반환한다.
obj[mask]
# True 값인 인덱스만 반환

```

# 9. 데이터 로딩과 저장, 파일형식
- pandas의 파일 파싱 함수
    - read_csv : 파일, URL 또는 파일과 유사한 객체로부터 구분된 데이터를 읽어 온다. 데이터 구분자는 쉼표(,)를 기본으로 한다.
    - read_table : 파일, URL 또는 파일과 유사한 객체로부터 구분된 데이터를 읽어 온다. 데이터 구분자는 탭('\t')을 기본으로 한다.
    - read_excel : 엑셀 파일에서 표 형식의 데이터를 읽어 온다.
    - read_html : HTML 문서 내의 모든 테이블의 데이터를 읽어 온다.
    - read_clipboard : 클립보드에 있는 데이터를 읽어 온다.
    - read_hdf : pandas에서 저장한 HDF5(binary파일)데이터를 읽어온다
    - JSON 문자열에서 데이터를 읽어온다
    - read_sql : SQL 쿼리 결과를 pandas의 DataFrame 형식으로 읽어온다. 

- pandas파일 파싱함수의 주요 옵션
    - 색인 
        - 반환하는 DataFrame에서 하나이상의 컬럼을 색인으로 지정할 수 있다
        - 파일이나 사용자로부터 컬럼 이름을 받거나 아무것도 받지 않을 수 있다
    - 자료형 추론과 데이터 변환
        - 사용자 정의 값 변환과 비어있는 값을 위한 사용자 리스트를 포함한다.
    - 날짜 분석
        - 여러 컬럼에 걸쳐 있는 날짜와 시간 정보를 하나의 컬럼에 조합해서 결과레 반영한다.
    - 반복 
        - 여러개의 파일에 걸쳐 있는 자료를 반복적으로 읽어 올 수 있다.
    - 정제되지 않은 데이터 처리
        - 로우나 꼬리말, 주석 건너뛰기 또는 천 단위마다 쉼표로 구분된 숫자 같은 것들의 처리

-  *타입추론*
    - pandas.read_csv 같은 함수들은 데이터 형식에 자료형이 포함되어 있지 않은 관계로 타입 추론을 수행한다.

- ###  *텍스트 파일에서 데이터 읽고 쓰기*

    - 먼저 OS의 type명령을 써서 csv파일의 내용을 살펴본다
    ```py
    !type examples\ex1.csv
    # 윈도우
    !cat examples/ex1.csv
    # 리눅스, 유닉스
    ```
    - 쉼표로 구분된 텍스트 데이터 파일은 read_csv 함수를 사용해서 DataFrame으로 읽어올 수 있다.
    ```py
    df = pd.read_csv("/ex1.csv")
    ```
    - 쉼표로 구분된 텍스트 데이터파일은 read_table 함수에 구분자(sep옵션)을 지정해서 DataFrame으로 읽어 올 수 있다.
    ```py
    pd.read_table('ex1.csv', sep=',')
    ```
    - 텍스트 파일에서 DataFrame으로 데이터 읽어 올 때 색인 지정하기
    ```py
    pd.read_csv('ex1.csv', header=None)
    # 로우,컬럼 값이 0,1,2,... 로 생성
    pd.read_csv('ex1.csv', names=['a','b','c','d'], index_col = 'd')
    # names으로 컬럼색인을 생성하고 index_col으로 입력한 컬럼의 값을 인덱스 색인으로 사용할 수 있다.
    ```
- 계층적 색인
    ```py
    pd.read_csv('ex.csv', index_col=['a','b'])
    # 인덱스색인 값을 2개의 계층으로 나눠서 사용 할 수 있다
    # 'a'컬럼 값이 같은 것끼리 묶어서 'b'컬럼값을 정렬한 2계층 인덱스색인이 생성된다
    # 예제
    #       c d f
    # a b 
    # 1 x / 1,2,3
    #   y / 2,4,6
    # 2 z / 1,5,7
    #   q / 2,5,8
    ```
- 구분자없이 공백,다른패턴으로 필드를 구분한 경우
    ```py
    pd.read_table('ex1.txt', sep='\s+')
    # 공백,다른패턴일 경우 '\s+'가 자동적으로 데이터를 구분 시킨다
    ```
- 그 외의 read_csv,reac_table의 함수인자
    - skiprows : 파일의 시작부터 무시할 행의 수 또는 무시할 로우번호가 담긴 리스트
    - na_values : NA값으로 처리할 값들의 목록(컬럼값은 리스트, 컬럼의 특정값은 사전으로 지정한다)
    - comment : 주석으로 분류되어 파싱하지 않을 문자 혹은 문자열
    - thousand : 숫자를 천단위로 끊을 때 사용할 ',' '.' 같은 구분자
#
- ## ***9-2 학습내용***
    - 텍스트 파일 조금씩 읽어오기
    - 데이터를 텍스트로 기록하기
    - 구분자 형식 다루기

### 데이터 출력 설정
```py
pd.options.display.max_rows = 10
# 큰 파일은 자료가 방대하기 때문에 
# 시작5줄+끝5줄씩만 출력하도록 설정

pd.read_csv('~', nrows=5)
# nrows 처음5줄만 출력

chunker = pd.read_csv('~', chunksize=1000)
# 파일을 여러조각으로 나눠서 읽는다
# 1000개씩 나눠서 출력, 나눠진 갯수만큼 iterable한 객체

tot = pd.Series([])
# 중복된 값 세기
for piece in chunker:
    tot = tot.add(piece['key'].value_counts(). fill_value=0)
# 'key' 컬럼의 모든 값을 비교 중복되는 값의 횟수를 반환, 없는 값은 0으로 처리
```
### csv파일 저장하기
```py
# DataFrame을 ','를 구분자로 쓰는 csv로 저장
data.to_csv('dir')

# 파일 기록이 아닌 콘솔에서 출력
import sys
data.to_csv(sys.stdout, sep='|', na_rap='NULL', index=False, header=False)
# na_rap 은 비어있는 값에 넣을 값
# index=False 는 로우색인 삭제
# header=False 는 컬럼색인 삭제

data.to_csv('~', columns=['a','b','c'])
# 입력한 컬럼의 값만 저장한다

dates = pd.date_range('1/2/2021', periods=7)
# 입력한 날짜부터 7번째 날까지 반환  
```

### 구분자 형식 다루기
```py
# 파이썬 내장 모듈
import csv
# 구분자가 한 글자인 파일을 csv.reader함수를 사용해서 읽을 수 있다.
f = open('~.csv')
reader = csv.reader(f)
 
```
#
- ## ***9-3 학습내용***
    - 이진 데이터 형식
    - pickle의 직렬화
    - HDF5파일 형식
    - 엑셀자료 읽어오기
    - 데이터 베이스와 함께 사용하기

### pickle 직렬화
- 직렬화는 이진형식의 데이터로 저장하는 것이다
```py
Dataframe.to_pickle('/frame_pickle')
# to_pickle 메서드로 바이너리 데이터를 저장한다

pd.read_pickle('/frame_pickle')
# read_pickle 메서드로 읽어올수 있다

# pickle 직렬화는 추후 라이브러리 버전이 올라갔을 때 지원되지 않을 수 있기때문에 그다지 권장되지 않는다
```

### HDF5 형식
- 대량의 과학 계산용 배열 데이터를 저장하기위해 고안된 바이너리 형식의 파일포맷
- 파이썬 뿐만 아니라 C,Java 등 여러 언어에서 지원
- 다앙한 압축 기술을 사용해서 실시간 압축을 지원한다
    - 반복되는 패턴을 가지는 데이터를 효과적으로 저장할 수 있다

- ***pandas는 HDFStore 클래스를 통해 객체를 저장할수 있다***
    ```py
    frame = pd.DataFrame({'a':np.random.randn(100)})

    # HDF를 저장할 파일 객체 선언
    f_obj = pd.HDFStore('mydata.h5')

    # 파일객체에 사전형태로 pd객체 저장
    f_obj['obj1'] = frame

    # 원하는 행,열만 저장 (Series)
    f_obj['obj1_col'] = frame['a']

    ```
- HDFStore의 2가지 저장 스키마
    - fixed
        - 디폴트 값으로 사용된다
        - 파일을 저장,불러오는 기능 
    - table
        - 쿼리연산을 지원한다
        - 데이터의 일부를 조회해서 가져올 수 있다
        - 연산이 좀 더 느리다
    ```py  
    # table로 저장된 자료만 쿼리연산을 할수 있다
    f_obj.put('obj2', pd_obj, format='table')
    # put(파일명, 객체, format='table')로 저장

    # 쿼리연산으로 데이터 불러오기
    f_obj.select('obj2', where=['index >= 10 and index <= 15'])
    # select(파일명, where=index)로 불러올 수 있다

    # 파일 닫기
    f_obj.close()


    # table 스키마의 다른 저장,불러오기메서드
    frame.to_hdf('data.h5', 'obj3', format='table')
    # to_hdf(파일명, 키값, 포맷)으로저장
    pd.read_hdf('data.h5', 'obj3', where=['index<4'])
    # read_hdf(파일명, 키값, where)
    ```
### 엑셀 파일 읽어오기
- xls, xlsx 확장자의 파일을 읽어온다
- 엑셀파일 읽기
    ```py
    # 엑셀 파일객체 생성
    xl_obj = pd.Excelfile(파일명.xlsx)
    # Excelfile() 엑셀파일을 파일객체로 반환
    
    # 엑셀 시트 불러오기
    pd.read_excel(xlsx, 'Sheet1')
    # read_excel() 해당시트값들을 반환
    # 시트명이 파일과 일치해야 한다
    
    # 파일에서 시트의 값 바로가져오기
    frame = pd.read_excel(파일명.xls, 'Sheet1')
    # 파일객체를 생성하지 않고 해당 시트의 값을 바로 가져온다
    ```
- 엑셀 파일 저장
    ```py
    # 데이터 저장
    xl_obj = pd.Excelwriter(파일명.xlsx)
    # Excelwriter()메서드로 저장할 파일위치를 객체로 생성
    frame.to_excel(xl_obj, 'Sheet1')
    # to_excel(객체, 시트) 데이터를 파일객체 어느 시트에 저장할지 선언
    xl_obj.save()
    # 객체에 선언된 값 저장


    # 데이터 엑셀에 바로 저장하기
    frame.to_excel(파일명.xlsx)
    # 데이터가 디폴트 시트에 바로 저장된다
    ```
### 데이터베이스와 함께 사용하기 
- 관계형 데이터베이스에서 SQL로 데이터를 읽어와서 DataFrame에 저장할 수 있다
- 파이썬 내장 sqlite3 드라이버를 이용해서 SQLite 데이터베이스를 이용할 수 있다
    
    ```py
    import sqlite3
    
    # 쿼리 언어를 사용해서 값 선언
    query1 = """.CREATE TABLE test
    (a VARCHAR(20), b VARCHAR(20),
    c REAL, d INTEGER);"""
    # a,b,c,d 4개의 컬럼 생성
    # 각 컬럼의 자료형 선언

    # 만들어진 TABlE을 삭제하는 값
    query2 = "DROP TABLE test"

    # DB와 연결하기위해 경로객체를 생성
    con = sqlite3.connect('mydata.sqlite')
    # connect(경로명) DB와 연결할 경로명을 선언

    # 경로객체를 통해서 쿼리값 전달
    con.execute(query1)
    # 경로객체.execute(쿼리값) DB에 쿼리를 보낸다

    # 실행된 결과값 확인
    con.commit()

    # 실행 취소
    con.rollback()


    # 생성된 test테이블에 데이터 입력
    data = [('a','b',1.2,5),
        ('c','d',1.2,5),
        ('x','y',1.2,5)]
    
    # 쿼리언어 명령어 선언
    stmt = "INSERT INTO test VALUES(?, ?, ?, ?,)"
    # 컬럼 개수만큼 (?) 추가

    # 데이터 저장
    con.excutemany(stmt, data)
    #excutemany(명령어, 값) TABLE에 값저장

    # 입력된 값 실행
    con.commit()

    # 값 불러오기
    cursor = con.execute('select * from text')
    # select * 모든 값 가져오기
    # *에 행의 위치를 넣을 수 있다
    # cursor는 조회한 데이터를 임시로 보관하는 
    # 곳이다(장바구니 같은의미)

    rows = cursor.fetchall()
    # fetchall() 메서드로 
    # cursor에 저장된 값을 튜플리스트형태로 반환한다

    # 값의 여러가지 속성확인
    cursor.description
    

    ```

# 10. 데이터 정제 및 준비
- ## 10-1 학습내용
    - pandas 누락된 데이터 처리 함수, 제외하기
    - pandas 결측치(NaN) 채우기

누락된 데이터 처리하기
- pandas객체는 모든 기술 통계에서 결측치는 배제하고 처리한다

- 산술 데이터는 누락된 데이터를 NaN으로 취급한다
```py
from numpy import nan
string_data = pd.Series(['a','b',np.nan])
# np.nan은 NaN(null)으로 처리된다
```

- R프로그래밍 언어에서는 결측치를 NA로 정의한다
> 결측치
- NA, null, NaN, None 같은 값이다

NA처리 메서드
- *dropna* : 누락된 데이터가 이는 축(로우,컬럼)을 제외
- *fillna* : 누락된 데이터를 대신할 값을 채우거나 'ffill' 이나 'bfill' 같은 보간 메서드를 적용
- *isnull* : 누락되거나 NA인 값을 찾아서 블리언 값이 저장된 같은 형의 객체로 반환
- *notnull* : isnull과 반대되는 메서드



```py
from numpy import nan as NA
# NA 로 명을 바꿈

# 결측치 제외하기
data = pd.Series([1,NA,2,NA])
data.dropna()
# 결측치를 빼고 반환

data[data.notnull()]
# 결측치가 아닌 값만 참을 반환해서 값을 반환

data = pd.DataFrame([[1,NA,2,NA],
                     [NA,1,2,NA]])
data.dropna()
# 결측치가 포함된 행은 전부 제외하고 반환
data.dropna(how=all, axis=1)
# axis=1 열을 기준으로연산(디폴트는 행)
# how=all 축(행,열)의 값이 전부 결측치 일때만 제외

data.dropna(thresh=1)
# thresh=1 축의 값이 1개 이상 이면 반환


# 결측치 채우기
data.fillna(1)
# 결측치를 1로 채운다
data.fillna({1:2,2:1})
# 1열은 2를, 2열은 1을 채운다
data.fillna(method='ffill', limit=2, inplace=True)
# method='ffill'은 이전 축의 값으로 채운다, 'bfill'은 뒤의 축의 값으로 채운다
# limit=2 값을 앞 혹은 뒤부터 몇개까지 채울지 결정
# inplace=True 는 원본객체의 값을 바꾼다(디폴트는 False)

```

## 10-2 학습 내용
- DataFrame 중복 제거하기
- DataFrame 컬럼,Series 배열 내의 데이터 변형하기
- Series객체 값 치환하기

### 중복값 제거하기

```py
import pandas as pd
import numpy as np

data = pd.DataFrame({'k1': ['one', 'two'] * 3 + ['two'],'k2': [1, 1, 2, 3, 3, 4, 4]})

print(data.duplicated())
# duplicated() 로우(행)값이 전부 중복인지 아닌지 
# 블리언 Series객체반환

print(data.drop_duplicates())
# drop_duplicates() 중복된 로우(행)이 제거된 
# DataFrmae객체를 반환

data['v1'] = range(7)
print(data.drop_duplicates(['k1']))
# ['k1']컬럼에서 중복되는 값을 가진 로우는 전부 삭제

print(data.drop_duplicates(['k1', 'k2'], keep='last'))
# keep = 'last' 중복되는 값중 나중에 인덱스 값을
#  살리고 이전 값을 삭제

```

### 함수나 매핑을 이용해서 데이터 변형하기

```py
data = pd.DataFrame({'food': ['A', 'B', 'A', 'C', 'D', 'a', 'd'],
                     'ounces': [4, 3, 12, 6, 7.5, 8, 3]})

str_to_food = {
    'A': 'Apple',
    'B': 'Banana',
    'C': 'Candy',
    'D': 'Do'
}

uppercased = data['food'].str.upper()
# str.upper(),lower() 해당 컬럼의 문자열을 대,소문자로 변환

data['animal'] = uppercased.map(str_to_food)
# pandas.map(사전) pd의 1차원 배열값을 
# 함수가 아닌 사전의 키값으로 대입해서 연결된 밸류를 반환한다
# 데이터의 요소별 변환 및 데이터를 다듬는 작업을 편하게 수행

data['food'].map(lambda x : str_to_food[x.upper()])
# map(a, b)가 아니라 b.map(a)형식으로 
# 사전키값이 아닌 함수로 대입을 했다
```

## 값 치환하기

```py
data = pd.Series([1., -999., 2., -999., -1000., 3.])
print(data.replace(-999, np.nan))
# replace([a],[b]) 같은 인덱스의 a값을 
# 전부 같은 인덱스의 b값으로 바꾼다, {a:b}사전형도 가능
```

## 10-3 학습내용
- 축 색인 이름 바꾸기
- 개별화와 양자화
- 연속성 데이터 구간별로 구분하기
- Categorical 객체
- cut, qcut함수

## 축 색인 이름 바꾸기
- DataFrame은 축이름을 함수나 다른 변수를 이용해서 바꿀 수 있다
```py
import numpy as np
import pandas as pd

data = pd.DataFrame(np.arange(12).reshape((3, 4)), index=[
                    'a', 'b', 'c'], columns=[1, 2, 3, 4])

def tranform(x): return x.upper()
data.index = data.index.map(tranform)
# map을 이용해서 index값만 함수에 
# 넣어서 변환후 다시 index에 대입했다


print(data.rename(index=str.title, columns=str.upper))
# rename(index,columns)로 간단하게 색인 값을 변경할 수 있다
# str은 원본값을 의미 title은 문자열의 첫글자만 대문자로 만드는 메소드

data.rename(index={'a': 'AA'}, columns={'one': 'first'}, inplace=True)
# 사전형으로 색인값 변환, inplace로 원본객체를 바꿘다
```

## 개별화와 양자화
- 연속성데이터는 필요에 따라 개별로 분활하거나 분석을 위해 그룹별로 나눌 수 있다

- ## Categorical 객체
    - 각 데이터가 속하는 *카테고리의 번호*를 배열로가지는 codes 속성
    - Interval Index객체로서 *분류 간격에대한 정보*를 가지는 categories속성 

```py
ages = [20, 22, 25, 27, 21, 23, 37, 31, 61, 45, 41, 32]

bins = [18, 25, 35, 60, 100]
cats = pd.cut(ages, bins)
# bins의 [0],[1]로 하나의 카테고리 생성 (18, 25] 18초과, 25이하
# cut(대입할시퀀스, 기준값시퀀스) 기준값으로 대입한 값이 어떤 카테고리에 속하는지 연산후,
# 카테고리 값을 대입한값의 인덱스와 같게 반환한다(Categorical 객체)

print(cats.codes)
# 데이터가 속한 카테고리의 인덱스를 값으로 반환
print(cats.categories)
# 기준이되는 카테고리를 반환
print(pd.value_counts(cats))
# 카테고리별로 몇개의 value를 가지고 있는지 반환

pd.cut(ages, [15, 24, 36, 57, 100], right=False)
# right=False 는 (]초과,이하 -> [)이상,미만 으로 바뀐다

group = ['Youth', 'YoungAdult', 'MiddleAged', 'Senior']
print(pd.cut(ages, bins, labels=group))
# 카테고리 인덱스와 같은 labels인덱스의 값을 대신 반환한다

print(pd.cut(ages, 4, precision=2))
# precision=2 는 소수점 2자리까지 표시한다
# 카테고리값이 아니라 그룹의 개수(4)를 넘겨주면 
# 최소값과 최대값을 기준으로 균등한 길이의 그룹을 자동계산

data = np.random.randn(1000) # 정규 분포
cats = pd.qcut(data, 4)     # 4분위로 분류
# qcut은 각 그룹의 데이터수가 비슷하도록 카테고리를 나눠준다
print(pd.value_counts(cats))
# 각 그룹이 250개의 데이터를 가짐

pd.qcut(data, [0, 0.1, 0, 5, 0.9, 1.])
# 각 그룹의 데이터수를 퍼센트 별로 따라서 나눠준다
```

## 11-1 학습내용
- matplotilb라이브러리
- 기본 그래프 그리기/ *plt.plot*
- 그래프에 색상,선,마커 옵션 추가/ *'r*:'

> matplotlib 
- 파이썬에서 2D 형태의 그래프, 이미지 등을 그릴 때 사용
- 실제 과학 컴퓨팅 연구 분야나 인공지능 연구분야에서 많이 활용

## mataplotlib
- pyplot 모듈 사용하기
    ```py
    import matplotlib.pyplot as plt

    plt.plot([10, 20, 30, 40],'red' , lebel='asc')
    # plot() x 좌표는 인덱스, y좌표는 값으로 표현
    # lebel='asc' 범례(그래프선에 이름을 정의)를 표시
    # color='red' 그래프선의 색 정의
    plt.legend(loc=1)
    # 1,2,3,4: 모서리
    # (5,7),6,8,9: 왼,오,위,아래
    # 해당 위치에 범례를 표시 ,5가 디폴트
    plt.show()
    # 설정한 그래프를 보여준다


    plt.title('graph2')
    # title() 그래프에 이름을 지정
    plt.plot([1, 2, 3, 4], [12, 4, 7, 96],'r:')
    # plot() 첫 인수는 x좌표, 둘째 인수는 y좌표 각 좌표데이터의 개수가 같아야한다
    # 'r:'은 red 점선이라는 의미
    # 'y--'로 yellow 실선을 만들수도있음
    plt.show()


    # 마커로 그래프그리기
    plt.title('marker')
    plt.plot([10, 20, 30, 40], 'r*')
    # 'r*' red 별 모양
    plt.plot([1, 2, 3, 4], 'b>:')
    # 'b>' blue, 방향표 모양,점선
    plt.show()
    ```

## 11-2 학습내용
- 기온 공공데이터 다운로드 받기
- 데이터 읽어오기, 시각화
- 날짜 데이터 추출하기

```py
import matplotlib.pyplot as plt
import csv

f = open('/Users/gimjuyeong/myproject/study/suncheon.csv', encoding='euc-kr')
# 자료에 따라 인코딩 해주기
data = csv.reader(f)
next(data)
# 이터레이터 객체의 이터레이션을 한번 넘겨서 
# 불필요한 데이터를 삭제한다
result = []
date = []
for row in data:
    if (month := row[0].split('.')[1]) == '11':
        result.append(float(row[-1]))  # 기온

plt.figure(figsize=(15, 5))
# figure(figsize=()) 그래프사이즈 인치기준
plt.plot(result,  'r')
plt.show()

f.close()
```

# 11-3 학습내용
- 히스토그램
- 데이터를 히스토그램으로 표현하기
- 데이터를 boxplot으로 표현하기

## plt.hist() 함수
- 히스토그램은 자료의 빈도를 직사각형 모양의 막대 그래프로 나타낸것
- 기온분포도
    ```py
    import matplotlib.pyplot as plt
    import csv

    f = open('/Users/gimjuyeong/myproject/study/suncheon.csv', encoding='euc-kr')
    data = csv.reader(f)
    next(data)

    result = (float(row[-1]) for row in data)
    # 기온의 분포를 확인 할 수 있다
    plt.hist(list(result), bins=100)
    # hist() : 분포상태를 막대그래프로 표현 
    # bin= : 가로축 구간의 개수를 설정
    
    plt.show()
    f.close()
    ```
## boxplot
- 데이터의 빈도를 상자 그림으로 시각화한다
- matplotlib.pyplot.boxplot()
    - 최대값, 최소값, 상위 1/4, 2/4(중간), 3/4에 위치한 값을 보여주는 박스 그래프이다
    ```py
    # ~~ 계속
    result = (float(row[-2]) for row in data) # 최저기온
    plt.boxplot(list(result), showfliers=False)
    # boxplot() : 분포도를 박스그래프로 표현
    # showfliers=False : 아웃라이어 생략
        # outlier : 다른 수치에 비해 너무 크거나 
        # 작은 값을 자동으로(원으로) 나타낸다
    plt.style.use('ggplot')
    # 그래프 스타일 지정
    plt.figure(figsize = (10, 5), dpi=300)
    # 그래프 크기 지정
    plt.show()
  

    ```
    - 복수의 리스트를 그릴때는 다시 리스트로 감싸서 대입해야한다/ [x, y]

# 12-1 학습내용
- 인구 공공데이터 내려받기
- 우리동네 인구구조 조사하기

```py
import matplotlib.pyplot as plt
import pandas as pd
import csv


def get_int(x):
    if "," in x:
        return int(x.replace(",", ""))

with open(
    "/Users/gimjuyeong/myproject/study/202110_202110_연령별인구현황_월간.csv", encoding="euc-kr"
) as f:
    data = list(csv.reader(f))
print([age.split("_")[-1] for age in data[0][229:240]])
print(data[1][126:136])

man_popu = [get_int(i) for i in data[1][126:136]]
woman_popu = [get_int(i) for i in data[1][229:239]]
ages = [age.split("_")[-1] for age in data[0][126:136]]
plt.plot(ages, man_popu, "b:")
plt.plot(ages, woman_popu, "r:")
plt.rc("font", family="Malgun Gothic")  # 타이틀에 font에대한 family속성 지정
plt.title("shucheon 20ages man,woman population")
plt.show()
```

# 12-2 학습내용
- 막대 그래프 그리기, bar()
- 항아리 모양 그래프 그리기


### 막대 그래프 그리기
- bar()
    ```py
    import matplotlib.pyplot as plt

    plt.style.use('default')
    plt.figure(figsize=(6,3))
    plt.bar([0, 1,2,4,6,10],range(6))
    # bar() 길이가 같은 시퀀스 x, y를 둘다 입력해야 한다
    # range()함수를 사용할 수 있다
    plt.show()

    ptl.rcParams('axes.Unicod_minus'=False)
    # -가 깨지지 않도록 설정한다
    ```

- barh()
    - 막대그래프를 수평으로 그린다



# 학습내용 12-3
- 파이 차트 그리기
- 성별 인구 비율 그리기


- pie()
```py
import matplotlib.pyplot as plt
plt.rc('font', family='Malgun Gothic')
# 글 꼴을 정의한다
plt.pie([population.man, population.woman], labels=['man', 'woman']
, autopct='%.2f%%', colors=['skyblue', 'pink'], explode=[0, 0.1], startangle=90)
# pie([값], labels=[값명], autopct='퍼센트'(%%는 %를 출력하기위해 작성), 
# colors=[색]), explode=([파이 자르기 0~1]), starangle=int x도 만큼 원을 돌린다
plt.axis('equal')
# 정 원을 그린다
plt.show()
```




# 1. 사용중인 파이썬의 버전 알아두기
- 파이썬 2는 더이상 지원되지 않는다

# 2. PEP 스타일 가이드를 따르라
- 파이썬 개선 제안(Python Enhancement Proposal)은 코드를 어떤 형식으로 작성할지 알려주는 스타일 가이드다.
    - 일관된 스타일을 사용하면 코드에 더 친숙하게 접근하고 쉽게 읽을 수 있다.

- 공백
    - 탭대신 스페이스로 들여쓰기
    - 문법적으로 중요한 들여쓰기에는 4칸 스페이스 사용
    - 라인 길이는 79개 문자이하
    - 긴 식을 다음줄에 이어 쓸 경우 들여쓰기보다 4칸 더 들여쓰기
    - 파일 안에서 각 함수와 클래스 사이에 빈줄 2줄
    - 메서드와 메서드 사이에는 빈줄 1줄
    - 변수 대입에서 = 전후에는 스페이스 하나씩 /a = 10
    - 타입 표기를 덧붙이는 경우 변수 이름과 콜론 사이에 공백을 넣지 않도록 주의, 콜론과 타입정보사이에는 스페이스 하나 /a: str

- 명명 규약
    - 함수, 변수, 속성은  소문자와 밑줄을 사용
    - 보호되야하는 인스턴스 속성은 언더바 한개로 시작
    - 비공개(한 클래스 안에서만 쓰이고 다른곳에서 쓰면 안되는 경우)인스턴스 속성은 언더바 두개로 시작
    - 클래스명은 언더바 없이 단어앞 대문자사용
    - 모듈 수준의 상수는 ALL_CAPS 처럼 언더바, 모든 글자 대문자

- 식과 문
    - 부정문을 내부에 넣어라(if a is not b.)
    - 빈 컨테이너, 시퀀스를 검사할 때 길이를 0과 비교하지말라, 0은 False, " if not 시퀀스 "와 같이 조건문 쓰기
    - 비어있지 않은 컨테이너나 시퀀스검사는 "if 시퀀스"
    - 한 줄 짜리 if, for, while, except 복합문을 사용하지말라, 명확성을 위해 각각 부분을 여러줄에 나눠 배치하라
    - 식을 한줄안에 다 쓸 수 없는 경우, 식을 괄호로 둘러싸고 줄 바꿈과 들여쓰기를 추가해서 읽기 쉽게 하자
    - 여러 줄에 걸쳐 식을 쓸 때는 줄이 계속된다는 표시를 하는 \문자보다는 괄호를 사용

- import
    - import문은 항상 파일 맨 앞에 적어라
    - 상대적인 이름으로 import하지 말라
        - import foo x -> from bar import foo
        - 어쩔 수 없는 경우 from . import foo
    - 임포트를 적을 떄는 표준, 서드 파티, 커스텀 순서로 섹션을 나누고 각 섹션은 알파벳 순서로하라
    
# 3. bytes와 str차이를 알아두라
- ***bytes : 부호가 없는 8바이트 데이터(아스키 인코딩도 사용됨)***
- ***str : 사람의 문자 유니코드의 코드포인트가 들어있다***
- 유니코드 데이터를 인코딩하거나 디코딩하는 부분을 인터페이스의 가장 먼 경계 지점에 위치시켜라(유니코드 샌드위치), 프로그램의 핵심 부분은 유니코드 데이터가 들어있는 str을 사용해야 하고, 문자 인코딩에 대해 어떤 가정도 해선 안된다
- 문자표현 타임이 둘로 나뉘어 있기 때문에 발생하는 상황
    - UTF-8으로 인코딩된 8비트 시퀀스를 그대로 사용하고 싶은경우
    - 특정 인코딩을 지정하지 않은 유니코드 문자열을 사용하고 싶은 경우
    - ***해결책: 도우미 함수를 사용***
        - bytes나 str 인스턴스를 받아서 항상 str을 반환하는 함수를 사용
        - bytes나 str 인스턴스를 받아서 항상 bytes를 반환하는 함수를 사용
        ```py
        def to_str(bytes_or_str):
            if isinstance(bytes_or_str, bytes):
                value = bytes_or_str.decode('uft-8')
            else:
                value = bytes_or_str
            return value # str 인스턴스를 반환하는 경우
        ```
- 주의 할 점
    - bytes와 str은 비슷해보이지만 호환되지 않기 때문에 타입을 분명하게 해야한다    
    - ***bytes + str, bytes > str 불가능하다***
    - ***%연산자는 각 타입의 형식화 문자열(format string)에 대해 작동하고 str인스턴스를 bytes형식화 문자열에 넘길 수없다 / b'red %s' %'blue' -> 오류***
    - 'red %s' % b'blue' -> 가능은 하지만 red b'blue'와 같이 출력됨
    - 파일핸들과 관련한 연산들이 디폴트로 유니코드 문자열을 요구한다
        ```py
        with open('data.bin', 'w') as f:
            f.write(b'/xf1/xf2/xf3/xf4/xf5')
            # -> TypeError
        ```
        - 이진 쓰기모드('wb')가 아닌 텍스트 쓰기모드('w')로 열었기 때문에 발생한 오류
        - write연산은 이진데이터가 아닌 유니코드데이터가 들어있는 str인스턴스를 요구한다
        - 반대로 바이너리파일을 텍스트 읽기 모드로 열어도 요류가 발생한다
        - 또는 'r' 를 사용하더라도 encoding을 명시해주면 된다

# 4. C 스타일 형식 문자열을  str.format고 쓰기보다는 f-문자열을 통한 인터폴레이션을 사용하라
-  형식화(formatting)
    - 미리 정의된 문자열에 데이터 값을 끼워 넣어서 사람이 보기 좋은 문자열로 저장하는 과정
    - 파이썬에는 4가지 형식화가 있는데 한가지 말고는 큰 단점이 있다
    - 가장 일반적인 방법은 % 형식화 연산자를 사용하는 것, % 왼쪽에 들어가는 텍스트를 형식 문자열이라고 한다
    - 문제점
        - 형식화 식 오른쪽 tuple의 순서를 바꾸거나 값의 타입을 바꾸면 타입변환이 불가하다
        - 형식화를 하기전에 값을 살짝 변경해야 하는 경우 tuple안에 쓰기때문데 연산식을 읽기가 매우 어려워진다
        - 같은 값을 여러번 사용하고 싶다면 tuple에서 같은 값을 여러번 반복해야 한다는 점이다
    - 형식화에 dict를 사용하는 방법
        - tuple 대신에 dict를 사용해 형식화하는 기능이 추가됬다
        ```py
        new way =
        '%(key)-10s = % (value).2f % {
        'key': key, 'value': value}
        ```
        - 순서를 바꾸는 경우나 반복하지 않아도 된다
        - 값을 살짝 변경하기 더 힘들어지고 같은 이름을 반복해서 쓰면서 번잡스러워 진다
        - dict를 따로 선언해서 대입하면 불연속성 때문에 버그를 찾기 힘들고 가독성이 더 나빠진다
    - 내장함수 format, str.format
        - 고급 문자열 형식화 기능으로 format내장 함수를 통해 모든 파이썬 값에 사용할 수있다
        - , 과 ^를 사용해서 값을 형식화 한다
            ```py
            a = 1234.123
            formatted = format(a, ',.2f')
            print(formatted) # -> 1,234.12 천단위, 과 소수2자리
            
            b = '문자열'
            formatted = format(b, '^20s')
            print('*', formatted, '*') # -> *     문자열      *  ^가운데 정렬

            ```
        - 가독성 면에서 차이가 거의 없다
    - ***인터폴레이션(interpolation)을 통한 형식 문자열(f-문자열)***
        - 형식 문자열의 표현력을 극대화, 불필요한 중복 지정 없음
        - 모든 이름을 자유롭게 참조할 수 있도록 허용함으로써 간결함을 제공
        ```py
        formatted = f'{key!r:<10} = {value:2f}'
        print(formatted)   
        ```
        - 형식지정자 옵션을 변수를 사용해서 피라미터화
        ```py
        places = 3
        number = 1.23456
        print(f'내가 고른 숫자는 {number:.{places}f}')
        # -> 내가 고른 숫자는 1.234
        ```

# 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라
- 연산식이 복잡해 지면 도우미 함수를 써서 추상화 하라
- 코드를 줄여 쓰는 것보다 가독성을 좋게 하는 것이 더 가치있다
- boolean연산자 or, and를 식에 사용하는 것보다 if/else식을 쓰는 편이 가독성에 더 좋다

# 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라
- 언패킹을 사용하는 것이 튜플인덱스를 사용하는 것보다 시각적인 잡음이 적다
    ```py
    item = ('호박엿', '식혜')
    print(item[0], item[1]) # 인덱싱
    first, second = item    # 언패킹
    print(first, second)

    ```
    - 언패킹을 사용하면 임시 변수를 정의하지 않고도 값을 맞바꿀 수 있다
    ```py
    a, b = 10, 12
    a, b = b, a
    # 먼저 오른쪽 항이 계산되고 이름없는 튜플에 저장된다
    # 이름없는 튜플을 왼쪽 항에 식별자에 차례 저장한다
    # 그 후 이름없는 튜플은 사라진다
    ```
    - for문 에서 언패킹 활용
    ```py
    snacks = [('베이컨',350), ('도넛', 240)]

    for index, (name, calories) in enumerate(snacks, 1):
        print(f'{index}:{name}은{calories}칼로리입니다.')
    # 다음 과 같이 언패킹을 통해서 직관적이고 간결하게 값을 참조할 수 있다
    ```

# 7. range보다는 enumerate를 사용하라
- range함수는 어떤 정수집합을 iteration할 때 유용하다
- for문에서 순서를 매기기위해 인덱스가 필요할때 range가 아닌 enumerate를 사용하라
    ```py
    for i, value in enumerate(generator, 1):
        # 1부터 시작
        print(f'{i}:{value}')
    ```

# 8. 여러 이터레이터에 대해 나란히 루프를 수행하려면 zip을 활용하라
- zip은 둘 이상의 이터레이터를 지연 계산 제너레이터를 사용해서 묶어준다
- zip 제너레이터는 각 이터레이터에서 다음 값이 들어 있는 튜플을 반환한다
- zip은 이터레이션과 동시에 원소를 하나씩 소비한다 따라서 아주 긴 입력도 메모리 걱정 없이 처리 할 수 있다.
- 주의점
    - zip으로 감싼 이터레이터의 길이가 서로 다르면 짧은 이터레이터가 끝나면 동작을 멈춘다
- itertools로 가장 긴 이터레이션이 끝날때까지 동작하게 할 수 있다
    ``` py
    import itertools

    a = [1,2,3]
    b = [1,2]
    for name, count in itertools.zip_longest(a, b):
        print(a, b)
    # 11/ 22/ 3None이 출력됨
    # fillvalue로 디폴트 값을 정할 수 있다

    ```

# 9. for나 while 루프 뒤에 else블록을 사용하지 말라
- for, while문은 뒤에 else문을 허용하는 특별한 문법을 제공한다
- 동작이 직관적이지 않고 혼동을 야기 할 수 있기 때문에 사용하지 않는다

# 10. 대입식을 사용해 반복을 피하라
- 대입식 정의
    - 대입식(assignment expression)은 왈러스(walrus) 연산자 라고 부른다
    - 이 대입식은 고질적 코드 중복 문제를 해결하기 위해서 파이썬 3.8에서 새롭게 도입된 구몬이다.
    - 일반 대입문은 a = b로 표기하지만 왈러스 연산자는 a := b 라고 쓰고 'a 왈러스 b'라고 읽는다
- 대입식은 대입문이 쓰일 수 없는 위치에서 변수의 값을 대입할 수 있어서 유용하다(if 문의 조건식)
- 대입식의 값은 왈러스 연산자 왼쪽에 있는 식별자에 대입된 값으로 평가된다
```py
fruit = {'사과':10, '레몬': 5}

if count := fruit.get('레몬', 0)
    make_lemonade(count)
# 조건문에서 바로 명령문을 실행해서 값을 대입했다
# 딱 한번 쓰일 변수를 선언하는 것보다 대입식을 쓰는 것이 직관적이고 간결하다
```
- 왈러스 연산자를 사용하면 switch/case문 같은 다중 선택과 비슷한 형식을 만들 수 있다
```py
if (count:= a.get('num1',0)) >= 2:
    pass
elif (count:= a.get('num2',0)) >= 4:)
    pass
elif (count:= a.get('num3',0)) >= 0:
    pass
# 대입식이 없다면 else문에서 대입문으로 선언해야할 변수를 간단하게 구현한다
```
- while문의 조건식에서 각 루프마다 조건식에 새로운 값을 줘야 할때 왈러스연산자를 사용하면 간단하게 할 수 있다
```py
while foods := get_foods()
    for food in foods
        eat(food)
```
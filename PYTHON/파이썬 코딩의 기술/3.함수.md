
# 19. 함수가 여러 값을 반환 하는 경우 절대로 네개의 값 이상을 언패킹하지 말라
- 반환값이 많으면 순서가 바뀌는 실수를 할 수도 있다
- 많은 값을 언패킹하는 것을 피할 수 없다면 가벼운 클래스나 네임드 튜플을 사용하라

# 20. None을 반환하기보다는 예외를 발생시켜라
- 함수에서 None을 반환받아서 조건문에 대입할 경우 함수에서 예상과 다르게 None을 반환하는 경우가 있기때문에 주의 해야 한다
    - None 은 한가지 값만을 위한 반환값이 아니다

- 그래서 조건문에 대입할 값을 None으로 받기 보다 함수내부에서 제대로 된 연산이 일어나지 않으면 예외를 발생시켜라
- 문서에 예외 정보를 기록해 호출자가 예외를 제대로 처리하도록 하라
- 타입 에너테이션을 사용하라

# 21. 변수 영역과 클로저의 상호작용 방식을 이해하라
- 숫자리스트를 정렬하되 몇몇 숫자만 앞쪽에 배치 시키는 방법(중요한 메시지나 예외적인 이벤트를 다른것보다 우선해 표시할때 유용)
    ```py
    # 클로저의 활용
    def sort_priority(values, group):
        found = False
        def helper(x):
            nonlocal found
            if x in group:
                found = True
                # 우선순위를 발견하면 표시
                return (0, x)
            return(1, x)
            # 우선순위는 튜플 앞에 0을 대입해서
            # 비교했을 때 다른 값보다 앞에정렬
        values.sort(key=helper)
        return found
    ```
    - 클로저는 자신의 영역 밖의 변수(nonlocal)를 참조 하는 함수이다
    - 파이썬에서 함수는 일급 시민객체이다
    - 파이썬의 시퀀스 비교규칙
        - 0번 인덱스의 값 비교 -> 같으면 1번 인덱스 비교 -> 반복해서 비교결과를 반환
    - nonlocal문을 사용해서 자유변수 영역의 값을 변경할 수 있지만 간단한 함수가 아니면 사용하지 말라

# 22. 변수 위치 인자를 사용해 시각적인 잡음을 줄여라
- 위치 인자(positional argument)를 가변적으로 받을 수 있으면 함수호출이 더 깔끔해지고 시각적 잡음도 줄어든다(가변인자(varargs), 스타인자(star args)라고도 한다)
    ```py
    def log(message, values):
        values_str = ','join(str(x)for x in values)
        print(f{message}:{values_str})
    log('시간', [1,2])
    # 무조건 모든 인수를 대입해야한다

    def log(message, *values):
        values_str = ','join(str(x)for x in values)
        print(f{message}:{values_str})
    log('시간', 1,2)
    log('끝')
    # 인수에 리스트를 씌우지 않아도 값을 입력하지 않아도 된다
    a = [1,2,3]
    log('x',*a)
    # 시퀀스값을 인수로 넣을때는 *를 사용하면된다
    ```
- 가변적인 위치인자의 문제점
    - 이런 위치인자가 함수에 전달되기 전에 항상 튜플로 변환 된다는 것이다
        - 따라서 제너레이터 객체를 인수로 대입하면 모든 원소를 얻기 위해서 반복한다 이로인해 메모리를 많이 소비하게 될 수 있다 
    - 함수가 새로운 위치 인자를 추가하면 해당 함수를 호출하는 모든 코드를 변경해야만 한다
        - def(a, *b)에서 def(a, b, *c)가 호출할 때 인수로 줬던 모든 변수위치를 변경해야 한다
- *args는 받을 값의 크기가 충분히 작을 때 가장 적합하다
- 위치 인자를 추가할 때 생기는 오류를 없에려면 키워드 기반의 인자만 사용해야 한다

# 19. 함수가 여러 값을 반환 하는 경우 절대로 네개의 값 이상을 언패킹하지 말라
- 반환값이 많으면 순서가 바뀌는 실수를 할 수도 있다
- 많은 값을 언패킹하는 것을 피할 수 없다면 가벼운 클래스나 네임드 튜플을 사용하라

# 20. None을 반환하기보다는 예외를 발생시켜라
- 함수에서 None을 반환받아서 조건문에 대입할 경우 함수에서 예상과 다르게 None을 반환하는 경우가 있기때문에 주의 해야 한다
    - None 은 한가지 값만을 위한 반환값이 아니다

- 그래서 조건문에 대입할 값을 None으로 받기 보다 함수내부에서 제대로 된 연산이 일어나지 않으면 예외를 발생시켜라
- 문서에 예외 정보를 기록해 호출자가 예외를 제대로 처리하도록 하라
- 타입 에너테이션을 사용하라

# 21. 변수 영역과 클로저의 상호작용 방식을 이해하라
- 숫자리스트를 정렬하되 몇몇 숫자만 앞쪽에 배치 시키는 방법(중요한 메시지나 예외적인 이벤트를 다른것보다 우선해 표시할때 유용)
    ```py
    # 클로저의 활용
    def sort_priority(values, group):
        found = False
        def helper(x):
            nonlocal found
            if x in group:
                found = True
                # 우선순위를 발견하면 표시
                return (0, x)
            return(1, x)
            # 우선순위는 튜플 앞에 0을 대입해서
            # 비교했을 때 다른 값보다 앞에정렬
        values.sort(key=helper)
        return found
    ```
    - 클로저는 자신의 영역 밖의 변수(nonlocal)를 참조 하는 함수이다
    - 파이썬에서 함수는 일급 시민객체이다
    - 파이썬의 시퀀스 비교규칙
        - 0번 인덱스의 값 비교 -> 같으면 1번 인덱스 비교 -> 반복해서 비교결과를 반환
    - nonlocal문을 사용해서 자유변수 영역의 값을 변경할 수 있지만 간단한 함수가 아니면 사용하지 말라

# 22. 변수 위치 인자를 사용해 시각적인 잡음을 줄여라
- 위치 인자(positional argument)를 가변적으로 받을 수 있으면 함수호출이 더 깔끔해지고 시각적 잡음도 줄어든다(가변인자(varargs), 스타인자(star args)라고도 한다)
    ```py
    def log(message, values):
        values_str = ','join(str(x)for x in values)
        print(f{message}:{values_str})
    log('시간', [1,2])
    # 무조건 모든 인수를 대입해야한다

    def log(message, *values):
        values_str = ','join(str(x)for x in values)
        print(f{message}:{values_str})
    log('시간', 1,2)
    log('끝')
    # 인수에 리스트를 씌우지 않아도 값을 입력하지 않아도 된다
    a = [1,2,3]
    log('x',*a)
    # 시퀀스값을 인수로 넣을때는 *를 사용하면된다
    ```
- 가변적인 위치인자의 문제점
    - 이런 위치인자가 함수에 전달되기 전에 항상 튜플로 변환 된다는 것이다
        - 따라서 제너레이터 객체를 인수로 대입하면 모든 원소를 얻기 위해서 반복한다 이로인해 메모리를 많이 소비하게 될 수 있다 
    - 함수가 새로운 위치 인자를 추가하면 해당 함수를 호출하는 모든 코드를 변경해야만 한다
        - def(a, *b)에서 def(a, b, *c)가 호출할 때 인수로 줬던 모든 변수위치를 변경해야 한다
- *args는 받을 값의 크기가 충분히 작을 때 가장 적합하다
- 위치 인자를 추가할 때 생기는 오류를 없에려면 키워드 기반의 인자만 사용해야 한다

# 23.키워드 인자로 선택적인 기능을 제공하라

- 위치 기반 인자를 지정하려면 키워드 인자보다 앞에 지정해야 한다.
- 인수로 쓸때 ** 연산자는 여러번 사용할 수도 있지만 겹치는 키값이 없어야 한다
- 인자로 사용해서 모든 키워드 인자를 받아줄 수도 있다
- **키워드 인자의 이점**
    - 코드를 처음 보는 사람에게 함수 호출의 의미를 명확히 알려줄 수 있다
    - 함수정의에서 디폴트 값을 지정할 수 있다
    - 함수가 정의된 대로 동작하도록 하는 디폴트 값을 정의해놓고 그 값을 바꿔서 확장된 새로운 동작을 하도록 만들 수 있다
- 문제점은 키워드 인자를 여전히 위치 인자로 지정할 수 있다는 것이다 따라서 오류를 최소화 하기 위해 키워드 인자는 위치인자로 값을 주면 안된다

# 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라
- 디폴트 인자로 함수를 호출를 호출한 경우
    ```py
    from time import sleep
    from datetime import datetime

    def log(message, when=datetime.now()):
        print(f'{when}:{message}')

    log('안녕!')
    sleep(1)
    log('잘가!')
    # 2021-11-06 13:56:36.063353:안녕!
    # 2021-11-06 13:56:36.063353:잘가!
    # 두 시간이 같다
    ```
    - 함수를 호출할 때마다 디폴트 값이 업데이트 되는 방식으로 작동하지 않는다, 디폴트 값은 모듈을 로드하는 시점에 단 한번만 평가된다, 처음 평가된 값은 호출할때마다 지속적으로 사용된다
    - 함수정의에서 디폴트 값으로 선언된 값을 전역변수라고 생각해도 되는 건가.?


- ***디폴트 값을 None으로 주고 동작을 독스트링에 문서화 하는 방법***
    ```py
    def log(message, when=None):
        """
        메시지와 타임 스탬프를 로그에 남긴다
        Args:
            message : 출력할 메시지
            when : 메시지가 발생한 시각(datetime)
                디폴트 값은 현재 시간이다
        """
        if when is None:
            when = datetime.now()
        print(f'{when}:{message}')

    log('안녕!')
    sleep(1)
    log('잘가!')
    #2021-11-06 14:07:43.373854:안녕!
    #2021-11-06 14:07:44.378919:잘가!
    ```
    - 디폴트인자로 함수를 호출하면 최초만 실행되는 상황을 해결하기 위해 None을 주고 if조건문으로 실행시켰다

- 디폴트 인자 값으로 None을 사용하는 것은 인자가 가변적인 경우 특히 중요함
    ```py
    def is_dict(data, defalut={}):
        if type(data) == dict:
            return data
        else:
            return defalut

    foo = is_dict(1)
    foo['num'] = 1
    bar = is_dict('s')
    bar['str'] = 'a'
    print(foo)
    print(id(foo), id(bar))
    # -> {'num': 1, 'str': 'a'}
    # -> 4375757184 4375757184
    # foo와 bar가 같은 id를 가지고 있다
    ```
    - 디폴트 인자의 값이 한번만 평가되기때문에 다시 반환된 값도 같은 id값을 갖게 된다, 
    - 따라서 디폴트 인자로 설정된 값을 절대 return하면 안된다 
    - 해결방안
        - ***아까와 같이 이 문제도 독스트링에 동작방식을 기술하고 디폴트 값을 None으로 설정하고 함수 내에서 값을 선언해 줘야 한다***
        - 타입 애너테이션을 사용해도 잘작동한다

# 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라
- 복잡한 함수의 경우 호출자가 키워드만 사용하는 인자를 통해 의도를 명확히 밝히도록 요구하는 편이 좋다(*활용)
    ```py
    def print_text(text, *, ignore=False):
        if ignore:
            print(text)
        else:
            print('ignore')


    print_text('text', ignore=True)
    # 키워드를 명시한 경우 정상적으로 실행된다
    print_text('text', True)
    # *뒤에 있는 키워드인자는 위치인자로 값을 줄수 없다
    ```
    - 문제는 사용자가 *앞의 필수인자의 위치와 키워드를 혼동할 수 있다는 것이다

- 위치로만 지정하는 인자를 선언(/활용)
    ```py
    def print_text(text, /, *, ignore=False):
        if ignore:
            print(text)
        else:
            print('ignore')


    print_text(text='text', ignore=True)
    # / 앞에 정의된 위치인자는 키워드로 값을 줄 수 없다
    print_text('text', ignore=True)
    # 정상 작동
    ```
    - 함수 정의에서 맨앞의 필수 인자는 호출하는 쪽과 분리됐다, 따라서 해당 피라미터 이름을 바꿔도 상관없다

- 이렇듯 / 과 * 를 사용함으로써 두 인자전달방식을 모두 사용하면서 또 가독성을 높이고 원하지 않는 상황을 줄일 수 있다
- 또한 / 과 * 사이에 인자를 정의 하면 위치,키워드 둘다 사용가능해진다

# 26.functools.wrap을 사용해 함수 데코레이터를 정의하라
- 데코레이터는 자신이 감싸고 있는 함수의 입력인자, 반환값, 오류등에 접근할 수 있다
- @로 wraping하는 것은 데코레이터가 반환한 함수를 데코레이터로 감싼 함수의 영역에서 같은 이름으로 등록되는 것과 같다
    - func = decorator(func) 

- 문제점
    - wrapper로 감싸진 함수는 더이상 원래 이름으로 정의 되지 않는다 
        - funtion decorator.<```locals```>.wrapper at ~~~와같이 객체명을 반환함
    - 데코레이터로 인해 wrapper함수가 모듈에 감싸진 함수의 이름으로 등록 된다, 객체 자체가 바뀌게 되는 것
        - help내장함수를 쓰면 함수의 독스트링이 출력되야 하는데 wrapping된 함수는 wrapper함수의 정보를 출력하게 된다
    
    - 이런 동작은 함수의 위치를 찾을수 없게 되기 때문에 직렬화가 깨지거나 디버거와 같이 인트로스팩션을 하는 도구에서 문제가 된다
    > 인트로스펙션(Introspection)
    - 실행 시점에 프로그램이 어떻게 실행되는지 관찰하는 것을 뜻한다

- 해결방안
    - functools 내장 모듈에 정의된 wraps 도우미 함수를 사용하는것이다, 이 함수는 데코레이터 작성을 돕는 데코레이터 이다
    - wraps를 wrapper 함수에 적용하면 wraps가 데코레이터 내부에 들어가는 함수에서 중요한 메타데이터를 복사해 wrapper함수에 적용해준다
    ```py
    from functools import wraps


    def deco(func):

        @wraps # wraps로 메타데이터복사해서 적용하기
        def wrapper(*a, **b):
            x = print_text(*a, **b)
            print(x)
        return wrapper

    @deco
    def print_text():
        print('text')
        return 'wrapping'

    help(print_text)
    # 정상적으로 함수의 데이터를 출력한다
    ```
    - wraps가 함수의 모든 속성을 제대로 복사해서 적용해주기 때문에 함수가 제대로 동작한다
    - pickle 객체 직렬화도 제대로 작동한다



# 1. 사용중인 파이썬의 버전 알아두기
- 파이썬 2는 더이상 지원되지 않는다

# 2. PEP 스타일 가이드를 따르라
- 파이썬 개선 제안(Python Enhancement Proposal)은 코드를 어떤 형식으로 작성할지 알려주는 스타일 가이드다.
    - 일관된 스타일을 사용하면 코드에 더 친숙하게 접근하고 쉽게 읽을 수 있다.

- 공백
    - 탭대신 스페이스로 들여쓰기
    - 문법적으로 중요한 들여쓰기에는 4칸 스페이스 사용
    - 라인 길이는 79개 문자이하
    - 긴 식을 다음줄에 이어 쓸 경우 들여쓰기보다 4칸 더 들여쓰기
    - 파일 안에서 각 함수와 클래스 상이에 빈줄 2줄
    - 메서드와 메서드 사이에는 빈줄 1줄
    - 변수 대입에서 = 전후에는 스페이스 하나씩 /a = 10
    - 타입 표기를 덧붙이는 경우 변수 이름과 콜론 사이에 공백을 넣지 않도록 주의, 콜론과 타입정보사이에는 스페이스 하나 /a: str

- 명명 규약
    - 함수, 변수, 속성은  소문자와 밑줄을 사용
    - 보호되야하는 인스턴스 속성은 언더바 한개로 시작
    - 비공개(한 클래스 안에서만 쓰이고 다른곳에서 쓰면 안되는 경우)인스턴스 속성은 언더바 두개로 시작
    - 클래스명은 언더바 없이 단어앞 대문자사용
    - 모듈 수준의 상수는 ALL_CAPS 처럼 언더바, 모든 글자 대문자

- 식과 문
    - 부정문을 내부에 넣어라(if a is not b.)
    - 빈 컨테이너, 시퀀스를 검사할 때 길이를 0과 비교하지말라, 0은 False, " if not 시퀀스 "와 같이 조건문 쓰기
    - 비어있지 않은 컨테이너나 시퀀스검사는 "if 시퀀스"
    - 한 줄 짜리 if, for, while, except 복합문을 사용하지말라, 명확성을 위해 각각 부분을 여러줄에 나눠 배치하라
    - 식을 한줄안에 다 쓸 수 없는 경우, 식을 괄호로 둘러싸고 줄 바꿈과 들여쓰기를 추가해서 읽기 쉽게 하자
    - 여러 줄에 걸쳐 식을 쓸 때는 줄이 계속된다는 표시를 하는 \문자보다는 괄호를 사용

- import
    - import문은 항상 파일 맨 앞에 적어라
    - 상대적인 이름으로 import하지 말라
        - import foo x -> from bar import foo
        - 어쩔 수 없는 경우 from . import foo
    - 임포트를 적을 떄는 표준, 서드 파티, 커스텀 순서로 섹션을 나누고 각 섹션은 알파벳 순서로하라
    
# 3. bytes오 str차이를 알아두라
- ***bytes : 부호가 없는 8바이트 데이터(아스키 인코딩도 사용됨)***
- ***str : 사람의 문자 유니코드의 코드포인트가 들어있다***
- 유니코드 데이터를 인코딩하거나 디코딩하는 부분을 인터페이스의 가장 먼 경계 지점에 위치시켜라(유니코드 샌드위치), 프로그램의 핵심 부분은 유니코드 데이터가 들어있는 str을 사용해야 하고, 문자 인코딩에 대해 어떤 가정도 해선 안된다
- 문자표현 타임이 둘로 나뉘어 있기 때문에 발생하는 상황
    - UTF-8으로 인코딩된 8비트 시퀀스를 그대로 사용하고 싶은경우
    - 특정 인코딩을 지정하지 않은 유니코드 문자열을 사용하고 싶은 경우
    - ***해결책: 도우미 함수를 사용***
        - bytes나 str 인스턴스를 받아서 항상 str을 반환하는 함수를 사용
        - bytes나 str 인스턴스를 받아서 항상 bytes를 반환하는 함수를 사용
        ```py
        def to_str(bytes_or_str):
            if isinstance(bytes_or_str, bytes):
                value = bytes_or_str.decode('uft-8')
            else:
                value = bytes_or_str
            return value # str 인스턴스를 반환하는 경우
        ```
- 주의 할 점
    - bytes와 str은 비슷해보이지만 호환되지 않기 때문에 타입을 분명하게 해야한다    
    - ***bytes + str, bytes > str 불가능하다***
    - ***%연산자는 각 타입의 형식화 문자열(format string)에 대해 작동하고 str인스턴스를 bytes형식화 문자열에 넘길 수없다 / b'red %s' %'blue' -> 오류***
    - 'red %s' % b'blue' -> 가능은 하지만 red b'blue'와 같이 출력됨
    - 파일핸들과 관련한 연산들이 디폴트로 유니코드 문자열을 요구한다
        ```py
        with open('data.bin', 'w') as f:
            f.write(b'/xf1/xf2/xf3/xf4/xf5')
            # -> TypeError
        ```
        - 이진 쓰기모드('wb')가 아닌 텍스트 쓰기모드('w')로 열었기 때문에 발생한 오류
        - write연산은 이진데이터가 아닌 유니코드데이터가 들어있는 str인스턴스를 요구한다
        - 반대로 바이너리파일을 텍스트 읽기 모드로 열어도 요류가 발생한다
        - 또는 'r' 를 사용하더라도 encoding을 명시해주면 된다

# 4. C 스타일 형식 문자열을  str.format고 쓰기보다는 f-문자열을 통하 인터폴레이션을 사용하라
-  형식화(formatting)
    - 미리 정의된 문자열에 데이터 값을 끼워 넣어서 사람이 보기 좋은 문자열로 저장하는 과정
    - 파이썬에는 4가지 형식화가 있는데 한가지 말고는 큰 단점이 있다
    - 가장 일반적인 방법은 % 형식화 연산자를 사용하는 것, % 왼쪽에 들어가는 텍스트를 형식 문자열이라고 한다
    - 문제점
        - 형식화 식 오른쪽 tuple의 순서를 바꾸거나 값의 타입을 바꾸면 타입변환이 불가하다
        - 형식화를 하기전에 값을 살짝 변경해야 하는 경우 tuple안에 쓰기때문데 연산식을 읽기가 매우 어려워진다
        - 같은 값을 여러번 사용하고 싶다면 tuple에서 같은 값을 여러번 반복해야 한다는 점이다
    - 형식화에 dict를 사용하는 방법
        - tuple 대신에 dict를 사용해 형식화하는 기능이 추가됬다
        ```py
        new way =
        '%(key)-10s = % (value).2f % {
        'key': key, 'value': value}
        ```
        - 순서를 바꾸는 경우나 반복하지 않아도 된다
        - 값을 살짝 변경하기 더 힘들어지고 같은 이름을 반복해서 쓰면서 번잡스러워 진다
        - dict를 따로 선언해서 대입하면 불연속성 때문에 버그를 찾기 힘들고 가독성이 더 나빠진다
    - 내장함수 format, str.format
        - 고급 문자열 형식화 기능으로 format내장 함수를 통해 모든 파이썬 값에 사용할 수있다
        - , 과 ^를 사용해서 값을 형식화 한다
            ```py
            a = 1234.123
            formatted = format(a, ',.2f')
            print(formatted) # -> 1,234.12 천단위, 과 소수2자리
            
            b = '문자열'
            formatted = format(b, '^20s')
            print('*', formatted, '*') # -> *     문자열      *  ^가운데 정렬

            ```
        - 가독성 면에서 차이가 거의 없다
    - 인터폴레이션(interpolation)을 통한 형식 문자열(f-문자열)
        - 형식 문자열의 표현력을 극대화, 불필요한 중복 지정 없음
        - 모든 이름을 자유롭게 참조할 수 있도록 허용함으로써 간결함을 제공
        ```py
        formatted = f'{key!r:<10} = {value:2f}'
        print(formatted)   
        ```
        - 형식지정자 옵션을 변수를 사용해서 피라미터화
        ```py
        places = 3
        number = 1.23456
        print(f'내가 고른 숫자는 {number:.{places}f}')
        # -> 내가 고른 숫자는 1.234
        ```

# 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라
